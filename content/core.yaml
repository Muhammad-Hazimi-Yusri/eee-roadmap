# EEE Roadmap - Core Track
# Human-editable source. Auto-converts to JSON on build.

meta:
  title: Core Topics
  description: The meat of EE. Analog, digital, signals, embedded.
  icon: sun
  featured: true
  category: core
  order: 2

sections:
  - id: analog-electronics
    title: Analog Electronics
    items:
      - id: transistors
        title: Transistors (BJT & MOSFET)
        description: >-
          The building blocks of amplification and switching. BJTs are current-controlled,
          MOSFETs are voltage-controlled. Understanding both lets you choose the right
          device for your application.
        prerequisites:
          - fundamentals/dc-circuits/DC Circuits
          - fundamentals/diodes/Diodes basics
        outcomes:
          - Bias BJT and MOSFET circuits for linear operation
          - Analyze small-signal amplifier behavior
          - Design basic switching circuits
          - Read transistor datasheets effectively
        concepts:
          - name: BJT biasing
            notes: |
              BJT biasing establishes the DC operating point (Q-point) for linear amplification.
              The goal is to set $I_C$ and $V_{CE}$ in the active region where the transistor
              amplifies without distortion.

              **The Four Operating Regions:**
              - **Cutoff**: Both junctions reverse-biased, $I_C \approx 0$
              - **Active**: B-E forward, B-C reverse — this is where amplification happens
              - **Saturation**: Both junctions forward-biased, transistor acts as closed switch
              - **Breakdown**: Excessive voltage destroys the device

              **Key Relationships:**

              $$I_C = \beta I_B$$

              $$I_E = I_C + I_B = (\beta + 1)I_B$$

              $$I_C = I_S e^{V_{BE}/V_T}$$

              where $V_T \approx 26mV$ at room temperature and $\beta$ typically ranges from 50-300.

              **Common Biasing Configurations:**
              - **Fixed bias**: Simple but unstable — $I_C$ varies wildly with $\beta$
              - **Voltage divider bias**: Most common, provides good stability
              - **Emitter feedback**: Resistor $R_E$ stabilizes against $\beta$ variations

              ![Voltage divider bias circuit](https://upload.wikimedia.org/wikipedia/commons/8/81/Voltage_divider_bias.svg)

              The load line on the I-V characteristic shows all possible operating points.
              Where the load line intersects the base current curve determines the Q-point.

              ![BJT I-V characteristics](https://upload.wikimedia.org/wikipedia/commons/6/6d/Output_characteristic_common-emitter_silicon_transistor-en.svg)

              **Design Rule of Thumb:** For voltage divider bias, make the divider current
              at least 10× the base current to minimize loading effects.

              ![MIT OCW BJT Fundamentals](/pdfs/mit-bjt-fundamentals.pdf)

              For more depth, see [All About Circuits BJT Chapter](https://www.allaboutcircuits.com/textbook/semiconductors/chpt-4/bipolar-junction-transistors/).

          - name: MOSFET operation
            notes: |
              MOSFETs are voltage-controlled devices — the gate voltage creates an electric
              field that modulates channel conductivity. No gate current flows (in DC), giving
              extremely high input impedance.

              **Structure and Physics:**
              The gate is insulated from the channel by a thin oxide layer. Applying $V_{GS} > V_{th}$
              creates an inversion layer (channel) between source and drain.

              ![MOSFET cross-section](https://upload.wikimedia.org/wikipedia/commons/7/79/Lateral_mosfet.svg)

              **Operating Regions:**

              | Region | Condition | Drain Current |
              |--------|-----------|---------------|
              | Cutoff | $V_{GS} < V_{th}$ | $I_D \approx 0$ |
              | Linear (Triode) | $V_{GS} > V_{th}$, $V_{DS} < V_{GS} - V_{th}$ | $I_D = \mu_n C_{ox} \frac{W}{L}\left[(V_{GS}-V_{th})V_{DS} - \frac{V_{DS}^2}{2}\right]$ |
              | Saturation | $V_{GS} > V_{th}$, $V_{DS} \geq V_{GS} - V_{th}$ | $I_D = \frac{1}{2}\mu_n C_{ox} \frac{W}{L}(V_{GS}-V_{th})^2$ |

              **The Saturation Equation (Square Law):**

              $$I_D = \frac{1}{2}\mu_n C_{ox} \frac{W}{L}(V_{GS}-V_{th})^2(1 + \lambda V_{DS})$$

              where $\lambda$ is the channel-length modulation parameter.

              ![MOSFET I-V characteristics](https://upload.wikimedia.org/wikipedia/commons/1/1d/IvsV_mosfet.svg)

              **Enhancement vs Depletion:**
              - Enhancement mode (most common): Channel forms when $V_{GS} > V_{th}$
              - Depletion mode: Channel exists at $V_{GS} = 0$, removed by negative $V_{GS}$

              **Why MOSFETs Dominate Digital:**
              - Near-zero static power (no gate current)
              - Easy to fabricate complementary pairs (CMOS)
              - Scales well with smaller geometries

              For switching applications, the goal is to operate fully in cutoff or deep
              in the linear region (as a closed switch with low $R_{DS(on)}$).

          - name: Small-signal models
            notes: |
              Small-signal analysis linearizes transistor behavior around the Q-point.
              We replace the nonlinear device with a linear equivalent circuit valid for
              small AC variations.

              **The Hybrid-Pi Model (BJT):**

              ![BJT hybrid-pi model](https://upload.wikimedia.org/wikipedia/commons/d/dd/NPN_BJT_Hybrid_Pi_model_common-emitter_high_frequency.svg)

              Key parameters:

              $$g_m = \frac{I_C}{V_T} \approx 40 \cdot I_C \text{ (at room temp)}$$

              $$r_\pi = \frac{\beta}{g_m} = \frac{V_T}{I_B}$$

              $$r_o = \frac{V_A}{I_C}$$

              where $V_A$ is the Early voltage (typically 50-100V).

              **MOSFET Small-Signal Model:**

              ![MOSFET small-signal model](https://upload.wikimedia.org/wikipedia/commons/7/7e/MOSFET_small_signal.svg)

              $$g_m = \frac{2I_D}{V_{GS} - V_{th}} = \sqrt{2\mu_n C_{ox} \frac{W}{L} I_D}$$

              $$r_o = \frac{1}{\lambda I_D}$$

              **Using Small-Signal Models:**
              1. Find DC operating point (bias analysis)
              2. Replace transistor with small-signal model
              3. Short all DC voltage sources, open DC current sources
              4. Analyze resulting linear circuit

              **Voltage Gain (Common-Emitter/Source):**

              $$A_v = -g_m(r_o \| R_L)$$

              The negative sign indicates phase inversion.

              **Miller Effect:** Feedback capacitance $C_\mu$ (or $C_{gd}$) appears multiplied
              at the input: $C_{Miller} = C_\mu(1 + g_m R_L)$. This often dominates
              high-frequency response.

          - name: Saturation vs active region
            notes: |
              Understanding operating regions is critical for both amplifier design
              (stay in active) and switching circuits (transition through regions quickly).

              **BJT Regions Summary:**

              | Region | B-E Junction | B-C Junction | Use |
              |--------|--------------|--------------|-----|
              | Cutoff | Reverse | Reverse | OFF switch |
              | Active | Forward | Reverse | Amplification |
              | Saturation | Forward | Forward | ON switch |
              | Reverse Active | Reverse | Forward | Rarely used |

              **Detecting Saturation (BJT):**
              In saturation, $V_{CE(sat)} \approx 0.1-0.3V$ regardless of base current.
              The transistor can't sink more collector current — it's "bottomed out."

              $$I_C < \beta I_B \text{ (saturated)}$$
              $$I_C = \beta I_B \text{ (active)}$$

              **MOSFET Regions:**

              The "saturation" terminology is confusingly opposite to BJTs:
              - MOSFET **saturation** = constant current region (used for amplification)
              - MOSFET **linear/triode** = resistive region (used for switching)

              **Boundary Condition:**

              $$V_{DS} = V_{GS} - V_{th} \text{ (edge of saturation)}$$

              ![Operating regions on I-V curve](https://upload.wikimedia.org/wikipedia/commons/1/1d/IvsV_mosfet.svg)

              **Practical Implications:**
              - **Amplifiers**: Bias in active/saturation region with margin
              - **Switches**: Drive hard into cutoff or ohmic region
              - **Power dissipation**: Highest during transitions through active region

        resources:
          - label: All About Circuits - BJT
            url: https://www.allaboutcircuits.com/textbook/semiconductors/chpt-4/bipolar-junction-transistors/
          - label: All About Circuits - MOSFET
            url: https://www.allaboutcircuits.com/textbook/semiconductors/chpt-7/insulated-gate-field-effect-transistors-mosfet/
          - label: MIT OCW 6.002
            url: https://ocw.mit.edu/courses/6-002-circuits-and-electronics-spring-2007/

      - id: op-amps
        title: Operational Amplifiers
        description: >-
          The Swiss Army knife of analog design. Two simple rules (virtual short, no input
          current) let you build amplifiers, filters, comparators, and more. Master the
          741 and its modern successors.
        prerequisites:
          - fundamentals/dc-circuits/DC Circuits
          - fundamentals/ac-circuits/AC Circuits
        outcomes:
          - Design inverting and non-inverting amplifiers
          - Build active filters and integrators
          - Understand op-amp limitations (bandwidth, slew rate)
          - Select appropriate op-amps for specific applications
        concepts:
          - name: Virtual short
            notes: |
              The "virtual short" is the most powerful concept for analyzing op-amp circuits.
              With negative feedback, the op-amp adjusts its output to keep both inputs
              at the same voltage.

              **The Two Golden Rules (Ideal Op-Amp with Negative Feedback):**

              1. **Virtual Short:** $V_+ = V_-$ (inputs at same potential)
              2. **No Input Current:** $I_+ = I_- = 0$ (infinite input impedance)

              These rules only apply with **negative feedback**. Open-loop or positive
              feedback circuits don't obey these rules.

              ![Non-inverting amplifier](https://upload.wikimedia.org/wikipedia/commons/4/44/Op-Amp_Non-Inverting_Amplifier.svg)

              **Non-Inverting Amplifier Analysis:**
              - Virtual short: $V_- = V_{in}$
              - No current into $V_-$: voltage divider gives $V_- = V_{out} \cdot \frac{R_1}{R_1 + R_f}$
              - Therefore: $V_{in} = V_{out} \cdot \frac{R_1}{R_1 + R_f}$

              $$A_v = \frac{V_{out}}{V_{in}} = 1 + \frac{R_f}{R_1}$$

              ![Inverting amplifier](https://upload.wikimedia.org/wikipedia/commons/4/41/Op-Amp_Inverting_Amplifier.svg)

              **Inverting Amplifier Analysis:**
              - Virtual short: $V_- = V_+ = 0$ (virtual ground)
              - Current through $R_{in}$: $I = \frac{V_{in}}{R_{in}}$
              - Same current through $R_f$ (no current into op-amp)
              - $V_{out} = -I \cdot R_f$

              $$A_v = -\frac{R_f}{R_{in}}$$

              ![Unity gain buffer](https://upload.wikimedia.org/wikipedia/commons/a/a8/Op-Amp_Unity-Gain_Buffer.svg)

              **The Buffer (Voltage Follower):**
              $A_v = 1$, but provides high input impedance and low output impedance.
              Essential for impedance matching between stages.

          - name: Gain-bandwidth product
            notes: |
              Real op-amps have finite bandwidth. The gain-bandwidth product (GBW) is
              approximately constant — trading gain for bandwidth.

              **Single-Pole Model:**

              $$A(f) = \frac{A_0}{1 + j\frac{f}{f_p}}$$

              where $A_0$ is DC open-loop gain (often 100,000+) and $f_p$ is the dominant
              pole frequency (often just a few Hz).

              ![Gain-bandwidth product](https://upload.wikimedia.org/wikipedia/commons/1/1e/Gain-bandwidth_product.svg)

              **The GBW Relationship:**

              $$GBW = A_{closed} \times f_{-3dB} = \text{constant}$$

              For a 741 with GBW = 1 MHz:
              - Gain of 1 → Bandwidth = 1 MHz
              - Gain of 10 → Bandwidth = 100 kHz
              - Gain of 100 → Bandwidth = 10 kHz

              **Unity-Gain Frequency ($f_T$):**
              The frequency where open-loop gain drops to 1 (0 dB). This equals GBW
              for single-pole systems.

              **Practical Implications:**
              - High-gain stages have limited bandwidth
              - Cascade multiple low-gain stages for high gain with good bandwidth
              - Modern op-amps: GBW from 1 MHz (general purpose) to 1 GHz+ (high-speed)

              **Slew Rate Limitation:**
              Large signals can't change faster than the slew rate (V/μs):

              $$f_{max} = \frac{SR}{2\pi V_{peak}}$$

              A 741 with SR = 0.5 V/μs can only output a 10V peak sine up to ~8 kHz.

          - name: Feedback
            notes: |
              Feedback is the foundation of op-amp circuits. Negative feedback trades
              gain for improved performance in almost every other metric.

              **Negative Feedback Benefits:**
              - Reduced distortion
              - Increased bandwidth
              - Stabilized gain (depends on passive components, not op-amp)
              - Reduced output impedance
              - Reduced sensitivity to component variations

              ![Feedback block diagram](https://upload.wikimedia.org/wikipedia/commons/b/b5/Ideal_feedback_model.svg)

              **Closed-Loop Gain:**

              $$A_f = \frac{A}{1 + A\beta}$$

              where $A$ is open-loop gain and $\beta$ is the feedback fraction.

              For large loop gain ($A\beta >> 1$):

              $$A_f \approx \frac{1}{\beta}$$

              This is why op-amp gain depends only on resistor ratios!

              **The Four Feedback Topologies:**

              | Topology | Samples | Returns | Effect |
              |----------|---------|---------|--------|
              | Series-Shunt | Voltage | Voltage | Voltage amplifier |
              | Shunt-Series | Current | Current | Current amplifier |
              | Series-Series | Voltage | Current | Transconductance |
              | Shunt-Shunt | Current | Voltage | Transimpedance |

              **Stability Concern:**
              Negative feedback can become positive at high frequencies due to phase
              shift, causing oscillation. The op-amp's internal compensation prevents
              this for most applications.

              **Loop Gain:** $T = A\beta$ determines stability margin and how well
              the virtual short approximation holds.

          - name: Comparators
            notes: |
              Comparators are op-amps used without negative feedback (or with positive
              feedback for hysteresis). They output a digital-like high or low based
              on which input is larger.

              **Basic Comparator:**

              $$V_{out} = \begin{cases} V_{high} & \text{if } V_+ > V_- \\ V_{low} & \text{if } V_+ < V_- \end{cases}$$

              **The Problem with Simple Comparators:**
              Noise near the threshold causes rapid oscillation (chatter) as the input
              crosses back and forth.

              ![Schmitt trigger](https://upload.wikimedia.org/wikipedia/commons/e/e4/Op-Amp_Schmitt_Trigger.svg)

              **Schmitt Trigger (Comparator with Hysteresis):**
              Positive feedback creates two different thresholds — one for rising
              inputs, one for falling.

              ![Hysteresis curve](https://upload.wikimedia.org/wikipedia/commons/7/7a/Hysteresis_sharp_curve.svg)

              **Hysteresis Thresholds:**

              $$V_{TH} = V_{ref}\frac{R_1}{R_1+R_2} + V_{sat}\frac{R_2}{R_1+R_2}$$

              $$V_{TL} = V_{ref}\frac{R_1}{R_1+R_2} - V_{sat}\frac{R_2}{R_1+R_2}$$

              Hysteresis width: $\Delta V = V_{TH} - V_{TL}$

              **Dedicated Comparator ICs vs Op-Amps:**
              - Comparators: Faster (ns), open-collector outputs, no compensation
              - Op-amps: Slower in open-loop, may oscillate, but work in a pinch

              **Applications:**
              - Zero-crossing detectors
              - Window comparators (in-range detection)
              - PWM generation
              - ADC building blocks

        resources:
          - label: Electronics Tutorials - Op-amps
            url: https://www.electronics-tutorials.ws/opamp/opamp_1.html
          - label: All About Circuits - Op-amps
            url: https://www.allaboutcircuits.com/textbook/semiconductors/chpt-8/introduction-operational-amplifiers/
          - label: TI Op-Amp Basics
            url: https://www.ti.com/lit/eb/sloa011b/sloa011b.pdf

      - id: analog-filters
        title: Analog Filters
        description: >-
          Shape the frequency content of signals. Low-pass removes noise, high-pass blocks
          DC, band-pass selects specific frequencies. Active filters with op-amps give
          you gain plus filtering.
        prerequisites:
          - fundamentals/ac-circuits/AC Circuits
          - core/op-amps/Op-amps basics
        outcomes:
          - Design passive RC and RLC filters
          - Build active filters using op-amps
          - Analyze filter frequency response using Bode plots
          - Choose appropriate filter topology for application
        concepts:
          - name: Cutoff frequency
            notes: |
              The cutoff frequency ($f_c$) marks where the filter begins to attenuate.
              Defined as the -3dB point where output power is half the passband value.

              **RC Low-Pass Filter:**

              $$f_c = \frac{1}{2\pi RC}$$

              ![RC low-pass filter](https://upload.wikimedia.org/wikipedia/commons/e/e0/1st_Order_Lowpass_Filter_RC.svg)

              At $f_c$: $|H(j\omega_c)| = \frac{1}{\sqrt{2}} \approx 0.707$ (-3dB)

              **Transfer Function (1st Order Low-Pass):**

              $$H(s) = \frac{1}{1 + sRC} = \frac{1}{1 + s/\omega_c}$$

          - name: Roll-off
            notes: |
              Roll-off describes how quickly a filter attenuates beyond cutoff.
              Measured in dB per decade (10× frequency) or dB per octave (2×).

              **First-Order Filter:** -20 dB/decade = -6 dB/octave

              **nth-Order Filter:** $-20n$ dB/decade

              Higher order = sharper transition but more complexity and potential
              for instability.

              **Why It Matters:**
              A 1st-order filter at 1 kHz only attenuates a 10 kHz signal by 20 dB.
              A 4th-order filter achieves 80 dB — much better noise rejection.

          - name: Butterworth vs Chebyshev
            notes: |
              Filter design involves tradeoffs between passband flatness, transition
              sharpness, and phase response.

              **Butterworth (Maximally Flat):**

              $$|H(j\omega)|^2 = \frac{1}{1+(\omega/\omega_c)^{2n}}$$

              - Flattest possible passband
              - Moderate roll-off
              - Good all-around choice

              **Chebyshev Type I (Equiripple Passband):**
              - Ripple in passband (you choose how much)
              - Sharper roll-off than Butterworth
              - More ringing in step response

              **Chebyshev Type II (Equiripple Stopband):**
              - Flat passband
              - Ripple in stopband
              - Sharp roll-off

              ![Butterworth Bode plot](https://upload.wikimedia.org/wikipedia/commons/6/6b/Butterworth_filter_bode_plot.svg)

              **Selection Guide:**
              - Need flat passband? → Butterworth
              - Need sharp cutoff? → Chebyshev
              - Need linear phase? → Bessel (not covered here)

          - name: Bode plots
            notes: |
              Bode plots show magnitude and phase vs. frequency on logarithmic scales.
              Essential for understanding and designing filters.

              **Magnitude Plot:**

              $$|H|_{dB} = 20\log_{10}|H(j\omega)|$$

              **Phase Plot:**

              $$\angle H(j\omega) = \arctan\left(\frac{\text{Im}(H)}{\text{Re}(H)}\right)$$

              ![Bode plot example](https://upload.wikimedia.org/wikipedia/commons/1/1a/Bode-PT1.svg)

              **Sketching Rules (1st Order):**
              - Below $f_c$: flat at 0 dB
              - Above $f_c$: -20 dB/decade slope
              - At $f_c$: -3 dB, phase = -45°
              - Phase goes from 0° to -90° over ~2 decades centered at $f_c$

              **Combining Stages:**
              - Magnitude: add dB values
              - Phase: add angles
              - Cascaded filters multiply transfer functions

        optional: true
        resources:
          - label: Electronics Tutorials - Filters
            url: https://www.electronics-tutorials.ws/filter/filter_1.html
          - label: All About Circuits - Filters
            url: https://www.allaboutcircuits.com/textbook/alternating-current/chpt-8/what-is-a-filter/

  - id: digital-logic
    title: Digital Logic Design
    items:
      - id: boolean-logic-gates
        title: Boolean Algebra & Logic Gates
        description: >-
          The mathematics of digital systems. AND, OR, NOT gates combine to implement any
          logical function. Boolean algebra lets you simplify and optimize circuits before
          building them.
        prerequisites:
          - fundamentals/algebra-trig/Basic algebra
        outcomes:
          - Simplify Boolean expressions using algebra and K-maps
          - Convert between truth tables and gate circuits
          - Implement functions using NAND/NOR as universal gates
          - Understand gate propagation delay
        concepts:
          - name: Truth tables
            notes: |
              Truth tables exhaustively list all input combinations and their outputs.
              They're the starting point for designing any combinational logic circuit.

              **Basic Gate Truth Tables:**

              | A | B | AND | OR | NAND | NOR | XOR | XNOR |
              |---|---|-----|----|----- |-----|-----|------|
              | 0 | 0 |  0  | 0  |  1   |  1  |  0  |  1   |
              | 0 | 1 |  0  | 1  |  1   |  0  |  1  |  0   |
              | 1 | 0 |  0  | 1  |  1   |  0  |  1  |  0   |
              | 1 | 1 |  1  | 1  |  0   |  0  |  0  |  1   |

              ![Logic gate symbols](https://upload.wikimedia.org/wikipedia/commons/0/0f/LogicGates.svg)

              **Boolean Expressions from Truth Tables:**
              1. Find all rows where output = 1
              2. Write a product (AND) term for each row
              3. Sum (OR) all product terms together

              This gives the Sum of Products (SOP) form.

              **Example:** $F = \bar{A}\bar{B}C + \bar{A}BC + AB\bar{C} + ABC$

              **Minterms and Maxterms:**
              - Minterm: AND of all variables (complemented or not) that produces 1
              - Maxterm: OR of all variables that produces 0
              - $F = \sum m(1,3,5,7)$ means F=1 for minterms 1,3,5,7

              For a deeper dive, see [All About Circuits - Boolean Algebra](https://www.allaboutcircuits.com/textbook/digital/chpt-7/introduction-boolean-algebra/).

          - name: K-maps
            notes: |
              Karnaugh maps provide a visual method for simplifying Boolean expressions.
              Adjacent cells differ by exactly one variable, enabling easy grouping.

              **2-Variable K-map:**
              ```
                    B=0  B=1
              A=0 |  0  |  1  |
              A=1 |  2  |  3  |
              ```

              **3-Variable K-map:**
              ```
                     BC=00  BC=01  BC=11  BC=10
              A=0  |   0  |   1  |   3  |   2  |
              A=1  |   4  |   5  |   7  |   6  |
              ```

              Note the Gray code ordering: 00, 01, 11, 10 (only one bit changes).

              ![K-map with groupings](https://upload.wikimedia.org/wikipedia/commons/2/2c/Karnaugh_map_KV_Venn_Diagramm.svg)

              **Simplification Rules:**
              1. Group adjacent 1s in powers of 2 (1, 2, 4, 8...)
              2. Groups can wrap around edges (the map is a torus!)
              3. Make groups as large as possible
              4. Cover all 1s with minimum number of groups
              5. Each group becomes one product term

              **Reading Groups:**
              - Variables that don't change across the group → include in term
              - Variables that do change → eliminate from term

              A group of $2^k$ cells eliminates $k$ variables.

              ![K-map torus topology](https://upload.wikimedia.org/wikipedia/commons/f/fb/Karnaugh_map_torus.svg)

              **Don't Cares (X):**
              Can be treated as 0 or 1 — choose whichever gives larger groups.
              Common in BCD circuits where codes 10-15 are unused.

          - name: De Morgan's theorem
            notes: |
              De Morgan's theorems let you convert between AND/OR operations and
              push inversions through expressions. Essential for NAND/NOR implementations.

              **The Two Theorems:**

              $$\overline{A + B} = \bar{A} \cdot \bar{B}$$

              $$\overline{A \cdot B} = \bar{A} + \bar{B}$$

              In words:
              - NOT(OR) = AND of NOTs → "break the bar, change the sign"
              - NOT(AND) = OR of NOTs

              ![De Morgan gate equivalents](https://upload.wikimedia.org/wikipedia/commons/e/e1/DeMorgan_Logic_Circuit_diagram_DIN.svg)

              **Bubble Pushing:**
              A visual technique using De Morgan's theorems:
              - Push bubbles through a gate, changing AND↔OR
              - Bubbles on both sides of a gate cancel

              **Generalized Form:**

              $$\overline{A_1 + A_2 + ... + A_n} = \bar{A_1} \cdot \bar{A_2} \cdot ... \cdot \bar{A_n}$$

              $$\overline{A_1 \cdot A_2 \cdot ... \cdot A_n} = \bar{A_1} + \bar{A_2} + ... + \bar{A_n}$$

              **Practical Application:**
              Convert SOP to use only NAND gates:
              1. Start with $F = AB + CD$
              2. Double invert: $F = \overline{\overline{AB + CD}}$
              3. Apply De Morgan: $F = \overline{\overline{AB} \cdot \overline{CD}}$
              4. Result: NAND of NANDs!

          - name: Universal gates
            notes: |
              NAND and NOR gates are "universal" — any Boolean function can be built
              using only NAND gates or only NOR gates. This simplifies manufacturing.

              **Why Universal?**
              If you can make NOT, AND, and OR from a single gate type, you can
              build anything. Both NAND and NOR can do this.

              **Building Blocks from NAND:**

              ![NOT from NAND](https://upload.wikimedia.org/wikipedia/commons/f/f9/NOT_from_NAND.svg)

              - **NOT:** Connect both inputs together: $\bar{A} = \overline{A \cdot A}$
              - **AND:** NAND followed by NOT: $AB = \overline{\overline{AB}}$
              - **OR:** NOT inputs, then NAND: $A+B = \overline{\bar{A} \cdot \bar{B}}$

              ![AND from NAND](https://upload.wikimedia.org/wikipedia/commons/1/16/AND_from_NAND.svg)

              ![OR from NAND](https://upload.wikimedia.org/wikipedia/commons/9/90/OR_from_NAND.svg)

              **Building Blocks from NOR:**

              - **NOT:** $\bar{A} = \overline{A + A}$
              - **OR:** NOR followed by NOT
              - **AND:** NOT inputs, then NOR

              ![AND from NOR](https://upload.wikimedia.org/wikipedia/commons/9/9e/AND_from_NOR.svg)

              **Why NAND Dominates:**
              In CMOS, NAND gates are faster and smaller than NOR gates because
              NMOS transistors (in series for NAND) are faster than PMOS.

              **Gate Count Optimization:**
              Direct NAND/NOR implementation often uses fewer transistors than
              converting from AND/OR/NOT. Modern synthesis tools handle this automatically.

              ![MIT OCW Combinational Logic](/pdfs/mit-combinational-logic.pdf)

        resources:
          - label: Neso Academy Digital Electronics
            url: https://www.nesoacademy.org/ee/05-digital-electronics
          - label: All About Circuits - Boolean
            url: https://www.allaboutcircuits.com/textbook/digital/chpt-7/introduction-boolean-algebra/

      - id: combinational-circuits
        title: Combinational Circuits
        description: >-
          Outputs depend only on current inputs — no memory. Multiplexers route signals,
          decoders select devices, adders do arithmetic. These blocks combine to build
          ALUs and more.
        prerequisites:
          - core/boolean-logic-gates/Boolean Algebra & Logic Gates
        outcomes:
          - Design multiplexers and demultiplexers
          - Build encoders, decoders, and priority encoders
          - Implement binary adders and subtractors
          - Use ROMs and PLAs for function implementation
        concepts:
          - name: Mux/Demux
            notes: |
              Multiplexers (MUX) select one of many inputs to pass to the output.
              Demultiplexers (DEMUX) route one input to one of many outputs.

              **2:1 Multiplexer:**

              $$Y = \bar{S} \cdot I_0 + S \cdot I_1$$

              When S=0, Y=I₀. When S=1, Y=I₁.

              ![2-to-1 MUX](https://upload.wikimedia.org/wikipedia/commons/e/e0/Multiplexer_2-to-1.svg)

              **General MUX:**
              - $n$ select lines → $2^n$ data inputs
              - 4:1 MUX has 2 select lines, 4 data inputs
              - 8:1 MUX has 3 select lines, 8 data inputs

              ![4-to-1 MUX](https://upload.wikimedia.org/wikipedia/commons/7/75/4-to-1_multiplexer.svg)

              **MUX as Universal Logic:**
              Any n-variable function can be implemented with a $2^n$:1 MUX:
              - Connect variables to select lines
              - Connect 0, 1, or variable to data inputs based on truth table

              **Demultiplexer (1:n DEMUX):**
              Routes single input to one of $2^n$ outputs based on select lines.
              Often combined with decoder functionality.

              ![Demultiplexer](https://upload.wikimedia.org/wikipedia/commons/1/15/Demultiplexer_Example01.svg)

              **Applications:**
              - Data routing in buses
              - Time-division multiplexing
              - Memory address decoding
              - Function generators

          - name: Encoders/Decoders
            notes: |
              Encoders compress information (many inputs → few outputs).
              Decoders expand it (few inputs → many outputs).

              **Binary Encoder (2ⁿ:n):**
              Converts one-hot input to binary code.
              - 8:3 encoder: 8 inputs, 3-bit binary output
              - Only one input should be active at a time

              **Priority Encoder:**
              Handles multiple active inputs by encoding the highest-priority one.
              Also outputs a "valid" signal indicating at least one input is active.

              **Binary Decoder (n:2ⁿ):**
              Activates exactly one of $2^n$ outputs based on n-bit input.

              | A₁ | A₀ | Y₃ | Y₂ | Y₁ | Y₀ |
              |----|----|----|----|----|-----|
              | 0  | 0  | 0  | 0  | 0  | 1   |
              | 0  | 1  | 0  | 0  | 1  | 0   |
              | 1  | 0  | 0  | 1  | 0  | 0   |
              | 1  | 1  | 1  | 0  | 0  | 0   |

              ![Decoder circuit](https://upload.wikimedia.org/wikipedia/commons/c/c6/Decoder_Example.svg)

              **7-Segment Decoder:**
              Converts 4-bit BCD to 7 outputs for display segments.

              ![7-segment display](https://upload.wikimedia.org/wikipedia/commons/0/02/7_segment_display_labeled.svg)

              **Applications:**
              - Memory chip select (address decoding)
              - Instruction decoding in CPUs
              - Keyboard encoding
              - Display drivers

          - name: Adders
            notes: |
              Binary adders are the foundation of arithmetic logic units.
              Built from simple gates, they perform the addition we take for granted.

              **Half Adder:**
              Adds two 1-bit numbers, produces Sum and Carry.

              $$Sum = A \oplus B$$
              $$Carry = A \cdot B$$

              ![Half adder circuit](https://upload.wikimedia.org/wikipedia/commons/d/d9/Half-adder.svg)

              **Full Adder:**
              Adds three 1-bit numbers (A, B, and Carry-in).

              $$Sum = A \oplus B \oplus C_{in}$$
              $$C_{out} = AB + C_{in}(A \oplus B)$$

              ![Full adder logic diagram](https://upload.wikimedia.org/wikipedia/commons/6/69/Full-adder_logic_diagram.svg)

              **Ripple Carry Adder:**
              Chain full adders together — carry ripples from LSB to MSB.

              ![Ripple carry adder](https://upload.wikimedia.org/wikipedia/commons/5/5d/Full_Adder_Modules.svg)

              **The Propagation Delay Problem:**
              For n-bit addition, worst case is n × (full adder delay).
              A 32-bit ripple adder is slow!

              ![Full adder propagation delay](https://upload.wikimedia.org/wikipedia/commons/d/d5/Full-Adder_Propagation_Delay.svg)

              **Faster Adders:**
              - **Carry Lookahead (CLA):** Compute carries in parallel using
                Generate ($G = AB$) and Propagate ($P = A \oplus B$) signals
              - **Carry Select:** Compute both possibilities, select when carry arrives
              - **Carry Skip:** Skip over blocks that propagate

              **Subtraction:**
              Use 2's complement: $A - B = A + \bar{B} + 1$
              Invert B, set carry-in to 1.

          - name: Comparators
            notes: |
              Magnitude comparators determine the relationship between two binary
              numbers: A > B, A = B, or A < B.

              **1-Bit Comparator:**

              $$A > B: A\bar{B}$$
              $$A = B: \overline{A \oplus B} = A \odot B$$
              $$A < B: \bar{A}B$$

              **n-Bit Comparator:**
              Compare bit-by-bit from MSB to LSB. First unequal bit determines result.

              ![Magnitude comparator](https://upload.wikimedia.org/wikipedia/commons/c/c8/Parallel_Magnitude_Comparator.svg)

              **Cascading Comparators:**
              For wider comparisons, chain comparator ICs (like 74HC85).
              Each stage has A>B, A=B, A<B inputs from the previous stage.

              ![4-bit comparator extension](https://upload.wikimedia.org/wikipedia/commons/7/79/4_bit_magnitude_comparator_extension.svg)

              **Equality Comparator (Simpler):**
              Just check if A XOR B = 0 for each bit position, then AND all results.

              $$A = B: \prod_{i=0}^{n-1}(A_i \odot B_i)$$

              **Applications:**
              - Address matching in networking
              - Branch conditions in CPUs
              - Window comparators (range checking)
              - Sorting networks

        resources:
          - label: Neso Academy - Combinational
            url: https://www.nesoacademy.org/ee/05-digital-electronics
          - label: GeeksforGeeks Digital Logic
            url: https://www.geeksforgeeks.org/digital-electronics-logic-design-tutorials/

      - id: sequential-circuits
        title: Sequential Circuits
        description: >-
          Circuits with memory — outputs depend on current inputs AND past history.
          Flip-flops store bits, registers hold bytes, counters sequence through states.
          The basis of all digital systems.
        prerequisites:
          - core/combinational-circuits/Combinational Circuits
        outcomes:
          - Design circuits using SR, D, JK, and T flip-flops
          - Build counters (synchronous and asynchronous)
          - Design finite state machines
          - Analyze timing diagrams and setup/hold violations
        concepts:
          - name: Flip-flops
            notes: |
              Flip-flops are bistable circuits that store one bit. They're the
              fundamental building blocks of all sequential logic.

              **SR (Set-Reset) Flip-Flop:**
              The simplest memory element, but has a forbidden state.

              | S | R | Q⁺ | Action |
              |---|---|----|--------|
              | 0 | 0 | Q  | Hold |
              | 0 | 1 | 0  | Reset |
              | 1 | 0 | 1  | Set |
              | 1 | 1 | ?  | **Forbidden** |

              ![SR flip-flop using NOR gates](https://upload.wikimedia.org/wikipedia/commons/c/c6/RS_Flip-flop_%28NOR%29.svg)

              **D (Data) Flip-Flop:**
              The most commonly used type. Output follows input on clock edge.

              $$Q^+ = D$$

              ![D flip-flop symbol](https://upload.wikimedia.org/wikipedia/commons/8/8c/D-Type_Flip-flop.svg)

              **JK Flip-Flop:**
              Like SR but with no forbidden state. J=K=1 toggles the output.

              $$Q^+ = J\bar{Q} + \bar{K}Q$$

              | J | K | Q⁺ | Action |
              |---|---|----|--------|
              | 0 | 0 | Q  | Hold |
              | 0 | 1 | 0  | Reset |
              | 1 | 0 | 1  | Set |
              | 1 | 1 | Q̄  | Toggle |

              ![JK flip-flop](https://upload.wikimedia.org/wikipedia/commons/1/1c/JK_Flip-flop.svg)

              **T (Toggle) Flip-Flop:**
              Toggles on each clock when T=1. Perfect for counters.

              $$Q^+ = T \oplus Q$$

              ![T flip-flop](https://upload.wikimedia.org/wikipedia/commons/e/e2/T-Type_Flip-flop.svg)

              **Edge Triggering:**
              Modern flip-flops are edge-triggered (positive or negative edge),
              not level-triggered. This prevents transparency issues.

              **Timing Parameters:**
              - **Setup time ($t_{su}$):** Data must be stable before clock edge
              - **Hold time ($t_h$):** Data must remain stable after clock edge
              - **Propagation delay ($t_{pd}$):** Clock edge to output change

          - name: Registers
            notes: |
              Registers are groups of flip-flops that store multi-bit values.
              They can load, hold, or shift data.

              **Parallel Load Register:**
              All bits loaded simultaneously on clock edge when LOAD=1.

              **Shift Register:**
              Data shifts one position per clock cycle.

              ![Shift register](https://upload.wikimedia.org/wikipedia/commons/6/60/3_bit_universal_shift_register.svg)

              **Shift Register Types:**
              - **SISO:** Serial In, Serial Out — delay line
              - **SIPO:** Serial In, Parallel Out — serial to parallel converter
              - **PISO:** Parallel In, Serial Out — parallel to serial converter
              - **PIPO:** Parallel In, Parallel Out — standard register

              ![Bidirectional shift register](https://upload.wikimedia.org/wikipedia/commons/6/69/3_bit_bi-directional_shift_register_circuit.svg)

              **Universal Shift Register:**
              Can shift left, shift right, parallel load, or hold.
              Mode select inputs choose the operation.

              **Applications:**
              - Serial communication (UART)
              - LED displays (driving many LEDs with few pins)
              - Pseudo-random number generators (LFSR)
              - Digital delay lines

              **Ring Counter:**
              Shift register with output fed back to input.
              Circulates a single 1 (or 0) through the stages.

          - name: Counters
            notes: |
              Counters sequence through a series of states, typically counting
              up or down in binary.

              **Asynchronous (Ripple) Counter:**
              Each flip-flop is clocked by the previous stage's output.
              Simple but slow — delays accumulate.

              **Synchronous Counter:**
              All flip-flops share the same clock. Faster, more reliable.

              ![Synchronous up counter](https://upload.wikimedia.org/wikipedia/commons/8/86/3_bit_up_synchronous_counter.svg)

              **Binary Up Counter Design:**
              - LSB (Q₀) toggles every clock
              - Q₁ toggles when Q₀=1
              - Q₂ toggles when Q₁Q₀=11
              - Pattern: Qₙ toggles when all lower bits are 1

              **Modulo-N Counter:**
              Counts from 0 to N-1, then wraps. A mod-10 counter counts 0-9.
              Use additional logic to detect N and reset.

              ![Synchronous down counter](https://upload.wikimedia.org/wikipedia/commons/9/91/3_bit_down_synchronous_counter.svg)

              **Up/Down Counter:**
              Direction control input selects counting direction.
              Changes the feedback logic.

              **Counter ICs:**
              - 74HC161: 4-bit synchronous binary
              - 74HC190: Decade up/down
              - 74HC4520: Dual 4-bit binary

              **Applications:**
              - Frequency division
              - Event counting
              - Timer/PWM generation
              - Address generation for memory

          - name: State machines
            notes: |
              Finite State Machines (FSMs) are the general model for sequential
              circuits. They consist of states, transitions, and outputs.

              **Moore Machine:**
              Outputs depend only on current state.
              More stable outputs (change only on clock edges).

              ![Moore machine example](https://upload.wikimedia.org/wikipedia/commons/a/ab/FSM_mooreModel_doorCtrl.png)

              **Mealy Machine:**
              Outputs depend on current state AND inputs.
              Faster response but outputs can glitch.

              ![Mealy machine example](https://upload.wikimedia.org/wikipedia/commons/f/f3/FSM_Mealy_model_doorCtrl.png)

              **FSM Design Process:**
              1. Define states and state diagram
              2. Create state transition table
              3. Choose state encoding (binary, one-hot, Gray)
              4. Derive next-state logic (K-maps or equations)
              5. Derive output logic
              6. Implement with flip-flops and gates

              ![FSM block diagram](https://upload.wikimedia.org/wikipedia/commons/8/80/Finite_State_Machine_Logic.svg)

              **State Encoding:**
              - **Binary:** Minimum flip-flops, complex logic
              - **One-Hot:** One flip-flop per state, simple logic, more FFs
              - **Gray Code:** Only one bit changes per transition, reduces glitches

              **Example: Traffic Light Controller**
              States: Green→Yellow→Red→Green...
              Inputs: Timer, sensor
              Outputs: Light signals

              **Avoiding Common Pitfalls:**
              - Initialize to a known state (reset)
              - Handle unused states (don't let FSM get stuck)
              - Watch for asynchronous input synchronization

        resources:
          - label: Neso Academy - Sequential
            url: https://www.nesoacademy.org/ee/05-digital-electronics
          - label: Ben Eater - 8-bit Computer
            url: https://eater.net/

  - id: signals-systems
    title: Signals & Systems
    items:
      - id: signal-basics
        title: Signal Fundamentals
        description: >-
          The language of information. Continuous vs discrete, periodic vs aperiodic,
          energy vs power signals. Understanding signal properties is essential before
          analyzing how systems process them.
        prerequisites:
          - fundamentals/calculus/Calculus
          - Complex numbers
        outcomes:
          - Classify signals by their properties
          - Perform basic signal operations (scaling, shifting)
          - Understand even/odd decomposition
          - Work with unit impulse and step functions
        concepts:
          - name: Continuous vs discrete
            notes: |
              Signals come in two fundamental flavors based on their independent
              variable (usually time).

              **Continuous-Time (CT) Signals:**
              Defined for all real values of $t$: $x(t), \quad t \in \mathbb{R}$

              Examples: voltage from a microphone, temperature sensor output

              **Discrete-Time (DT) Signals:**
              Defined only at integer indices: $x[n], \quad n \in \mathbb{Z}$

              Examples: sampled audio, digital sensor readings

              ![Discrete signal representation](https://upload.wikimedia.org/wikipedia/commons/6/67/Digital.signal.discret.svg)

              **Sampling Relationship:**

              $$x[n] = x(nT_s)$$

              where $T_s$ is the sampling period and $f_s = 1/T_s$ is the sampling frequency.

              ![Sampling process](https://upload.wikimedia.org/wikipedia/commons/c/c3/Signal_Sampling.png)

              **Nyquist Theorem:**
              To perfectly reconstruct a signal, sample at least twice the highest frequency:

              $$f_s > 2f_{max}$$

              Violating this causes aliasing — high frequencies masquerade as low frequencies.

              **Analog vs Digital:**
              - Analog: continuous time AND continuous amplitude
              - Digital: discrete time AND quantized amplitude
              - Sampled: discrete time, continuous amplitude (theoretical)

              **Why Discrete Matters:**
              All modern signal processing is digital. Understanding both domains
              and how they relate is essential.

          - name: Periodic signals
            notes: |
              A signal is periodic if it repeats exactly after some period $T$ (CT)
              or $N$ (DT).

              **Continuous-Time Periodic:**

              $$x(t) = x(t + T) \text{ for all } t$$

              The fundamental frequency is $f_0 = 1/T$ or $\omega_0 = 2\pi/T$.

              **Discrete-Time Periodic:**

              $$x[n] = x[n + N] \text{ for all } n$$

              $N$ must be a positive integer.

              ![Common waveforms](https://upload.wikimedia.org/wikipedia/commons/7/77/Waveforms.svg)

              **Common Periodic Signals:**

              **Sinusoid:**
              $$x(t) = A\sin(2\pi f_0 t + \phi) = A\sin(\omega_0 t + \phi)$$

              **Square Wave (Fourier Series):**
              $$x(t) = \frac{4}{\pi}\sum_{n=1,3,5...}^{\infty}\frac{1}{n}\sin(n\omega_0 t)$$

              **Triangle Wave:**
              $$x(t) = \frac{8}{\pi^2}\sum_{n=1,3,5...}^{\infty}\frac{(-1)^{(n-1)/2}}{n^2}\sin(n\omega_0 t)$$

              **Sawtooth Wave:**
              $$x(t) = \frac{2}{\pi}\sum_{n=1}^{\infty}\frac{(-1)^{n+1}}{n}\sin(n\omega_0 t)$$

              **DT Periodicity Subtlety:**
              Not all sinusoids are periodic in discrete time!
              $x[n] = \cos(\omega_0 n)$ is periodic only if $\omega_0/(2\pi)$ is rational.

              **Energy vs Power Signals:**
              - Energy signal: finite total energy, zero average power (transients)
              - Power signal: infinite energy, finite average power (periodic signals)

          - name: Impulse function
            notes: |
              The impulse (Dirac delta) is a mathematical idealization — infinite
              height, zero width, unit area. It's the foundation of linear systems theory.

              **Continuous-Time Impulse $\delta(t)$:**

              $$\delta(t) = 0 \text{ for } t \neq 0$$

              $$\int_{-\infty}^{\infty} \delta(t) \, dt = 1$$

              ![Dirac delta function](https://upload.wikimedia.org/wikipedia/commons/4/48/Dirac_distribution_PDF.svg)

              **Sifting Property (Most Important!):**

              $$\int_{-\infty}^{\infty} f(t)\delta(t-t_0) \, dt = f(t_0)$$

              The impulse "picks out" the function value at $t_0$.

              **Discrete-Time Impulse $\delta[n]$:**

              $$\delta[n] = \begin{cases} 1, & n=0 \\ 0, & n \neq 0 \end{cases}$$

              Much simpler than the CT version — just a sample of height 1 at n=0.

              **Unit Step Function:**

              $$u(t) = \begin{cases} 1, & t \geq 0 \\ 0, & t < 0 \end{cases}$$

              $$u[n] = \begin{cases} 1, & n \geq 0 \\ 0, & n < 0 \end{cases}$$

              **Relationship:**

              $$\frac{d}{dt}u(t) = \delta(t)$$

              $$u(t) = \int_{-\infty}^{t} \delta(\tau) \, d\tau$$

              For discrete: $\delta[n] = u[n] - u[n-1]$

              **Why Impulses Matter:**
              The impulse response $h(t)$ completely characterizes an LTI system.
              Any input can be decomposed into weighted, shifted impulses.

          - name: Convolution
            notes: |
              Convolution is THE fundamental operation for linear time-invariant
              (LTI) systems. If you know the impulse response, you can find the
              output for any input.

              **Continuous-Time Convolution:**

              $$y(t) = x(t) * h(t) = \int_{-\infty}^{\infty} x(\tau)h(t-\tau) \, d\tau$$

              **Discrete-Time Convolution:**

              $$y[n] = x[n] * h[n] = \sum_{k=-\infty}^{\infty} x[k]h[n-k]$$

              ![Convolution animation](https://upload.wikimedia.org/wikipedia/commons/6/6a/Convolution_of_box_signal_with_itself2.gif)

              **Graphical Convolution Steps:**
              1. Flip $h(\tau)$ to get $h(-\tau)$
              2. Shift by $t$ to get $h(t-\tau)$
              3. Multiply $x(\tau) \cdot h(t-\tau)$
              4. Integrate (sum) the product
              5. Repeat for all values of $t$

              ![Convolution diagram](https://upload.wikimedia.org/wikipedia/commons/9/97/Convolution3.svg)

              **Key Properties:**

              | Property | Expression |
              |----------|------------|
              | Commutative | $x * h = h * x$ |
              | Associative | $(x * h_1) * h_2 = x * (h_1 * h_2)$ |
              | Distributive | $x * (h_1 + h_2) = x*h_1 + x*h_2$ |
              | Identity | $x * \delta = x$ |

              **The Frequency Domain Shortcut:**

              $$\mathcal{F}\{x * h\} = X(\omega) \cdot H(\omega)$$

              Convolution in time = multiplication in frequency!
              This is why we use Fourier transforms.

              **Practical Interpretation:**
              - Convolution with impulse response = filtering
              - Convolution with rectangular pulse = moving average
              - Convolution with Gaussian = smoothing/blurring

              For detailed examples, see the [DSPGuide Convolution Chapter](https://www.dspguide.com/CH6.PDF).

        resources:
          - label: MIT OCW 6.003
            url: https://ocw.mit.edu/courses/6-003-signals-and-systems-fall-2011/
          - label: Neso Academy - Signals
            url: https://www.nesoacademy.org/ee/04-signals-and-systems

      - id: fourier-analysis
        title: Fourier Analysis
        description: >-
          Any signal can be decomposed into sinusoids. Fourier series for periodic signals,
          Fourier transform for aperiodic. This frequency-domain view reveals what filters
          do and how signals occupy bandwidth.
        prerequisites:
          - core/signal-basics/Signal Fundamentals
          - fundamentals/calculus/Calculus
        outcomes:
          - Compute Fourier series coefficients
          - Apply Fourier transform to common signals
          - Interpret frequency spectra
          - Understand Parseval's theorem (energy in time = energy in frequency)
        concepts:
          - name: Fourier series
            notes: |
              Any periodic signal can be represented as a sum of harmonically
              related sinusoids. This is the Fourier series.

              **Trigonometric Form:**

              $$x(t) = a_0 + \sum_{n=1}^{\infty}[a_n\cos(n\omega_0 t) + b_n\sin(n\omega_0 t)]$$

              **Coefficients:**

              $$a_0 = \frac{1}{T}\int_0^T x(t) \, dt \quad \text{(DC component)}$$

              $$a_n = \frac{2}{T}\int_0^T x(t)\cos(n\omega_0 t) \, dt$$

              $$b_n = \frac{2}{T}\int_0^T x(t)\sin(n\omega_0 t) \, dt$$

              **Complex Exponential Form (More Elegant):**

              $$x(t) = \sum_{n=-\infty}^{\infty} c_n e^{jn\omega_0 t}$$

              $$c_n = \frac{1}{T}\int_0^T x(t)e^{-jn\omega_0 t} \, dt$$

              ![Square wave Fourier series](https://upload.wikimedia.org/wikipedia/commons/1/1a/Fourier_series_square_wave_circles_animation.svg)

              **Example: Square Wave**

              $$x(t) = \frac{4}{\pi}\left(\sin(\omega_0 t) + \frac{1}{3}\sin(3\omega_0 t) + \frac{1}{5}\sin(5\omega_0 t) + ...\right)$$

              Only odd harmonics! Even functions have only cosine terms,
              odd functions have only sine terms.

              ![Fourier series visualization](https://upload.wikimedia.org/wikipedia/commons/b/bc/Fourier_Series.svg)

              **Gibbs Phenomenon:**
              At discontinuities, the Fourier series overshoots by ~9%, no matter
              how many terms you include. This is fundamental, not a bug.

              **Convergence:**
              - Dirichlet conditions guarantee convergence for most practical signals
              - At discontinuities, converges to midpoint of jump

          - name: Fourier transform
            notes: |
              The Fourier transform extends Fourier series to non-periodic signals,
              giving a continuous spectrum instead of discrete harmonics.

              **Forward Transform:**

              $$X(j\omega) = \int_{-\infty}^{\infty} x(t)e^{-j\omega t} \, dt$$

              **Inverse Transform:**

              $$x(t) = \frac{1}{2\pi}\int_{-\infty}^{\infty} X(j\omega)e^{j\omega t} \, d\omega$$

              ![Time and frequency domain relationship](https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains.gif)

              **Common Transform Pairs:**

              | Time Domain | Frequency Domain |
              |-------------|------------------|
              | $\delta(t)$ | $1$ |
              | $1$ | $2\pi\delta(\omega)$ |
              | $e^{-at}u(t)$ | $\frac{1}{a+j\omega}$ |
              | $e^{-a\|t\|}$ | $\frac{2a}{a^2+\omega^2}$ |
              | $\text{rect}(t/T)$ | $T\text{sinc}(\omega T/2)$ |
              | $\cos(\omega_0 t)$ | $\pi[\delta(\omega-\omega_0)+\delta(\omega+\omega_0)]$ |

              **Key Properties:**

              | Property | Time Domain | Frequency Domain |
              |----------|-------------|------------------|
              | Linearity | $ax(t)+by(t)$ | $aX(\omega)+bY(\omega)$ |
              | Time Shift | $x(t-t_0)$ | $e^{-j\omega t_0}X(\omega)$ |
              | Freq Shift | $e^{j\omega_0 t}x(t)$ | $X(\omega-\omega_0)$ |
              | Convolution | $x(t)*h(t)$ | $X(\omega)H(\omega)$ |
              | Multiplication | $x(t)y(t)$ | $\frac{1}{2\pi}X(\omega)*Y(\omega)$ |
              | Differentiation | $\frac{dx}{dt}$ | $j\omega X(\omega)$ |

              ![Transform relationships](https://upload.wikimedia.org/wikipedia/commons/a/a6/Fourier_transform%2C_Fourier_series%2C_DTFT%2C_DFT.svg)

              **Duality:**
              Time and frequency are interchangeable — properties in one domain
              have mirror properties in the other.

          - name: Spectrum
            notes: |
              The spectrum shows how a signal's energy or power is distributed
              across frequencies. It's how we "see" signals in the frequency domain.

              **Magnitude Spectrum:**

              $$|X(j\omega)| = \sqrt{\text{Re}(X)^2 + \text{Im}(X)^2}$$

              **Phase Spectrum:**

              $$\angle X(j\omega) = \arctan\left(\frac{\text{Im}(X)}{\text{Re}(X)}\right)$$

              ![Sine wave spectrum](https://upload.wikimedia.org/wikipedia/commons/4/4a/Spectrum_sinewave.svg)

              **Single Frequency (Sinusoid):**
              A pure tone appears as two impulses at $\pm f_0$.

              **Square Wave Spectrum:**
              Impulses at odd harmonics with decreasing amplitude ($1/n$).

              ![Square wave spectrum](https://upload.wikimedia.org/wikipedia/commons/8/81/Spectrum_square.svg)

              **Power Spectral Density (PSD):**
              For power signals, the PSD shows power per unit frequency:

              $$S_{xx}(\omega) = \lim_{T\to\infty} \frac{|X_T(\omega)|^2}{T}$$

              **Energy Spectral Density:**
              For energy signals: $|X(\omega)|^2$

              **One-Sided vs Two-Sided:**
              - Two-sided: shows negative frequencies (mathematically complete)
              - One-sided: doubles positive side, ignores negative (practical measurements)

              Real signals have conjugate-symmetric spectra: $X(-\omega) = X^*(\omega)$

          - name: Bandwidth
            notes: |
              Bandwidth measures how much frequency "space" a signal occupies.
              Different definitions exist for different applications.

              **3dB Bandwidth:**
              Range where $|X(\omega)| \geq |X(\omega_{max})|/\sqrt{2}$

              ![Bandwidth definition](https://upload.wikimedia.org/wikipedia/commons/0/01/Bandwidth_2.svg)

              **Null-to-Null Bandwidth:**
              Distance between first zeros of the spectrum.

              **Equivalent Noise Bandwidth:**
              Width of rectangular filter with same area under the curve.

              **Time-Bandwidth Product:**
              A fundamental tradeoff — you can't have both short duration AND
              narrow bandwidth.

              $$\Delta t \cdot \Delta f \geq \frac{1}{4\pi}$$

              Equality holds only for Gaussian pulses.

              **Practical Implications:**
              - Shorter pulses need more bandwidth
              - Sharper filter cutoffs need longer impulse responses
              - Communication rate limited by available bandwidth (Shannon)

              **Parseval's Theorem:**
              Total energy is the same in time and frequency domains:

              $$\int_{-\infty}^{\infty} |x(t)|^2 dt = \frac{1}{2\pi}\int_{-\infty}^{\infty} |X(j\omega)|^2 d\omega$$

              This lets you calculate energy from the spectrum.

        resources:
          - label: 3Blue1Brown - Fourier
            url: https://www.youtube.com/watch?v=spUNpyF58BY
          - label: MIT OCW 6.003
            url: https://ocw.mit.edu/courses/6-003-signals-and-systems-fall-2011/

      - id: laplace-z-transform
        title: Laplace & Z-Transform
        description: >-
          Generalized frequency domain tools. Laplace transform handles continuous systems
          with initial conditions, Z-transform does the same for discrete systems. Both
          turn differential/difference equations into algebra.
        prerequisites:
          - core/fourier-analysis/Fourier Analysis
          - Differential equations
        outcomes:
          - Apply Laplace transform to solve circuit problems
          - Find transfer functions from differential equations
          - Use Z-transform for discrete-time system analysis
          - Analyze system stability using pole locations
        concepts:
          - name: Transfer function
            notes: |
              The transfer function $H(s)$ or $H(z)$ is the Laplace/Z-transform
              of the impulse response. It completely characterizes an LTI system.

              **Laplace Transform:**

              $$X(s) = \int_{0}^{\infty} x(t)e^{-st} \, dt$$

              where $s = \sigma + j\omega$ is a complex frequency.

              **Transfer Function Definition:**

              $$H(s) = \frac{Y(s)}{X(s)}$$

              **From Differential Equations:**
              For $\frac{d^2y}{dt^2} + 3\frac{dy}{dt} + 2y = x(t)$:

              $$s^2Y(s) + 3sY(s) + 2Y(s) = X(s)$$

              $$H(s) = \frac{Y(s)}{X(s)} = \frac{1}{s^2 + 3s + 2}$$

              **Standard Form:**

              $$H(s) = K\frac{(s-z_1)(s-z_2)...(s-z_m)}{(s-p_1)(s-p_2)...(s-p_n)}$$

              ![Feedback system](https://upload.wikimedia.org/wikipedia/commons/e/ed/Feedback_loop_with_descriptions.svg)

          - name: Poles and zeros
            notes: |
              Poles and zeros determine everything about a system's behavior —
              stability, frequency response, and transient response.

              **Zeros:** Values of $s$ where $H(s) = 0$ (numerator = 0)
              **Poles:** Values of $s$ where $H(s) \to \infty$ (denominator = 0)

              **Pole-Zero Plot:**
              Plot poles (×) and zeros (○) in the complex s-plane.

              ![Pole-zero plot](https://upload.wikimedia.org/wikipedia/commons/a/a8/Smoothing_Filter_Pole_Zero_Plot.svg)

              **Pole Locations and Time Response:**

              | Pole Location | Time Response |
              |---------------|---------------|
              | Real, negative | Decaying exponential |
              | Real, positive | Growing exponential (unstable!) |
              | Complex conjugate pair, LHP | Decaying oscillation |
              | Complex conjugate pair, RHP | Growing oscillation (unstable!) |
              | On imaginary axis | Sustained oscillation |

              **Effect on Frequency Response:**
              - Poles create peaks in $|H(j\omega)|$
              - Zeros create notches/dips
              - Distance from jω-axis determines sharpness

          - name: ROC
            notes: |
              The Region of Convergence (ROC) specifies where the transform
              integral/sum converges. It's essential for uniqueness and stability.

              **Laplace ROC:**
              The transform converges for $\text{Re}(s) > \sigma_0$ where
              $\sigma_0$ depends on the signal.

              **ROC Rules (Laplace):**
              - Right-sided signals: ROC is right of rightmost pole
              - Left-sided signals: ROC is left of leftmost pole
              - Two-sided signals: ROC is a strip (if it exists)
              - Causal + stable: ROC includes jω-axis and extends right

              **Z-Transform ROC:**
              For discrete systems, ROC is an annular region in the z-plane.

              - Causal signals: ROC is outside the outermost pole
              - Stable systems: ROC includes the unit circle

          - name: Stability
            notes: |
              A system is BIBO (bounded-input, bounded-output) stable if every
              bounded input produces a bounded output.

              **Continuous-Time Stability:**
              All poles must be in the left half-plane (LHP):

              $$\text{Re}(p_i) < 0 \text{ for all poles } p_i$$

              **Discrete-Time Stability:**
              All poles must be inside the unit circle:

              $$|p_i| < 1 \text{ for all poles } p_i$$

              **Stability Tests:**
              - **Routh-Hurwitz:** Algebraic test for CT systems
              - **Jury Test:** Algebraic test for DT systems
              - **Nyquist Criterion:** Graphical, handles feedback

              **Marginal Stability:**
              Poles on the boundary (jω-axis or unit circle) give sustained
              oscillations — theoretically stable but practically risky.

              **Common Stable Systems:**
              - Low-pass filters (poles in LHP)
              - Most physical systems without positive feedback

              For more depth, see the [DSPGuide Laplace Chapter](https://www.dspguide.com/CH32.PDF).

        optional: true
        resources:
          - label: MIT OCW 6.003
            url: https://ocw.mit.edu/courses/6-003-signals-and-systems-fall-2011/
          - label: Brian Douglas - Control
            url: https://www.youtube.com/@BrianDouglas

  - id: microcontrollers
    title: Microcontrollers
    items:
      - id: mcu-basics
        title: Microcontroller Fundamentals
        description: >-
          A computer on a chip — CPU, memory, and peripherals in one package. Arduino made
          embedded systems accessible, but understanding what happens under the hood makes
          you a better developer.
        prerequisites:
          - core/boolean-logic-gates/Digital Logic basics
          - Basic programming
        outcomes:
          - Understand microcontroller architecture (CPU, memory, peripherals)
          - Program GPIO pins for digital I/O
          - Use Arduino IDE effectively
          - Read microcontroller datasheets
        concepts:
          - name: Architecture
            notes: |
              ## Microcontroller Architecture

              A microcontroller (MCU) integrates a processor core, memory, and peripherals
              on a single chip — a complete computer system in miniature.

              ### Von Neumann vs Harvard Architecture

              ![Von Neumann Architecture](https://upload.wikimedia.org/wikipedia/commons/e/e5/Von_Neumann_Architecture.svg)

              **Von Neumann** uses a single bus for both instructions and data:
              - Simpler design, fewer connections
              - Potential bottleneck (can't fetch instruction while accessing data)
              - Used in: x86 processors, some ARM cores

              ![Harvard Architecture](https://upload.wikimedia.org/wikipedia/commons/3/3f/Harvard_architecture.svg)

              **Harvard** separates instruction and data buses:
              - Simultaneous instruction fetch and data access
              - Higher performance for embedded applications
              - Used in: AVR (Arduino), PIC, most ARM Cortex-M

              ### Core Components

              ![8051 Block Diagram](https://upload.wikimedia.org/wikipedia/commons/7/79/Microcontroller_8051.gif)

              | Component | Function |
              |-----------|----------|
              | CPU | Executes instructions (ALU, registers, control unit) |
              | Flash | Program memory (non-volatile, stores your code) |
              | SRAM | Data memory (volatile, variables, stack) |
              | Peripherals | I/O ports, timers, ADC, communication interfaces |
              | Clock | System timing (internal RC or external crystal) |

              ### Word Size

              - **8-bit**: AVR, PIC, 8051 — simple, low power, cheap
              - **16-bit**: MSP430 — ultra-low power applications
              - **32-bit**: ARM Cortex-M — performance, complex applications

              The word size affects register width, address space, and arithmetic efficiency.
              8-bit MCUs handle 32-bit math through multiple operations.

              ### Pipeline and Execution

              Most MCUs use pipelining for efficiency:

              $$\text{Throughput} = \frac{\text{Instructions}}{\text{Clock cycles}}$$

              AVR achieves ~1 MIPS/MHz through single-cycle execution of most instructions.

          - name: GPIO
            notes: |
              ## General Purpose Input/Output (GPIO)

              GPIO pins are the fundamental interface between your MCU and the outside world.
              Each pin can be configured as input (reading sensors, buttons) or output
              (driving LEDs, motors).

              ### Port Registers (AVR Example)

              ![Port Register Structure](https://upload.wikimedia.org/wikipedia/commons/d/d6/MFrey_Port_1_MCS-51.svg)

              Each I/O port typically has three registers:

              | Register | Function |
              |----------|----------|
              | DDRx | Data Direction (0 = input, 1 = output) |
              | PORTx | Output data / Pull-up enable |
              | PINx | Read input state |

              ### Basic Configuration
              ```c
              // Set pin as output
              DDRB |= (1 << PB5);    // Pin 13 on Arduino Uno

              // Set output high
              PORTB |= (1 << PB5);   // LED on

              // Set output low
              PORTB &= ~(1 << PB5);  // LED off

              // Toggle output
              PORTB ^= (1 << PB5);

              // Set pin as input with pull-up
              DDRD &= ~(1 << PD2);   // Input
              PORTD |= (1 << PD2);   // Enable pull-up

              // Read input
              if (PIND & (1 << PD2)) {
                  // Pin is HIGH
              }
              ```

              ### Input Modes

              - **Floating (Hi-Z)**: Undefined voltage, susceptible to noise
              - **Pull-up**: Internal resistor to VCC (~20-50kΩ)
              - **Pull-down**: External resistor to GND (not always available internally)

              ### Output Modes

              - **Push-pull**: Can source and sink current
              - **Open-drain**: Can only sink current (needs external pull-up)

              ### Current Limits

              $$I_{max} \approx 20-40\text{ mA per pin}$$
              $$I_{total} \approx 100-200\text{ mA per port}$$

              Exceeding limits damages the MCU. Use transistors or drivers for high-current loads.

          - name: Clock
            notes: |
              ## Clock System

              The clock is the heartbeat of your MCU — every operation is synchronized to it.
              Understanding clock configuration is essential for timing-critical applications.

              ### Clock Sources

              | Source | Accuracy | Startup | Power |
              |--------|----------|---------|-------|
              | Internal RC | ±1-10% | Fast (~µs) | Lowest |
              | External Crystal | ±20-50 ppm | Slow (~ms) | Medium |
              | External Oscillator | Best | Fast | Highest |
              | PLL (multiplied) | Varies | Medium | High |

              ### Clock Tree

              The system clock feeds various subsystems through dividers:
              ![Clock Tree Example](https://upload.wikimedia.org/wikipedia/commons/2/2e/Clock_tree_MCU.svg)

              ```plaintext
              Main Clock → CPU Clock
                        → Peripheral Clock (may be divided)
                        → Timer Clock
                        → ADC Clock
              ```

              ### Prescalers

              Prescalers divide the clock for slower peripherals:

              $$f_{peripheral} = \frac{f_{system}}{2^n}$$

              Common prescaler values: 1, 2, 4, 8, 16, 32, 64, 128, 256

              ### Power vs Performance

              Clock frequency directly affects power consumption:

              $$P \propto f \cdot V^2$$

              Lower frequency = lower power, but slower execution.
              Many MCUs support dynamic frequency scaling.

              ### Arduino Default Clocks

              | Board | MCU | Clock |
              |-------|-----|-------|
              | Uno | ATmega328P | 16 MHz (external) |
              | Nano | ATmega328P | 16 MHz (external) |
              | Pro Mini 3.3V | ATmega328P | 8 MHz (internal) |

          - name: Memory map
            notes: |
              ## Memory Organization

              MCUs organize memory into distinct regions with different characteristics
              and access methods.

              ![MCS-51 Memory Map](https://upload.wikimedia.org/wikipedia/commons/5/54/Mcs-51_pamet.png)

              ### Memory Types

              | Type | Volatile | Use | Typical Size |
              |------|----------|-----|--------------|
              | Flash | No | Program code, constants | 16-256 KB |
              | SRAM | Yes | Variables, stack, heap | 1-32 KB |
              | EEPROM | No | Configuration, calibration | 512-4096 bytes |
              | Registers | Yes | CPU and peripheral control | Hundreds |

              ### Memory Map (AVR ATmega328P)
              ```plaintext
              0x0000-0x001F  General Purpose Registers (R0-R31)
              0x0020-0x005F  I/O Registers (64 locations)
              0x0060-0x00FF  Extended I/O Registers
              0x0100-0x08FF  SRAM (2KB)
              0x0900-0x1FFF  EEPROM (1KB)
              0x2000-0xFFFF  Flash Program Memory (32KB)
              ```

              ### Special Sections

              ![Internal RAM Organization](https://upload.wikimedia.org/wikipedia/commons/8/82/MFrey_Internal_RAM_MCS-51-DE.svg)

              - **.text**: Program code (in Flash)
              - **.data**: Initialized global variables (Flash → SRAM at startup)
              - **.bss**: Uninitialized globals (zeroed at startup)
              - **.stack**: Function call frames, local variables (grows down)
              - **.heap**: Dynamic allocation (grows up, avoid in embedded)

              ### Stack Considerations

              $$\text{Stack usage} = \text{local vars} + \text{return addresses} + \text{saved registers}$$

              Interrupts add to stack depth. Deep call chains + ISRs can overflow.
              Always leave margin — stack overflow causes mysterious crashes.

              ### Accessing Flash Data

              In Harvard architecture, constants in Flash need special access:
              ```c
              #include <avr/pgmspace.h>
              const char message[] PROGMEM = "Hello";
              char c = pgm_read_byte(&message[0]);
              ```
        resources:
          - label: SparkFun Arduino Tutorials
            url: https://learn.sparkfun.com/tutorials/tags/arduino
          - label: Adafruit Learn Arduino
            url: https://learn.adafruit.com/series/learn-arduino

      - id: mcu-peripherals
        title: Peripherals & Communication
        description: >-
          Microcontrollers talk to sensors and other devices through standardized protocols.
          I2C for multiple devices on two wires, SPI for speed, UART for simplicity.
          ADC/DAC bridge analog and digital worlds.
        prerequisites:
          - core/mcu-basics/Microcontroller Fundamentals
        outcomes:
          - Configure and use UART, SPI, and I2C
          - Read analog sensors with ADC
          - Generate analog outputs with PWM
          - Use timers and interrupts effectively
        concepts:
          - name: UART
            notes: |
              ## UART (Universal Asynchronous Receiver/Transmitter)

              UART is the simplest serial protocol — no clock line, just two data wires.
              Both devices must agree on baud rate beforehand.

              ![UART Frame Format](https://upload.wikimedia.org/wikipedia/commons/2/24/UART_Frame.svg)

              ### Frame Structure

              | Field | Bits | Description |
              |-------|------|-------------|
              | Start | 1 | Always LOW, signals frame start |
              | Data | 5-9 | LSB first, typically 8 bits |
              | Parity | 0-1 | Optional error detection |
              | Stop | 1-2 | Always HIGH, signals frame end |

              ### Baud Rate

              Common rates: 9600, 19200, 38400, 57600, **115200** (most common today)

              $$\text{Bit time} = \frac{1}{\text{baud rate}}$$

              At 115200 baud: ~8.68 µs per bit, ~86.8 µs per byte (with overhead).

              ### Connections
              ```plaintext
              Device A          Device B
              TX  ───────────── RX
              RX  ───────────── TX
              GND ───────────── GND
              ```

              Cross-connect TX/RX! Common beginner mistake.

              ### Voltage Levels

              | Standard | Logic High | Logic Low |
              |----------|------------|-----------|
              | TTL | 3.3V or 5V | 0V |
              | RS-232 | -3 to -15V | +3 to +15V |

              Never connect RS-232 directly to MCU pins — use level shifter (MAX232).

              ### Arduino Example
              ```c
              Serial.begin(115200);
              Serial.println("Hello, World!");
              if (Serial.available()) {
                  char c = Serial.read();
                  Serial.print("Received: ");
                  Serial.println(c);
                }
              ```

              See [SparkFun Serial Tutorial](https://learn.sparkfun.com/tutorials/serial-communication/all)
              for comprehensive guide.

          - name: SPI
            notes: |
              ## SPI (Serial Peripheral Interface)

              SPI is fast, full-duplex, and synchronous. The master provides the clock,
              so no baud rate agreement needed. Used for displays, SD cards, sensors.

              ![SPI Single Slave](https://upload.wikimedia.org/wikipedia/commons/e/ed/SPI_single_slave.svg)

              ### Signal Lines

              | Line | Direction | Function |
              |------|-----------|----------|
              | MOSI | Master → Slave | Master Out, Slave In |
              | MISO | Slave → Master | Master In, Slave Out |
              | SCK | Master → Slave | Serial Clock |
              | CS/SS | Master → Slave | Chip Select (active LOW) |

              ### Multiple Slaves

              ![SPI Three Slaves](https://upload.wikimedia.org/wikipedia/commons/f/fc/SPI_three_slaves.svg)

              Each slave needs its own CS line. Only one slave active at a time.

              ### Clock Modes

              ![SPI Timing Diagram](https://upload.wikimedia.org/wikipedia/commons/6/6b/SPI_timing_diagram.svg)

              | Mode | CPOL | CPHA | Description |
              |------|------|------|-------------|
              | 0 | 0 | 0 | Idle LOW, sample on rising edge |
              | 1 | 0 | 1 | Idle LOW, sample on falling edge |
              | 2 | 1 | 0 | Idle HIGH, sample on falling edge |
              | 3 | 1 | 1 | Idle HIGH, sample on rising edge |

              Check your device's datasheet for required mode!

              ### Speed

              SPI can run at 1-50 MHz typically. Limited by:
              - Slave device maximum frequency
              - Wire length and capacitance
              - EMI considerations

              ### Arduino Example
              ```c
              #include <SPI.h>
              SPI.begin();
              SPI.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
              digitalWrite(CS_PIN, LOW);
              byte response = SPI.transfer(0x42);  // Send and receive
              digitalWrite(CS_PIN, HIGH);
              SPI.endTransaction();
              ```

              See [SparkFun SPI Tutorial](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all).

          - name: I2C
            notes: |
              ## I2C (Inter-Integrated Circuit)

              I2C uses only two wires for multiple devices. Each device has a unique address.
              Great for sensors, EEPROMs, RTCs — anything that doesn't need high speed.

              ![I2C Bus](https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg)

              ### Signal Lines

              | Line | Function |
              |------|----------|
              | SDA | Serial Data (bidirectional) |
              | SCL | Serial Clock (master driven) |

              Both lines are **open-drain** with pull-up resistors (typically 4.7kΩ).

              ### Addressing

              7-bit address = up to 128 devices (some reserved).
              First byte after START: `[7-bit address][R/W bit]`

              - R/W = 0: Master writes to slave
              - R/W = 1: Master reads from slave

              ![I2C Data Transfer](https://upload.wikimedia.org/wikipedia/commons/3/3b/I2C_data_transfer.svg)

              ### Speed Modes

              | Mode | Speed | Use Case |
              |------|-------|----------|
              | Standard | 100 kHz | General purpose |
              | Fast | 400 kHz | Most sensors |
              | Fast+ | 1 MHz | Higher bandwidth |
              | High Speed | 3.4 MHz | Rare, specialized |

              ### Protocol Sequence

              1. **START**: SDA goes LOW while SCL HIGH
              2. **Address + R/W**: 8 bits, slave responds with ACK
              3. **Data**: 8 bits each, ACK after each byte
              4. **STOP**: SDA goes HIGH while SCL HIGH

              ![I2C Start Condition](https://upload.wikimedia.org/wikipedia/commons/4/48/I2C_START.svg)

              ### Arduino Example
              ```c
              #include <Wire.h>
              Wire.begin();
              Wire.beginTransmission(0x48);  // Address
              Wire.write(0x00);              // Register
              Wire.endTransmission();
              Wire.requestFrom(0x48, 2);     // Read 2 bytes
              int value = Wire.read() << 8 | Wire.read();
              ```

              See [SparkFun I2C Tutorial](https://learn.sparkfun.com/tutorials/i2c/all).

          - name: ADC/DAC
            notes: |
              ## Analog-to-Digital Conversion

              MCUs work in digital, but the real world is analog. ADC bridges that gap,
              converting continuous voltages to discrete numbers.

              ![SAR ADC Block Diagram](https://upload.wikimedia.org/wikipedia/commons/6/61/Sar_adc.svg)

              ### SAR ADC (Successive Approximation Register)

              Most common type in MCUs. Uses binary search algorithm:

              ![SAR ADC Process](https://upload.wikimedia.org/wikipedia/commons/4/45/Successive-approximation_ADC_example_Setup.svg)

              1. Compare input to DAC output (start at mid-scale)
              2. If input > DAC: keep MSB = 1, else MSB = 0
              3. Move to next bit, repeat
              4. After n bits, conversion complete

              Conversion time: n clock cycles for n-bit resolution.

              ### Resolution

              $$\text{LSB} = \frac{V_{ref}}{2^n}$$

              | Resolution | Levels | LSB (5V ref) |
              |------------|--------|--------------|
              | 8-bit | 256 | 19.5 mV |
              | 10-bit | 1024 | 4.88 mV |
              | 12-bit | 4096 | 1.22 mV |

              ### Key Specs

              - **INL/DNL**: Linearity errors (in LSBs)
              - **SNR**: Signal-to-noise ratio
              - **Sampling rate**: Conversions per second

              $$SNR_{max} = 6.02n + 1.76 \text{ dB}$$

              ### Arduino ADC
              ```c
              int value = analogRead(A0);  // 0-1023 (10-bit)
              float voltage = value * (5.0 / 1023.0);
              ```

              Default: 10-bit, ~100 µs conversion, single-ended.

              ### DAC (Digital-to-Analog)

              Not all MCUs have DAC. Alternatives:
              - **PWM + filter**: Simple, good for audio/motor control
              - **External DAC**: Higher precision (MCP4725, etc.)

          - name: PWM
            notes: |
              ## Pulse Width Modulation (PWM)

              PWM creates "analog-like" output using digital pins. By rapidly switching
              between HIGH and LOW, the average voltage can be controlled.

              ![PWM Signal](https://upload.wikimedia.org/wikipedia/commons/8/8e/Pwm_signal.png)

              ### Duty Cycle

              $$\text{Duty Cycle} = \frac{T_{ON}}{T_{period}} \times 100\%$$

              ![Duty Cycle Examples](https://upload.wikimedia.org/wikipedia/commons/4/49/Duty_Cycle_Examples.png)

              | Duty Cycle | Average Voltage (5V) |
              |------------|---------------------|
              | 0% | 0V |
              | 25% | 1.25V |
              | 50% | 2.5V |
              | 75% | 3.75V |
              | 100% | 5V |

              ### Applications

              - **LED dimming**: Duty cycle controls brightness
              - **Motor speed**: Average voltage controls speed
              - **Servo control**: Pulse width encodes position
              - **Audio**: PWM DAC with low-pass filter

              ### Arduino PWM
              ```c
              analogWrite(9, 127);  // 50% duty cycle (0-255)
              ```

              | Board | PWM Pins | Frequency |
              |-------|----------|-----------|
              | Uno | 3,5,6,9,10,11 | 490 Hz (5,6: 980 Hz) |
              | Mega | 2-13, 44-46 | 490 Hz |

              ### Timer-Based PWM

              PWM is generated by hardware timers, not software. For custom frequencies:
              ```c
              // Fast PWM, prescaler 8, ~7.8 kHz on Timer1
              TCCR1A = _BV(COM1A1) | _BV(WGM11);
              TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS11);
              ICR1 = 255;
              OCR1A = 127;  // Duty cycle
              ```

              $$f_{PWM} = \frac{f_{clock}}{prescaler \times (TOP + 1)}$$

          - name: Interrupts
            notes: |
              ## Interrupts

              Interrupts let hardware events preempt normal code execution.
              Essential for responsive, efficient embedded systems.

              ### Why Interrupts?

              **Polling** (checking repeatedly):
              ```c
              while (1) {
                  if (button_pressed()) handle_button();
                  if (serial_available()) handle_serial();
                  // Wastes CPU time waiting
                }
              ```

              **Interrupts** (event-driven):
              ```c
              ISR(INT0_vect) { handle_button(); }
              ISR(USART_RX_vect) { handle_serial(); }
              // Main loop does useful work
              ```

              ### Interrupt Vector Table

              ![Interrupt Vector Table](https://upload.wikimedia.org/wikipedia/commons/6/67/X86_Interrupt_Vector_Table.svg)

              Each interrupt source has a fixed address (vector) containing a jump
              to its handler (ISR - Interrupt Service Routine).

              ### Interrupt Types

              | Type | Source | Example |
              |------|--------|---------|
              | External | Pin change | Button press |
              | Timer | Counter overflow/match | Periodic tasks |
              | Serial | TX/RX complete | UART data |
              | ADC | Conversion complete | Sensor reading |

              ### ISR Rules

              1. **Keep it short**: Get in, set flag, get out
              2. **No blocking**: No delays, no Serial.print
              3. **volatile variables**: Required for ISR-main communication
              4. **Atomic access**: Disable interrupts when reading multi-byte shared data
              ```c
              volatile uint8_t flag = 0;

              ISR(INT0_vect) {
                  flag = 1;  // Just set flag
              }

              int main() {
                  while (1) {
                      if (flag) {
                          flag = 0;
                          handle_event();  // Process outside ISR
                      }
                  }
              }
              ```

              ### Enable/Disable
              ```c
              sei();  // Enable global interrupts
              cli();  // Disable global interrupts

              // Critical section
              cli();
              uint16_t copy = shared_value;  // Atomic read
              sei();
              ```

        resources:
          - label: SparkFun Serial Communication
            url: https://learn.sparkfun.com/tutorials/serial-communication/all
          - label: SparkFun I2C Tutorial
            url: https://learn.sparkfun.com/tutorials/i2c/all

      - id: embedded-c
        title: Embedded C Programming
        description: >-
          C is the lingua franca of embedded systems. Direct hardware access, bit manipulation,
          memory management — skills that matter when every byte counts and timing is critical.
        prerequisites:
          - core/mcu-basics/Microcontroller Fundamentals
          - C programming basics
        outcomes:
          - Write efficient embedded C code
          - Manipulate registers using bit operations
          - Understand volatile keyword and memory-mapped I/O
          - Debug embedded systems effectively
        optional: true
        concepts:
          - name: Bit manipulation
            notes: |
              ## Bit Manipulation

              Embedded systems live at the bit level. Every register, every flag,
              every hardware configuration is controlled through bits.

              ### Bitwise Operators

              | Operator | Symbol | Operation |
              |----------|--------|-----------|
              | AND | & | Mask bits |
              | OR | \| | Set bits |
              | XOR | ^ | Toggle bits |
              | NOT | ~ | Invert all bits |
              | Left Shift | << | Multiply by 2^n |
              | Right Shift | >> | Divide by 2^n |

              ### Common Macros
              ```c
              #define BIT_SET(reg, bit)     ((reg) |= (1 << (bit)))
              #define BIT_CLEAR(reg, bit)   ((reg) &= ~(1 << (bit)))
              #define BIT_TOGGLE(reg, bit)  ((reg) ^= (1 << (bit)))
              #define BIT_CHECK(reg, bit)   ((reg) & (1 << (bit)))
              ```

              ### Examples
              ```c
              // Set bit 5
              PORTB |= (1 << 5);       // PORTB = PORTB | 0b00100000

              // Clear bit 3
              PORTB &= ~(1 << 3);      // PORTB = PORTB & 0b11110111

              // Toggle bit 0
              PORTB ^= (1 << 0);       // Flip state

              // Check if bit 2 is set
              if (PINB & (1 << 2)) { /* bit is 1 */ }

              // Set multiple bits
              PORTB |= (1 << 5) | (1 << 3);  // Set bits 5 and 3

              // Clear multiple bits
              PORTB &= ~((1 << 5) | (1 << 3));
              ```

              ### Bit Fields (Alternative)
              ```c
              struct {
                  uint8_t enable : 1;
                  uint8_t mode   : 2;
                  uint8_t speed  : 3;
                  uint8_t reserved : 2;
                } config;

              config.enable = 1;
              config.mode = 2;
              ```

              Note: Bit field ordering is compiler-dependent. Use with caution.

          - name: Registers
            notes: |
              ## Hardware Registers

              Registers are special memory locations that control hardware.
              Each bit typically has a specific function defined in the datasheet.

              ### Register Access
              ```c
              // Direct register names (from header)
              DDRB = 0xFF;           // All pins output
              PORTB = 0x0F;          // Lower nibble HIGH
              uint8_t val = PINB;    // Read port

              // Using addresses
              #define PORTB  (*(volatile uint8_t *)0x25)
              #define DDRB   (*(volatile uint8_t *)0x24)
              ```

              ### Register Types

              | Type | Description | Access |
              |------|-------------|--------|
              | Control | Configure peripheral | Read/Write |
              | Status | Current state/flags | Read (some W1C) |
              | Data | Input/output values | Read/Write |

              W1C = Write 1 to Clear (common for interrupt flags)

              ### Reading the Datasheet
              ```
              TCCR1A – Timer/Counter1 Control Register A
              ┌───┬───┬───┬───┬───┬───┬───┬───┐
              │COM1A1│COM1A0│COM1B1│COM1B0│ - │ - │WGM11│WGM10│
              └───┴───┴───┴───┴───┴───┴───┴───┘
              ```

              Each bit/field is documented with:
              - Name and position
              - Read/Write capability
              - Effect of each value

              ### Safe Register Modification
              ```c
              // Read-Modify-Write pattern
              uint8_t temp = TCCR1A;
              temp &= ~(0x03);       // Clear bits 0-1
              temp |= (0x01);        // Set new value
              TCCR1A = temp;

              // Or one-liner
              TCCR1A = (TCCR1A & ~0x03) | 0x01;
              ```

          - name: Volatile
            notes: |
              ## The volatile Keyword

              `volatile` tells the compiler "this variable can change unexpectedly."
              Without it, optimizations can break your code.

              ### Why It Matters
              ```c
              // WITHOUT volatile - BROKEN
              uint8_t flag = 0;

              ISR(INT0_vect) { flag = 1; }

              void main() {
                  while (!flag) { }  // May optimize to while(1)
                  // Compiler thinks flag never changes in loop
                }
              ```
              ```c
              // WITH volatile - CORRECT
              volatile uint8_t flag = 0;

              ISR(INT0_vect) { flag = 1; }

              void main() {
                  while (!flag) { }  // Actually reads flag each time
                }
              ```

              ### When to Use volatile

              1. **Variables shared with ISR**
              2. **Memory-mapped hardware registers**
              3. **Variables modified by DMA**
              4. **Multi-threaded shared data** (with proper synchronization)

              ### Hardware Registers
              ```c
              // All hardware registers should be volatile
              volatile uint8_t *port = (volatile uint8_t *)0x25;
              *port = 0xFF;  // Compiler won't optimize away
              ```

              MCU header files define registers with volatile:
              ```c
              #define PORTB (*(volatile uint8_t *)0x25)
              ```

              ### What volatile Does NOT Do

              - Does not make access atomic
              - Does not provide memory barriers
              - Does not prevent reordering between volatile accesses

              For multi-byte variables shared with ISRs:
              ```c
              volatile uint16_t counter;

              uint16_t read_counter() {
                  cli();  // Disable interrupts
                  uint16_t copy = counter;
                  sei();  // Re-enable
                  return copy;
                }
              ```

          - name: Memory-mapped I/O
            notes: |
              ## Memory-Mapped I/O

              In most MCUs, hardware peripherals appear as memory addresses.
              Reading/writing these addresses controls the hardware.

              ### How It Works
              ```
              CPU ─────┬───── Memory Bus ─────┬───── RAM
                       │                      │
                       └──── I/O Decoder ─────┴───── Peripherals
                                              │
                                         GPIO, UART,
                                         Timers, etc.
              ```

              ### Accessing Hardware
              ```c
              // Define register address
              #define GPIO_BASE    0x40020000
              #define GPIO_MODER   (*(volatile uint32_t *)(GPIO_BASE + 0x00))
              #define GPIO_ODR     (*(volatile uint32_t *)(GPIO_BASE + 0x14))

              // Use like normal variables
              GPIO_MODER = 0x55555555;  // All outputs
              GPIO_ODR = 0x0000FFFF;    // Lower 16 bits HIGH
              ```

              ### Struct Overlay Pattern
              ```c
              typedef struct {
                  volatile uint32_t MODER;
                  volatile uint32_t OTYPER;
                  volatile uint32_t OSPEEDR;
                  volatile uint32_t PUPDR;
                  volatile uint32_t IDR;
                  volatile uint32_t ODR;
                } GPIO_TypeDef;

              #define GPIOA ((GPIO_TypeDef *)0x40020000)
              #define GPIOB ((GPIO_TypeDef *)0x40020400)

              // Clean access
              GPIOA->ODR = 0xFF;
              uint32_t input = GPIOB->IDR;
              ```

              ### Why Memory-Mapped?

              - Unified addressing simplifies CPU design
              - Same instructions for memory and I/O
              - Pointers work with hardware
              - C can directly manipulate hardware

              This is why embedded C remains dominant — direct hardware control
              without assembly language.

        resources:
          - label: Embedded Systems Programming
            url: https://www.state-machine.com/quickstart/
          - label: SparkFun Tutorials
            url: https://learn.sparkfun.com/tutorials

  - id: pcb-design
    title: PCB Design
    items:
      - id: pcb-fundamentals
        title: PCB Design Fundamentals
        description: >-
          Move from breadboard to real product. PCBs are reliable, reproducible, and
          professional. Learn the workflow: schematic → layout → fabrication files.
          KiCad is free and industry-capable.
        prerequisites:
          - fundamentals/dc-circuits/DC Circuits
          - Basic component knowledge
        outcomes:
          - Create schematics in KiCad or similar
          - Lay out simple two-layer boards
          - Generate Gerber files for fabrication
          - Understand design rules and clearances
        concepts:
          - name: Schematic capture
            notes: |
              ## Schematic Capture

              The schematic is your circuit's logical blueprint — components and their
              connections without physical placement concerns.

              ![Electrical Symbols](https://upload.wikimedia.org/wikipedia/commons/c/c8/Electrical_symbols_library.svg)

              ### Schematic Workflow

              1. **Add components** from libraries (or create custom symbols)
              2. **Place and arrange** logically (inputs left, outputs right)
              3. **Wire connections** (nets)
              4. **Add power symbols** (VCC, GND)
              5. **Annotate** (assign reference designators: R1, C1, U1)
              6. **Run ERC** (Electrical Rules Check)

              ### Symbol Elements

              ![Transistor Circuit Example](https://upload.wikimedia.org/wikipedia/commons/8/86/Transistor_Simple_Circuit_Diagram_with_NPN_Labels.svg)

              | Element | Purpose |
              |---------|---------|
              | Symbol | Graphical representation |
              | Reference | R1, C1, U1 (unique ID) |
              | Value | 10kΩ, 100nF, ATmega328P |
              | Footprint | Physical package link |
              | Pins | Connection points with names/numbers |

              ### Best Practices

              - **Signal flow**: Left-to-right, top-to-bottom
              - **Group by function**: Power, digital, analog sections
              - **Label nets**: Named nets are clearer than lines everywhere
              - **Use hierarchical sheets** for complex designs
              - **Add notes**: Document non-obvious design decisions

              ### Power Symbols

              ![Battery Symbols](https://upload.wikimedia.org/wikipedia/commons/0/0e/Battery_symbols_and_circuit.svg)

              Use global power symbols (VCC, +3V3, GND) rather than wiring
              power to every component — cleaner schematics.

              ### ERC (Electrical Rules Check)

              Catches common errors:
              - Unconnected pins
              - Multiple outputs driving same net
              - Power pins not connected
              - Input pins floating

              See [SparkFun How to Read Schematics](https://learn.sparkfun.com/tutorials/how-to-read-a-schematic)
              and [SparkFun EAGLE Schematic](https://learn.sparkfun.com/tutorials/using-eagle-schematic/all).

          - name: Layout
            notes: |
              ## PCB Layout

              Layout transforms your schematic into physical reality — component placement,
              copper traces, and layer stackup.

              ### Layout Workflow

              1. **Import netlist** from schematic
              2. **Define board outline**
              3. **Place components** (critical components first)
              4. **Route traces** (connect the nets)
              5. **Pour ground planes**
              6. **Run DRC** (Design Rules Check)
              7. **Generate manufacturing files**

              ### Layer Stackup

              | Layers | Typical Configuration |
              |--------|----------------------|
              | 2-layer | Top: Signals + Power / Bottom: GND + Signals |
              | 4-layer | Signal → GND → Power → Signal |
              | 6-layer | Sig → GND → Sig → Sig → Power → Sig |

              Two-layer is cheapest and sufficient for most hobby/simple projects.
              Four-layer adds solid reference planes for better signal integrity.

              ### Placement Guidelines

              1. **Connectors** at board edges
              2. **Decoupling caps** close to IC power pins
              3. **Crystal/oscillator** close to MCU
              4. **High-frequency** components near their sources
              5. **Thermal** considerations (hot components away from sensitive ones)
              6. **Mechanical** constraints (mounting holes, keep-outs)

              ### Routing Guidelines

              - **Shortest path** (but not at expense of other rules)
              - **Avoid 90° corners** (use 45° or curves)
              - **Match trace lengths** for high-speed differential pairs
              - **Keep analog/digital separate**
              - **Don't route under noisy components**

              ### Trace Width

              Width determines current capacity:

              | Width (1oz Cu) | ~Current (10°C rise) |
              |----------------|---------------------|
              | 10 mil | 300 mA |
              | 20 mil | 800 mA |
              | 50 mil | 1.5 A |
              | 100 mil | 3 A |

              Use online calculators for precise values based on your stackup.

              ### Ground Planes

              Pour copper fills connected to GND:
              - Low impedance return path
              - EMI shielding
              - Heat dissipation

              See [SparkFun PCB Basics](https://learn.sparkfun.com/tutorials/pcb-basics/all)
              and [SparkFun EAGLE Layout](https://learn.sparkfun.com/tutorials/using-eagle-board-layout/all).

          - name: Gerbers
            notes: |
              ## Gerber Files

              Gerbers are the universal language of PCB fabrication — every manufacturer
              accepts them. They describe each layer as 2D artwork.

              ### Standard File Set

              | Extension | Layer | Description |
              |-----------|-------|-------------|
              | .GTL | Top Copper | Signal traces, pads |
              | .GBL | Bottom Copper | Signal traces, pads |
              | .GTS | Top Solder Mask | Green coating openings |
              | .GBS | Bottom Solder Mask | Green coating openings |
              | .GTO | Top Silkscreen | Component labels |
              | .GBO | Bottom Silkscreen | Component labels |
              | .GTP | Top Paste | Stencil for solder paste |
              | .GBP | Bottom Paste | Stencil for solder paste |
              | .GKO / .GM1 | Board Outline | Mechanical boundary |
              | .DRL | Drill File | Hole locations (Excellon format) |

              ### Gerber Format

              **RS-274X** (extended Gerber) is the modern standard:
              - Embedded aperture definitions
              - Self-contained files
              - ASCII format (human-readable)

              ### Generation Workflow

              1. Run final DRC check
              2. Generate Gerbers (plot each layer)
              3. Generate drill file (Excellon format)
              4. **Review in Gerber viewer** (critical step!)
              5. Zip all files together
              6. Upload to manufacturer

              ### Gerber Viewers

              Always verify before ordering:
              - **KiCad GerbView** (built-in)
              - **gerbv** (free, open-source)
              - **Online viewers** (OSH Park, JLCPCB)

              ### Common Mistakes

              - Missing drill file
              - Wrong board outline layer
              - Solder mask inverted (shows mask, not openings)
              - Missing paste layer for SMD assembly
              - Different units (mm vs inches) between files

              ### Manufacturer Upload

              Most fabs (JLCPCB, PCBWay, OSH Park) auto-detect layers
              from standard extensions. Review their preview before ordering!

          - name: Design rules
            notes: |
              ## Design Rules (DRC)

              Design rules ensure your PCB can actually be manufactured.
              Every fab has minimum capabilities — violate them and your
              board fails or costs extra.

              ### Critical Parameters

              | Parameter | Typical Minimum | Description |
              |-----------|-----------------|-------------|
              | Trace width | 6-8 mil | Narrowest copper |
              | Trace spacing | 6-8 mil | Gap between copper |
              | Via drill | 10-12 mil | Hole diameter |
              | Via annular ring | 5-8 mil | Copper around hole |
              | Solder mask dam | 4 mil | Mask between pads |
              | Silkscreen width | 5-6 mil | Text/line minimum |

              1 mil = 0.001 inch = 0.0254 mm

              ### Clearances
              Clearances prevent shorts and manufacturing issues:
              ```
              ┌─────────────────────────────────────┐
              │  Trace ══════  ║spacing║  ══════ Trace  │
              │                                     │
              │  Pad ●────── annular ring ──────● Via │
              │                                     │
              │  Board edge ├── edge clearance ──┤   │
              └─────────────────────────────────────┘
              ```

              - **Trace-to-trace**: Prevent shorts
              - **Trace-to-pad**: Manufacturing tolerance
              - **Pad-to-pad**: Solder bridging prevention
              - **Edge clearance**: Routing/panelization

              ### High Voltage Considerations

              For voltages >50V, spacing must increase:

              $$\text{Spacing (mm)} \approx 0.1 + \frac{V_{peak}}{500}$$

              Consult IPC-2221 for proper clearances.

              ### DRC Setup

              Configure rules in your EDA tool before layout:
              ```
              Minimum trace width:     0.2mm (8 mil)
              Minimum clearance:       0.2mm (8 mil)
              Minimum via drill:       0.3mm (12 mil)
              Minimum annular ring:    0.15mm (6 mil)
              Board edge clearance:    0.5mm (20 mil)
              ```

              ### Manufacturer Capabilities

              Check your fab's specs! Example (JLCPCB standard):

              | Parameter | Standard | Advanced |
              |-----------|----------|----------|
              | Min trace/space | 5/5 mil | 3.5/3.5 mil |
              | Min via drill | 0.3mm | 0.2mm |
              | Min hole size | 0.3mm | 0.15mm |

              Advanced capabilities cost more. Design to standard rules when possible.

              ### Running DRC

              1. Set rules matching your manufacturer
              2. Run DRC before generating Gerbers
              3. Fix all errors (yellow = warning, red = error)
              4. Re-run until clean
              5. Document any intentional rule violations

              See TI application notes for advanced guidelines:
              - [PCB EMI Guidelines](https://www.ti.com/lit/pdf/szza009)
              - [High Speed Layout](https://www.ti.com/lit/pdf/scaa082)

        resources:
          - label: KiCad Getting Started
            url: https://docs.kicad.org/
          - label: SparkFun PCB Basics
            url: https://learn.sparkfun.com/tutorials/pcb-basics/all
