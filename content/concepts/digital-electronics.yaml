# EEE Roadmap — Concept Library: digital-electronics
# Auto-generated by scripts/migrate-to-library.mjs — review and edit as needed.
# See CONTRIBUTING.md for the concept file format.
_meta:
  domain: digital-electronics
  description: Logic circuits, digital design, and microprocessor fundamentals
concepts:
  adc-dac:
    name: ADC/DAC
    notes: |
      ## Analog-to-Digital Conversion

      MCUs work in digital, but the real world is analog. ADC bridges that gap,
      converting continuous voltages to discrete numbers.

      ![SAR ADC Block Diagram](https://upload.wikimedia.org/wikipedia/commons/6/61/Sar_adc.svg)

      ### SAR ADC (Successive Approximation Register)

      Most common type in MCUs. Uses binary search algorithm:

      ![SAR ADC Process](https://upload.wikimedia.org/wikipedia/commons/4/45/Successive-approximation_ADC_example_Setup.svg)

      1. Compare input to DAC output (start at mid-scale)
      2. If input > DAC: keep MSB = 1, else MSB = 0
      3. Move to next bit, repeat
      4. After n bits, conversion complete

      Conversion time: n clock cycles for n-bit resolution.

      ### Resolution

      $$\text{LSB} = \frac{V_{ref}}{2^n}$$

      | Resolution | Levels | LSB (5V ref) |
      |------------|--------|--------------|
      | 8-bit | 256 | 19.5 mV |
      | 10-bit | 1024 | 4.88 mV |
      | 12-bit | 4096 | 1.22 mV |

      ### Key Specs

      - **INL/DNL**: Linearity errors (in LSBs)
      - **SNR**: Signal-to-noise ratio
      - **Sampling rate**: Conversions per second

      $$SNR_{max} = 6.02n + 1.76 \text{ dB}$$

      ### Arduino ADC
      ```c
      int value = analogRead(A0);  // 0-1023 (10-bit)
      float voltage = value * (5.0 / 1023.0);
      ```

      Default: 10-bit, ~100 µs conversion, single-ended.

      ### DAC (Digital-to-Analog)

      Not all MCUs have DAC. Alternatives:
      - **PWM + filter**: Simple, good for audio/motor control
      - **External DAC**: Higher precision (MCP4725, etc.)
  adders:
    name: Adders
    notes: |
      Binary adders are the foundation of arithmetic logic units.
      Built from simple gates, they perform the addition we take for granted.

      **Half Adder:**
      Adds two 1-bit numbers, produces Sum and Carry.

      $$Sum = A \oplus B$$
      $$Carry = A \cdot B$$

      ![Half adder circuit](https://upload.wikimedia.org/wikipedia/commons/d/d9/Half-adder.svg)

      **Full Adder:**
      Adds three 1-bit numbers (A, B, and Carry-in).

      $$Sum = A \oplus B \oplus C_{in}$$
      $$C_{out} = AB + C_{in}(A \oplus B)$$

      ![Full adder logic diagram](https://upload.wikimedia.org/wikipedia/commons/6/69/Full-adder_logic_diagram.svg)

      **Ripple Carry Adder:**
      Chain full adders together — carry ripples from LSB to MSB.

      ![Ripple carry adder](https://upload.wikimedia.org/wikipedia/commons/5/5d/Full_Adder_Modules.svg)

      **The Propagation Delay Problem:**
      For n-bit addition, worst case is n × (full adder delay).
      A 32-bit ripple adder is slow!

      ![Full adder propagation delay](https://upload.wikimedia.org/wikipedia/commons/d/d5/Full-Adder_Propagation_Delay.svg)

      **Faster Adders:**
      - **Carry Lookahead (CLA):** Compute carries in parallel using
        Generate ($G = AB$) and Propagate ($P = A \oplus B$) signals
      - **Carry Select:** Compute both possibilities, select when carry arrives
      - **Carry Skip:** Skip over blocks that propagate

      **Subtraction:**
      Use 2's complement: $A - B = A + \bar{B} + 1$
      Invert B, set carry-in to 1.
  architecture:
    name: Architecture
    notes: |
      ## Microcontroller Architecture

      A microcontroller (MCU) integrates a processor core, memory, and peripherals
      on a single chip — a complete computer system in miniature.

      ### Von Neumann vs Harvard Architecture

      ![Von Neumann Architecture](https://upload.wikimedia.org/wikipedia/commons/e/e5/Von_Neumann_Architecture.svg)

      **Von Neumann** uses a single bus for both instructions and data:
      - Simpler design, fewer connections
      - Potential bottleneck (can't fetch instruction while accessing data)
      - Used in: x86 processors, some ARM cores

      ![Harvard Architecture](https://upload.wikimedia.org/wikipedia/commons/3/3f/Harvard_architecture.svg)

      **Harvard** separates instruction and data buses:
      - Simultaneous instruction fetch and data access
      - Higher performance for embedded applications
      - Used in: AVR (Arduino), PIC, most ARM Cortex-M

      ### Core Components

      ![8051 Block Diagram](https://upload.wikimedia.org/wikipedia/commons/7/79/Microcontroller_8051.gif)

      | Component | Function |
      |-----------|----------|
      | CPU | Executes instructions (ALU, registers, control unit) |
      | Flash | Program memory (non-volatile, stores your code) |
      | SRAM | Data memory (volatile, variables, stack) |
      | Peripherals | I/O ports, timers, ADC, communication interfaces |
      | Clock | System timing (internal RC or external crystal) |

      ### Word Size

      - **8-bit**: AVR, PIC, 8051 — simple, low power, cheap
      - **16-bit**: MSP430 — ultra-low power applications
      - **32-bit**: ARM Cortex-M — performance, complex applications

      The word size affects register width, address space, and arithmetic efficiency.
      8-bit MCUs handle 32-bit math through multiple operations.

      ### Pipeline and Execution

      Most MCUs use pipelining for efficiency:

      $$\text{Throughput} = \frac{\text{Instructions}}{\text{Clock cycles}}$$

      AVR achieves ~1 MIPS/MHz through single-cycle execution of most instructions.
  bit-manipulation:
    name: Bit manipulation
    notes: |
      ## Bit Manipulation

      Embedded systems live at the bit level. Every register, every flag,
      every hardware configuration is controlled through bits.

      ### Bitwise Operators

      | Operator | Symbol | Operation |
      |----------|--------|-----------|
      | AND | & | Mask bits |
      | OR | \| | Set bits |
      | XOR | ^ | Toggle bits |
      | NOT | ~ | Invert all bits |
      | Left Shift | << | Multiply by 2^n |
      | Right Shift | >> | Divide by 2^n |

      ### Common Macros
      ```c
      #define BIT_SET(reg, bit)     ((reg) |= (1 << (bit)))
      #define BIT_CLEAR(reg, bit)   ((reg) &= ~(1 << (bit)))
      #define BIT_TOGGLE(reg, bit)  ((reg) ^= (1 << (bit)))
      #define BIT_CHECK(reg, bit)   ((reg) & (1 << (bit)))
      ```

      ### Examples
      ```c
      // Set bit 5
      PORTB |= (1 << 5);       // PORTB = PORTB | 0b00100000

      // Clear bit 3
      PORTB &= ~(1 << 3);      // PORTB = PORTB & 0b11110111

      // Toggle bit 0
      PORTB ^= (1 << 0);       // Flip state

      // Check if bit 2 is set
      if (PINB & (1 << 2)) { /* bit is 1 */ }

      // Set multiple bits
      PORTB |= (1 << 5) | (1 << 3);  // Set bits 5 and 3

      // Clear multiple bits
      PORTB &= ~((1 << 5) | (1 << 3));
      ```

      ### Bit Fields (Alternative)
      ```c
      struct {
          uint8_t enable : 1;
          uint8_t mode   : 2;
          uint8_t speed  : 3;
          uint8_t reserved : 2;
        } config;

      config.enable = 1;
      config.mode = 2;
      ```

      Note: Bit field ordering is compiler-dependent. Use with caution.
  clock:
    name: Clock
    notes: |
      ## Clock System

      The clock is the heartbeat of your MCU — every operation is synchronized to it.
      Understanding clock configuration is essential for timing-critical applications.

      ### Clock Sources

      | Source | Accuracy | Startup | Power |
      |--------|----------|---------|-------|
      | Internal RC | ±1-10% | Fast (~µs) | Lowest |
      | External Crystal | ±20-50 ppm | Slow (~ms) | Medium |
      | External Oscillator | Best | Fast | Highest |
      | PLL (multiplied) | Varies | Medium | High |

      ### Clock Tree

      The system clock feeds various subsystems through dividers:
      ![Clock Tree Example](https://upload.wikimedia.org/wikipedia/commons/2/2e/Clock_tree_MCU.svg)

      ```plaintext
      Main Clock → CPU Clock
                → Peripheral Clock (may be divided)
                → Timer Clock
                → ADC Clock
      ```

      ### Prescalers

      Prescalers divide the clock for slower peripherals:

      $$f_{peripheral} = \frac{f_{system}}{2^n}$$

      Common prescaler values: 1, 2, 4, 8, 16, 32, 64, 128, 256

      ### Power vs Performance

      Clock frequency directly affects power consumption:

      $$P \propto f \cdot V^2$$

      Lower frequency = lower power, but slower execution.
      Many MCUs support dynamic frequency scaling.

      ### Arduino Default Clocks

      | Board | MCU | Clock |
      |-------|-----|-------|
      | Uno | ATmega328P | 16 MHz (external) |
      | Nano | ATmega328P | 16 MHz (external) |
      | Pro Mini 3.3V | ATmega328P | 8 MHz (internal) |
  counters:
    name: Counters
    notes: |
      Counters sequence through a series of states, typically counting
      up or down in binary.

      **Asynchronous (Ripple) Counter:**
      Each flip-flop is clocked by the previous stage's output.
      Simple but slow — delays accumulate.

      **Synchronous Counter:**
      All flip-flops share the same clock. Faster, more reliable.

      ![Synchronous up counter](https://upload.wikimedia.org/wikipedia/commons/8/86/3_bit_up_synchronous_counter.svg)

      **Binary Up Counter Design:**
      - LSB (Q₀) toggles every clock
      - Q₁ toggles when Q₀=1
      - Q₂ toggles when Q₁Q₀=11
      - Pattern: Qₙ toggles when all lower bits are 1

      **Modulo-N Counter:**
      Counts from 0 to N-1, then wraps. A mod-10 counter counts 0-9.
      Use additional logic to detect N and reset.

      ![Synchronous down counter](https://upload.wikimedia.org/wikipedia/commons/9/91/3_bit_down_synchronous_counter.svg)

      **Up/Down Counter:**
      Direction control input selects counting direction.
      Changes the feedback logic.

      **Counter ICs:**
      - 74HC161: 4-bit synchronous binary
      - 74HC190: Decade up/down
      - 74HC4520: Dual 4-bit binary

      **Applications:**
      - Frequency division
      - Event counting
      - Timer/PWM generation
      - Address generation for memory
  de-morgans-theorem:
    name: De Morgan's theorem
    notes: |
      De Morgan's theorems let you convert between AND/OR operations and
      push inversions through expressions. Essential for NAND/NOR implementations.

      **The Two Theorems:**

      $$\overline{A + B} = \bar{A} \cdot \bar{B}$$

      $$\overline{A \cdot B} = \bar{A} + \bar{B}$$

      In words:
      - NOT(OR) = AND of NOTs → "break the bar, change the sign"
      - NOT(AND) = OR of NOTs

      ![De Morgan gate equivalents](https://upload.wikimedia.org/wikipedia/commons/e/e1/DeMorgan_Logic_Circuit_diagram_DIN.svg)

      **Bubble Pushing:**
      A visual technique using De Morgan's theorems:
      - Push bubbles through a gate, changing AND↔OR
      - Bubbles on both sides of a gate cancel

      **Generalized Form:**

      $$\overline{A_1 + A_2 + ... + A_n} = \bar{A_1} \cdot \bar{A_2} \cdot ... \cdot \bar{A_n}$$

      $$\overline{A_1 \cdot A_2 \cdot ... \cdot A_n} = \bar{A_1} + \bar{A_2} + ... + \bar{A_n}$$

      **Practical Application:**
      Convert SOP to use only NAND gates:
      1. Start with $F = AB + CD$
      2. Double invert: $F = \overline{\overline{AB + CD}}$
      3. Apply De Morgan: $F = \overline{\overline{AB} \cdot \overline{CD}}$
      4. Result: NAND of NANDs!
  encoders-decoders:
    name: Encoders/Decoders
    notes: |
      Encoders compress information (many inputs → few outputs).
      Decoders expand it (few inputs → many outputs).

      **Binary Encoder (2ⁿ:n):**
      Converts one-hot input to binary code.
      - 8:3 encoder: 8 inputs, 3-bit binary output
      - Only one input should be active at a time

      **Priority Encoder:**
      Handles multiple active inputs by encoding the highest-priority one.
      Also outputs a "valid" signal indicating at least one input is active.

      **Binary Decoder (n:2ⁿ):**
      Activates exactly one of $2^n$ outputs based on n-bit input.

      | A₁ | A₀ | Y₃ | Y₂ | Y₁ | Y₀ |
      |----|----|----|----|----|-----|
      | 0  | 0  | 0  | 0  | 0  | 1   |
      | 0  | 1  | 0  | 0  | 1  | 0   |
      | 1  | 0  | 0  | 1  | 0  | 0   |
      | 1  | 1  | 1  | 0  | 0  | 0   |

      ![Decoder circuit](https://upload.wikimedia.org/wikipedia/commons/c/c6/Decoder_Example.svg)

      **7-Segment Decoder:**
      Converts 4-bit BCD to 7 outputs for display segments.

      ![7-segment display](https://upload.wikimedia.org/wikipedia/commons/0/02/7_segment_display_labeled.svg)

      **Applications:**
      - Memory chip select (address decoding)
      - Instruction decoding in CPUs
      - Keyboard encoding
      - Display drivers
  flip-flops:
    name: Flip-flops
    notes: |
      Flip-flops are bistable circuits that store one bit. They're the
      fundamental building blocks of all sequential logic.

      **SR (Set-Reset) Flip-Flop:**
      The simplest memory element, but has a forbidden state.

      | S | R | Q⁺ | Action |
      |---|---|----|--------|
      | 0 | 0 | Q  | Hold |
      | 0 | 1 | 0  | Reset |
      | 1 | 0 | 1  | Set |
      | 1 | 1 | ?  | **Forbidden** |

      ![SR flip-flop using NOR gates](https://upload.wikimedia.org/wikipedia/commons/c/c6/RS_Flip-flop_%28NOR%29.svg)

      **D (Data) Flip-Flop:**
      The most commonly used type. Output follows input on clock edge.

      $$Q^+ = D$$

      ![D flip-flop symbol](https://upload.wikimedia.org/wikipedia/commons/8/8c/D-Type_Flip-flop.svg)

      **JK Flip-Flop:**
      Like SR but with no forbidden state. J=K=1 toggles the output.

      $$Q^+ = J\bar{Q} + \bar{K}Q$$

      | J | K | Q⁺ | Action |
      |---|---|----|--------|
      | 0 | 0 | Q  | Hold |
      | 0 | 1 | 0  | Reset |
      | 1 | 0 | 1  | Set |
      | 1 | 1 | Q̄  | Toggle |

      ![JK flip-flop](https://upload.wikimedia.org/wikipedia/commons/1/1c/JK_Flip-flop.svg)

      **T (Toggle) Flip-Flop:**
      Toggles on each clock when T=1. Perfect for counters.

      $$Q^+ = T \oplus Q$$

      ![T flip-flop](https://upload.wikimedia.org/wikipedia/commons/e/e2/T-Type_Flip-flop.svg)

      **Edge Triggering:**
      Modern flip-flops are edge-triggered (positive or negative edge),
      not level-triggered. This prevents transparency issues.

      **Timing Parameters:**
      - **Setup time ($t_{su}$):** Data must be stable before clock edge
      - **Hold time ($t_h$):** Data must remain stable after clock edge
      - **Propagation delay ($t_{pd}$):** Clock edge to output change
  gpio:
    name: GPIO
    notes: |
      ## General Purpose Input/Output (GPIO)

      GPIO pins are the fundamental interface between your MCU and the outside world.
      Each pin can be configured as input (reading sensors, buttons) or output
      (driving LEDs, motors).

      ### Port Registers (AVR Example)

      ![Port Register Structure](https://upload.wikimedia.org/wikipedia/commons/d/d6/MFrey_Port_1_MCS-51.svg)

      Each I/O port typically has three registers:

      | Register | Function |
      |----------|----------|
      | DDRx | Data Direction (0 = input, 1 = output) |
      | PORTx | Output data / Pull-up enable |
      | PINx | Read input state |

      ### Basic Configuration
      ```c
      // Set pin as output
      DDRB |= (1 << PB5);    // Pin 13 on Arduino Uno

      // Set output high
      PORTB |= (1 << PB5);   // LED on

      // Set output low
      PORTB &= ~(1 << PB5);  // LED off

      // Toggle output
      PORTB ^= (1 << PB5);

      // Set pin as input with pull-up
      DDRD &= ~(1 << PD2);   // Input
      PORTD |= (1 << PD2);   // Enable pull-up

      // Read input
      if (PIND & (1 << PD2)) {
          // Pin is HIGH
      }
      ```

      ### Input Modes

      - **Floating (Hi-Z)**: Undefined voltage, susceptible to noise
      - **Pull-up**: Internal resistor to VCC (~20-50kΩ)
      - **Pull-down**: External resistor to GND (not always available internally)

      ### Output Modes

      - **Push-pull**: Can source and sink current
      - **Open-drain**: Can only sink current (needs external pull-up)

      ### Current Limits

      $$I_{max} \approx 20-40\text{ mA per pin}$$
      $$I_{total} \approx 100-200\text{ mA per port}$$

      Exceeding limits damages the MCU. Use transistors or drivers for high-current loads.
  i2c:
    name: I2C
    notes: |
      ## I2C (Inter-Integrated Circuit)

      I2C uses only two wires for multiple devices. Each device has a unique address.
      Great for sensors, EEPROMs, RTCs — anything that doesn't need high speed.

      ![I2C Bus](https://upload.wikimedia.org/wikipedia/commons/3/3e/I2C.svg)

      ### Signal Lines

      | Line | Function |
      |------|----------|
      | SDA | Serial Data (bidirectional) |
      | SCL | Serial Clock (master driven) |

      Both lines are **open-drain** with pull-up resistors (typically 4.7kΩ).

      ### Addressing

      7-bit address = up to 128 devices (some reserved).
      First byte after START: `[7-bit address][R/W bit]`

      - R/W = 0: Master writes to slave
      - R/W = 1: Master reads from slave

      ![I2C Data Transfer](https://upload.wikimedia.org/wikipedia/commons/3/3b/I2C_data_transfer.svg)

      ### Speed Modes

      | Mode | Speed | Use Case |
      |------|-------|----------|
      | Standard | 100 kHz | General purpose |
      | Fast | 400 kHz | Most sensors |
      | Fast+ | 1 MHz | Higher bandwidth |
      | High Speed | 3.4 MHz | Rare, specialized |

      ### Protocol Sequence

      1. **START**: SDA goes LOW while SCL HIGH
      2. **Address + R/W**: 8 bits, slave responds with ACK
      3. **Data**: 8 bits each, ACK after each byte
      4. **STOP**: SDA goes HIGH while SCL HIGH

      ![I2C Start Condition](https://upload.wikimedia.org/wikipedia/commons/4/48/I2C_START.svg)

      ### Arduino Example
      ```c
      #include <Wire.h>
      Wire.begin();
      Wire.beginTransmission(0x48);  // Address
      Wire.write(0x00);              // Register
      Wire.endTransmission();
      Wire.requestFrom(0x48, 2);     // Read 2 bytes
      int value = Wire.read() << 8 | Wire.read();
      ```

      See [SparkFun I2C Tutorial](https://learn.sparkfun.com/tutorials/i2c/all).
  interrupts:
    name: Interrupts
    notes: |
      ## Interrupts

      Interrupts let hardware events preempt normal code execution.
      Essential for responsive, efficient embedded systems.

      ### Why Interrupts?

      **Polling** (checking repeatedly):
      ```c
      while (1) {
          if (button_pressed()) handle_button();
          if (serial_available()) handle_serial();
          // Wastes CPU time waiting
        }
      ```

      **Interrupts** (event-driven):
      ```c
      ISR(INT0_vect) { handle_button(); }
      ISR(USART_RX_vect) { handle_serial(); }
      // Main loop does useful work
      ```

      ### Interrupt Vector Table

      ![Interrupt Vector Table](https://upload.wikimedia.org/wikipedia/commons/6/67/X86_Interrupt_Vector_Table.svg)

      Each interrupt source has a fixed address (vector) containing a jump
      to its handler (ISR - Interrupt Service Routine).

      ### Interrupt Types

      | Type | Source | Example |
      |------|--------|---------|
      | External | Pin change | Button press |
      | Timer | Counter overflow/match | Periodic tasks |
      | Serial | TX/RX complete | UART data |
      | ADC | Conversion complete | Sensor reading |

      ### ISR Rules

      1. **Keep it short**: Get in, set flag, get out
      2. **No blocking**: No delays, no Serial.print
      3. **volatile variables**: Required for ISR-main communication
      4. **Atomic access**: Disable interrupts when reading multi-byte shared data
      ```c
      volatile uint8_t flag = 0;

      ISR(INT0_vect) {
          flag = 1;  // Just set flag
      }

      int main() {
          while (1) {
              if (flag) {
                  flag = 0;
                  handle_event();  // Process outside ISR
              }
          }
      }
      ```

      ### Enable/Disable
      ```c
      sei();  // Enable global interrupts
      cli();  // Disable global interrupts

      // Critical section
      cli();
      uint16_t copy = shared_value;  // Atomic read
      sei();
      ```
  k-maps:
    name: K-maps
    notes: |
      Karnaugh maps provide a visual method for simplifying Boolean expressions.
      Adjacent cells differ by exactly one variable, enabling easy grouping.

      **2-Variable K-map:**
      ```
            B=0  B=1
      A=0 |  0  |  1  |
      A=1 |  2  |  3  |
      ```

      **3-Variable K-map:**
      ```
             BC=00  BC=01  BC=11  BC=10
      A=0  |   0  |   1  |   3  |   2  |
      A=1  |   4  |   5  |   7  |   6  |
      ```

      Note the Gray code ordering: 00, 01, 11, 10 (only one bit changes).

      ![K-map with groupings](https://upload.wikimedia.org/wikipedia/commons/2/2c/Karnaugh_map_KV_Venn_Diagramm.svg)

      **Simplification Rules:**
      1. Group adjacent 1s in powers of 2 (1, 2, 4, 8...)
      2. Groups can wrap around edges (the map is a torus!)
      3. Make groups as large as possible
      4. Cover all 1s with minimum number of groups
      5. Each group becomes one product term

      **Reading Groups:**
      - Variables that don't change across the group → include in term
      - Variables that do change → eliminate from term

      A group of $2^k$ cells eliminates $k$ variables.

      ![K-map torus topology](https://upload.wikimedia.org/wikipedia/commons/f/fb/Karnaugh_map_torus.svg)

      **Don't Cares (X):**
      Can be treated as 0 or 1 — choose whichever gives larger groups.
      Common in BCD circuits where codes 10-15 are unused.
  memory-map:
    name: Memory map
    notes: |
      ## Memory Organization

      MCUs organize memory into distinct regions with different characteristics
      and access methods.

      ![MCS-51 Memory Map](https://upload.wikimedia.org/wikipedia/commons/5/54/Mcs-51_pamet.png)

      ### Memory Types

      | Type | Volatile | Use | Typical Size |
      |------|----------|-----|--------------|
      | Flash | No | Program code, constants | 16-256 KB |
      | SRAM | Yes | Variables, stack, heap | 1-32 KB |
      | EEPROM | No | Configuration, calibration | 512-4096 bytes |
      | Registers | Yes | CPU and peripheral control | Hundreds |

      ### Memory Map (AVR ATmega328P)
      ```plaintext
      0x0000-0x001F  General Purpose Registers (R0-R31)
      0x0020-0x005F  I/O Registers (64 locations)
      0x0060-0x00FF  Extended I/O Registers
      0x0100-0x08FF  SRAM (2KB)
      0x0900-0x1FFF  EEPROM (1KB)
      0x2000-0xFFFF  Flash Program Memory (32KB)
      ```

      ### Special Sections

      ![Internal RAM Organization](https://upload.wikimedia.org/wikipedia/commons/8/82/MFrey_Internal_RAM_MCS-51-DE.svg)

      - **.text**: Program code (in Flash)
      - **.data**: Initialized global variables (Flash → SRAM at startup)
      - **.bss**: Uninitialized globals (zeroed at startup)
      - **.stack**: Function call frames, local variables (grows down)
      - **.heap**: Dynamic allocation (grows up, avoid in embedded)

      ### Stack Considerations

      $$\text{Stack usage} = \text{local vars} + \text{return addresses} + \text{saved registers}$$

      Interrupts add to stack depth. Deep call chains + ISRs can overflow.
      Always leave margin — stack overflow causes mysterious crashes.

      ### Accessing Flash Data

      In Harvard architecture, constants in Flash need special access:
      ```c
      #include <avr/pgmspace.h>
      const char message[] PROGMEM = "Hello";
      char c = pgm_read_byte(&message[0]);
      ```
  memory-mapped-i-o:
    name: Memory-mapped I/O
    notes: |
      ## Memory-Mapped I/O

      In most MCUs, hardware peripherals appear as memory addresses.
      Reading/writing these addresses controls the hardware.

      ### How It Works
      ```
      CPU ─────┬───── Memory Bus ─────┬───── RAM
               │                      │
               └──── I/O Decoder ─────┴───── Peripherals
                                      │
                                 GPIO, UART,
                                 Timers, etc.
      ```

      ### Accessing Hardware
      ```c
      // Define register address
      #define GPIO_BASE    0x40020000
      #define GPIO_MODER   (*(volatile uint32_t *)(GPIO_BASE + 0x00))
      #define GPIO_ODR     (*(volatile uint32_t *)(GPIO_BASE + 0x14))

      // Use like normal variables
      GPIO_MODER = 0x55555555;  // All outputs
      GPIO_ODR = 0x0000FFFF;    // Lower 16 bits HIGH
      ```

      ### Struct Overlay Pattern
      ```c
      typedef struct {
          volatile uint32_t MODER;
          volatile uint32_t OTYPER;
          volatile uint32_t OSPEEDR;
          volatile uint32_t PUPDR;
          volatile uint32_t IDR;
          volatile uint32_t ODR;
        } GPIO_TypeDef;

      #define GPIOA ((GPIO_TypeDef *)0x40020000)
      #define GPIOB ((GPIO_TypeDef *)0x40020400)

      // Clean access
      GPIOA->ODR = 0xFF;
      uint32_t input = GPIOB->IDR;
      ```

      ### Why Memory-Mapped?

      - Unified addressing simplifies CPU design
      - Same instructions for memory and I/O
      - Pointers work with hardware
      - C can directly manipulate hardware

      This is why embedded C remains dominant — direct hardware control
      without assembly language.
  mux-demux:
    name: Mux/Demux
    notes: |
      Multiplexers (MUX) select one of many inputs to pass to the output.
      Demultiplexers (DEMUX) route one input to one of many outputs.

      **2:1 Multiplexer:**

      $$Y = \bar{S} \cdot I_0 + S \cdot I_1$$

      When S=0, Y=I₀. When S=1, Y=I₁.

      ![2-to-1 MUX](https://upload.wikimedia.org/wikipedia/commons/e/e0/Multiplexer_2-to-1.svg)

      **General MUX:**
      - $n$ select lines → $2^n$ data inputs
      - 4:1 MUX has 2 select lines, 4 data inputs
      - 8:1 MUX has 3 select lines, 8 data inputs

      ![4-to-1 MUX](https://upload.wikimedia.org/wikipedia/commons/7/75/4-to-1_multiplexer.svg)

      **MUX as Universal Logic:**
      Any n-variable function can be implemented with a $2^n$:1 MUX:
      - Connect variables to select lines
      - Connect 0, 1, or variable to data inputs based on truth table

      **Demultiplexer (1:n DEMUX):**
      Routes single input to one of $2^n$ outputs based on select lines.
      Often combined with decoder functionality.

      ![Demultiplexer](https://upload.wikimedia.org/wikipedia/commons/1/15/Demultiplexer_Example01.svg)

      **Applications:**
      - Data routing in buses
      - Time-division multiplexing
      - Memory address decoding
      - Function generators
  pwm:
    name: PWM
    notes: |
      ## Pulse Width Modulation (PWM)

      PWM creates "analog-like" output using digital pins. By rapidly switching
      between HIGH and LOW, the average voltage can be controlled.

      ![PWM Signal](https://upload.wikimedia.org/wikipedia/commons/8/8e/Pwm_signal.png)

      ### Duty Cycle

      $$\text{Duty Cycle} = \frac{T_{ON}}{T_{period}} \times 100\%$$

      ![Duty Cycle Examples](https://upload.wikimedia.org/wikipedia/commons/4/49/Duty_Cycle_Examples.png)

      | Duty Cycle | Average Voltage (5V) |
      |------------|---------------------|
      | 0% | 0V |
      | 25% | 1.25V |
      | 50% | 2.5V |
      | 75% | 3.75V |
      | 100% | 5V |

      ### Applications

      - **LED dimming**: Duty cycle controls brightness
      - **Motor speed**: Average voltage controls speed
      - **Servo control**: Pulse width encodes position
      - **Audio**: PWM DAC with low-pass filter

      ### Arduino PWM
      ```c
      analogWrite(9, 127);  // 50% duty cycle (0-255)
      ```

      | Board | PWM Pins | Frequency |
      |-------|----------|-----------|
      | Uno | 3,5,6,9,10,11 | 490 Hz (5,6: 980 Hz) |
      | Mega | 2-13, 44-46 | 490 Hz |

      ### Timer-Based PWM

      PWM is generated by hardware timers, not software. For custom frequencies:
      ```c
      // Fast PWM, prescaler 8, ~7.8 kHz on Timer1
      TCCR1A = _BV(COM1A1) | _BV(WGM11);
      TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS11);
      ICR1 = 255;
      OCR1A = 127;  // Duty cycle
      ```

      $$f_{PWM} = \frac{f_{clock}}{prescaler \times (TOP + 1)}$$
  registers:
    name: Registers
    notes: |
      ## Hardware Registers

      Registers are special memory locations that control hardware.
      Each bit typically has a specific function defined in the datasheet.

      ### Register Access
      ```c
      // Direct register names (from header)
      DDRB = 0xFF;           // All pins output
      PORTB = 0x0F;          // Lower nibble HIGH
      uint8_t val = PINB;    // Read port

      // Using addresses
      #define PORTB  (*(volatile uint8_t *)0x25)
      #define DDRB   (*(volatile uint8_t *)0x24)
      ```

      ### Register Types

      | Type | Description | Access |
      |------|-------------|--------|
      | Control | Configure peripheral | Read/Write |
      | Status | Current state/flags | Read (some W1C) |
      | Data | Input/output values | Read/Write |

      W1C = Write 1 to Clear (common for interrupt flags)

      ### Reading the Datasheet
      ```
      TCCR1A – Timer/Counter1 Control Register A
      ┌───┬───┬───┬───┬───┬───┬───┬───┐
      │COM1A1│COM1A0│COM1B1│COM1B0│ - │ - │WGM11│WGM10│
      └───┴───┴───┴───┴───┴───┴───┴───┘
      ```

      Each bit/field is documented with:
      - Name and position
      - Read/Write capability
      - Effect of each value

      ### Safe Register Modification
      ```c
      // Read-Modify-Write pattern
      uint8_t temp = TCCR1A;
      temp &= ~(0x03);       // Clear bits 0-1
      temp |= (0x01);        // Set new value
      TCCR1A = temp;

      // Or one-liner
      TCCR1A = (TCCR1A & ~0x03) | 0x01;
      ```
  spi:
    name: SPI
    notes: |
      ## SPI (Serial Peripheral Interface)

      SPI is fast, full-duplex, and synchronous. The master provides the clock,
      so no baud rate agreement needed. Used for displays, SD cards, sensors.

      ![SPI Single Slave](https://upload.wikimedia.org/wikipedia/commons/e/ed/SPI_single_slave.svg)

      ### Signal Lines

      | Line | Direction | Function |
      |------|-----------|----------|
      | MOSI | Master → Slave | Master Out, Slave In |
      | MISO | Slave → Master | Master In, Slave Out |
      | SCK | Master → Slave | Serial Clock |
      | CS/SS | Master → Slave | Chip Select (active LOW) |

      ### Multiple Slaves

      ![SPI Three Slaves](https://upload.wikimedia.org/wikipedia/commons/f/fc/SPI_three_slaves.svg)

      Each slave needs its own CS line. Only one slave active at a time.

      ### Clock Modes

      ![SPI Timing Diagram](https://upload.wikimedia.org/wikipedia/commons/6/6b/SPI_timing_diagram.svg)

      | Mode | CPOL | CPHA | Description |
      |------|------|------|-------------|
      | 0 | 0 | 0 | Idle LOW, sample on rising edge |
      | 1 | 0 | 1 | Idle LOW, sample on falling edge |
      | 2 | 1 | 0 | Idle HIGH, sample on falling edge |
      | 3 | 1 | 1 | Idle HIGH, sample on rising edge |

      Check your device's datasheet for required mode!

      ### Speed

      SPI can run at 1-50 MHz typically. Limited by:
      - Slave device maximum frequency
      - Wire length and capacitance
      - EMI considerations

      ### Arduino Example
      ```c
      #include <SPI.h>
      SPI.begin();
      SPI.beginTransaction(SPISettings(1000000, MSBFIRST, SPI_MODE0));
      digitalWrite(CS_PIN, LOW);
      byte response = SPI.transfer(0x42);  // Send and receive
      digitalWrite(CS_PIN, HIGH);
      SPI.endTransaction();
      ```

      See [SparkFun SPI Tutorial](https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all).
  state-machines:
    name: State machines
    notes: |
      Finite State Machines (FSMs) are the general model for sequential
      circuits. They consist of states, transitions, and outputs.

      **Moore Machine:**
      Outputs depend only on current state.
      More stable outputs (change only on clock edges).

      ![Moore machine example](https://upload.wikimedia.org/wikipedia/commons/a/ab/FSM_mooreModel_doorCtrl.png)

      **Mealy Machine:**
      Outputs depend on current state AND inputs.
      Faster response but outputs can glitch.

      ![Mealy machine example](https://upload.wikimedia.org/wikipedia/commons/f/f3/FSM_Mealy_model_doorCtrl.png)

      **FSM Design Process:**
      1. Define states and state diagram
      2. Create state transition table
      3. Choose state encoding (binary, one-hot, Gray)
      4. Derive next-state logic (K-maps or equations)
      5. Derive output logic
      6. Implement with flip-flops and gates

      ![FSM block diagram](https://upload.wikimedia.org/wikipedia/commons/8/80/Finite_State_Machine_Logic.svg)

      **State Encoding:**
      - **Binary:** Minimum flip-flops, complex logic
      - **One-Hot:** One flip-flop per state, simple logic, more FFs
      - **Gray Code:** Only one bit changes per transition, reduces glitches

      **Example: Traffic Light Controller**
      States: Green→Yellow→Red→Green...
      Inputs: Timer, sensor
      Outputs: Light signals

      **Avoiding Common Pitfalls:**
      - Initialize to a known state (reset)
      - Handle unused states (don't let FSM get stuck)
      - Watch for asynchronous input synchronization
  truth-tables:
    name: Truth tables
    notes: |
      Truth tables exhaustively list all input combinations and their outputs.
      They're the starting point for designing any combinational logic circuit.

      **Basic Gate Truth Tables:**

      | A | B | AND | OR | NAND | NOR | XOR | XNOR |
      |---|---|-----|----|----- |-----|-----|------|
      | 0 | 0 |  0  | 0  |  1   |  1  |  0  |  1   |
      | 0 | 1 |  0  | 1  |  1   |  0  |  1  |  0   |
      | 1 | 0 |  0  | 1  |  1   |  0  |  1  |  0   |
      | 1 | 1 |  1  | 1  |  0   |  0  |  0  |  1   |

      ![Logic gate symbols](https://upload.wikimedia.org/wikipedia/commons/0/0f/LogicGates.svg)

      **Boolean Expressions from Truth Tables:**
      1. Find all rows where output = 1
      2. Write a product (AND) term for each row
      3. Sum (OR) all product terms together

      This gives the Sum of Products (SOP) form.

      **Example:** $F = \bar{A}\bar{B}C + \bar{A}BC + AB\bar{C} + ABC$

      **Minterms and Maxterms:**
      - Minterm: AND of all variables (complemented or not) that produces 1
      - Maxterm: OR of all variables that produces 0
      - $F = \sum m(1,3,5,7)$ means F=1 for minterms 1,3,5,7

      For a deeper dive, see [All About Circuits - Boolean Algebra](https://www.allaboutcircuits.com/textbook/digital/chpt-7/introduction-boolean-algebra/).
  uart:
    name: UART
    notes: |
      ## UART (Universal Asynchronous Receiver/Transmitter)

      UART is the simplest serial protocol — no clock line, just two data wires.
      Both devices must agree on baud rate beforehand.

      ![UART Frame Format](https://upload.wikimedia.org/wikipedia/commons/2/24/UART_Frame.svg)

      ### Frame Structure

      | Field | Bits | Description |
      |-------|------|-------------|
      | Start | 1 | Always LOW, signals frame start |
      | Data | 5-9 | LSB first, typically 8 bits |
      | Parity | 0-1 | Optional error detection |
      | Stop | 1-2 | Always HIGH, signals frame end |

      ### Baud Rate

      Common rates: 9600, 19200, 38400, 57600, **115200** (most common today)

      $$\text{Bit time} = \frac{1}{\text{baud rate}}$$

      At 115200 baud: ~8.68 µs per bit, ~86.8 µs per byte (with overhead).

      ### Connections
      ```plaintext
      Device A          Device B
      TX  ───────────── RX
      RX  ───────────── TX
      GND ───────────── GND
      ```

      Cross-connect TX/RX! Common beginner mistake.

      ### Voltage Levels

      | Standard | Logic High | Logic Low |
      |----------|------------|-----------|
      | TTL | 3.3V or 5V | 0V |
      | RS-232 | -3 to -15V | +3 to +15V |

      Never connect RS-232 directly to MCU pins — use level shifter (MAX232).

      ### Arduino Example
      ```c
      Serial.begin(115200);
      Serial.println("Hello, World!");
      if (Serial.available()) {
          char c = Serial.read();
          Serial.print("Received: ");
          Serial.println(c);
        }
      ```

      See [SparkFun Serial Tutorial](https://learn.sparkfun.com/tutorials/serial-communication/all)
      for comprehensive guide.
  universal-gates:
    name: Universal gates
    notes: |
      NAND and NOR gates are "universal" — any Boolean function can be built
      using only NAND gates or only NOR gates. This simplifies manufacturing.

      **Why Universal?**
      If you can make NOT, AND, and OR from a single gate type, you can
      build anything. Both NAND and NOR can do this.

      **Building Blocks from NAND:**

      ![NOT from NAND](https://upload.wikimedia.org/wikipedia/commons/f/f9/NOT_from_NAND.svg)

      - **NOT:** Connect both inputs together: $\bar{A} = \overline{A \cdot A}$
      - **AND:** NAND followed by NOT: $AB = \overline{\overline{AB}}$
      - **OR:** NOT inputs, then NAND: $A+B = \overline{\bar{A} \cdot \bar{B}}$

      ![AND from NAND](https://upload.wikimedia.org/wikipedia/commons/1/16/AND_from_NAND.svg)

      ![OR from NAND](https://upload.wikimedia.org/wikipedia/commons/9/90/OR_from_NAND.svg)

      **Building Blocks from NOR:**

      - **NOT:** $\bar{A} = \overline{A + A}$
      - **OR:** NOR followed by NOT
      - **AND:** NOT inputs, then NOR

      ![AND from NOR](https://upload.wikimedia.org/wikipedia/commons/9/9e/AND_from_NOR.svg)

      **Why NAND Dominates:**
      In CMOS, NAND gates are faster and smaller than NOR gates because
      NMOS transistors (in series for NAND) are faster than PMOS.

      **Gate Count Optimization:**
      Direct NAND/NOR implementation often uses fewer transistors than
      converting from AND/OR/NOT. Modern synthesis tools handle this automatically.

      ![MIT OCW Combinational Logic](/pdfs/mit-combinational-logic.pdf)
  volatile:
    name: Volatile
    notes: |
      ## The volatile Keyword

      `volatile` tells the compiler "this variable can change unexpectedly."
      Without it, optimizations can break your code.

      ### Why It Matters
      ```c
      // WITHOUT volatile - BROKEN
      uint8_t flag = 0;

      ISR(INT0_vect) { flag = 1; }

      void main() {
          while (!flag) { }  // May optimize to while(1)
          // Compiler thinks flag never changes in loop
        }
      ```
      ```c
      // WITH volatile - CORRECT
      volatile uint8_t flag = 0;

      ISR(INT0_vect) { flag = 1; }

      void main() {
          while (!flag) { }  // Actually reads flag each time
        }
      ```

      ### When to Use volatile

      1. **Variables shared with ISR**
      2. **Memory-mapped hardware registers**
      3. **Variables modified by DMA**
      4. **Multi-threaded shared data** (with proper synchronization)

      ### Hardware Registers
      ```c
      // All hardware registers should be volatile
      volatile uint8_t *port = (volatile uint8_t *)0x25;
      *port = 0xFF;  // Compiler won't optimize away
      ```

      MCU header files define registers with volatile:
      ```c
      #define PORTB (*(volatile uint8_t *)0x25)
      ```

      ### What volatile Does NOT Do

      - Does not make access atomic
      - Does not provide memory barriers
      - Does not prevent reordering between volatile accesses

      For multi-byte variables shared with ISRs:
      ```c
      volatile uint16_t counter;

      uint16_t read_counter() {
          cli();  // Disable interrupts
          uint16_t copy = counter;
          sei();  // Re-enable
          return copy;
        }
      ```
