# EEE Roadmap — Concept Library: control-systems
# Auto-generated by scripts/migrate-to-library.mjs — review and edit as needed.
# See CONTRIBUTING.md for the concept file format.
_meta:
  domain: control-systems
  description: Feedback control, stability analysis, and system dynamics
concepts:
  anti-windup:
    name: Anti-windup
    notes: |
      Integrator windup occurs when the controller output saturates but the integrator keeps accumulating error. When the error reverses, the "wound up" integrator causes massive overshoot.

      ## The Problem

      Consider a temperature controller with output limited to 0-100% heater power:

      1. Large setpoint change requested
      2. Controller commands 200% power (impossible)
      3. Actual output saturates at 100%
      4. Integrator keeps accumulating error
      5. When temperature approaches setpoint, integrator has huge accumulated value
      6. Takes long time to "unwind" — massive overshoot

      ## Solution 1: Conditional Integration

      Stop integrating when output is saturated:
      ```
      if (output < max AND output > min):
          integral += error * dt
      ```

      Simple but can cause bumpy response during saturation.

      ## Solution 2: Back-Calculation

      When saturated, feed back the difference between commanded and actual output to "unwind" the integrator:

      $$\frac{d}{dt}(\text{integral}) = K_i \cdot e + K_b \cdot (u_{actual} - u_{commanded})$$

      Where $K_b \approx 1/T_i$ is the back-calculation gain.

      ## Solution 3: Clamping

      Limit the integrator state directly:

      $$\text{integral} = \text{clamp}(\text{integral}, I_{min}, I_{max})$$

      Choose limits so that integral term alone cannot saturate output.

      ## Practical Note

      All industrial PID controllers include anti-windup. If implementing your own, ALWAYS include it — windup causes spectacular failures in real systems.
  bode-plot:
    name: Bode plot
    notes: |
      Bode plots show system frequency response as two graphs: magnitude (in dB) and phase (in degrees) versus frequency (log scale).

      ![Bode plot example](https://upload.wikimedia.org/wikipedia/commons/6/60/Bode_plot_template.svg)

      ## Construction

      Evaluate $G(j\omega)$ for $\omega$ from very low to very high:

      Magnitude: $|G(j\omega)|_{dB} = 20 \log_{10}|G(j\omega)|$

      Phase: $\angle G(j\omega)$ in degrees

      ## Standard First-Order Terms

      Pole at origin ($1/s$):
      - Magnitude: $-20$ dB/decade line through 0 dB at $\omega = 1$
      - Phase: constant $-90°$

      Real pole ($1/(1+s/\omega_p)$):
      - Magnitude: 0 dB until $\omega_p$, then $-20$ dB/decade
      - Phase: 0° at low freq, $-45°$ at $\omega_p$, $-90°$ at high freq

      Real zero ($1+s/\omega_z$):
      - Magnitude: 0 dB until $\omega_z$, then $+20$ dB/decade
      - Phase: 0° at low freq, $+45°$ at $\omega_z$, $+90°$ at high freq

      ## Second-Order Terms

      Complex poles add resonant peak at natural frequency. Height depends on damping ratio $\zeta$. Phase drops $180°$ across resonance.

      ## Reading Bode Plots

      - Bandwidth: Frequency where magnitude drops 3 dB below DC value
      - Gain crossover ($\omega_{gc}$): Where magnitude = 0 dB
      - Phase crossover ($\omega_{pc}$): Where phase = $-180°$
      - Stability margins: Measured at these crossover frequencies
  derivative-kick:
    name: Derivative kick
    notes: |
      Derivative kick is a large spike in controller output when the setpoint changes suddenly. The derivative term sees an instantaneous change in error as a huge rate of change.

      ## The Problem

      Standard derivative term: $K_d \frac{de}{dt} = K_d \frac{d(r-y)}{dt}$

      If setpoint $r$ steps instantly, $\frac{dr}{dt} \to \infty$ for an instant, causing a massive output spike.

      ## Solution: Derivative on Measurement Only

      Differentiate output (measurement) instead of error:

      $$u_d = -K_d \frac{dy}{dt}$$

      Note the negative sign! Setpoint changes don't affect derivative term. Only actual process changes do.

      ## Implementation Comparison

      Derivative on error: $D(s) = K_d s \cdot E(s) = K_d s \cdot (R(s) - Y(s))$

      Derivative on measurement: $D(s) = -K_d s \cdot Y(s)$

      ## Setpoint Weighting

      More general solution — weight the setpoint in each term:

      $$u = K_p(br - y) + K_i\int(r-y)dt + K_d\frac{d(cr-y)}{dt}$$

      Where $b$ and $c$ are setpoint weights (0 to 1).

      - $b = 1$, $c = 0$: P on error, D on measurement (common)
      - $b = c = 0$: PI on error, D on measurement
      - $b = c = 1$: Standard PID (with kick)

      ## Practical Default

      Most industrial controllers default to derivative on measurement. If you see setpoint step causing output spike, check this setting.
  gain-phase-margin:
    name: Gain/phase margin
    notes: |
      Gain and phase margins quantify how close a system is to instability. Larger margins = more robust to model uncertainty.

      ## Definitions

      **Gain Margin (GM):** How much the gain can increase before instability.

      $$GM = \frac{1}{|G(j\omega_{pc})|} \quad \text{or in dB:} \quad GM_{dB} = -20\log_{10}|G(j\omega_{pc})|$$

      Where $\omega_{pc}$ is the phase crossover frequency (where phase = $-180°$).

      **Phase Margin (PM):** How much phase lag can be added before instability.

      $$PM = 180° + \angle G(j\omega_{gc})$$

      Where $\omega_{gc}$ is the gain crossover frequency (where $|G| = 1$ or 0 dB).

      ## Graphical Interpretation

      On Bode plot:
      - GM = vertical distance from magnitude curve to 0 dB line, at $\omega_{pc}$
      - PM = vertical distance from phase curve to $-180°$ line, at $\omega_{gc}$

      ## Recommended Values

      | Application | Gain Margin | Phase Margin |
      |-------------|-------------|--------------|
      | Minimum | > 6 dB | > 30° |
      | Typical design | 10-20 dB | 45-60° |
      | Very robust | > 20 dB | > 60° |

      ## Relationship to Transient Response

      For second-order-like systems, phase margin relates to damping:

      $$\zeta \approx \frac{PM}{100}$$ (rough approximation)

      - PM = 45° → $\zeta \approx 0.45$ → ~25% overshoot
      - PM = 60° → $\zeta \approx 0.6$ → ~10% overshoot

      ## Design Use

      Adding a controller changes gain and phase. Design controller to achieve desired margins at desired bandwidth.
  nyquist:
    name: Nyquist
    notes: |
      The Nyquist plot maps the open-loop frequency response on the complex plane. The Nyquist stability criterion determines closed-loop stability from this plot.

      ![Nyquist plot](https://upload.wikimedia.org/wikipedia/commons/d/d1/Nyquist_plot.svg)

      ## Constructing the Nyquist Plot

      Plot $G(j\omega)H(j\omega)$ for $\omega$ from $-\infty$ to $+\infty$ on the complex plane.

      - Real axis: $\text{Re}[G(j\omega)]$
      - Imaginary axis: $\text{Im}[G(j\omega)]$

      Since $G(-j\omega) = G^*(j\omega)$, the negative frequency portion is a mirror image.

      ## Nyquist Stability Criterion

      $$Z = N + P$$

      Where:
      - $Z$ = number of closed-loop poles in RHP (unstable poles)
      - $N$ = number of clockwise encirclements of $-1$ point
      - $P$ = number of open-loop poles in RHP

      For stability: $Z = 0$, so $N = -P$

      If open-loop is stable ($P = 0$), the Nyquist plot must NOT encircle $-1$.

      ## Reading Margins from Nyquist

      - Gain margin: Distance from origin to where plot crosses negative real axis, relative to distance from origin to $-1$
      - Phase margin: Angle from negative real axis to where plot crosses unit circle

      ## When to Use Nyquist

      - Systems with RHP poles (open-loop unstable)
      - Time delay systems
      - Systems where Bode plot ambiguous
      - Rigorous stability proof needed

      ## Practical Note

      For most systems, Bode plots are easier to interpret. Nyquist is essential when the system has time delays or when open-loop is unstable.
  open-closed-loop:
    name: Open/closed loop
    notes: |
      Control systems are either open-loop (no feedback) or closed-loop (with feedback). This distinction fundamentally affects system behavior.

      ![Feedback loop block diagram](https://upload.wikimedia.org/wikipedia/commons/2/24/Feedback_loop_with_descriptions.svg)

      ## Open-Loop Control

      Output has no influence on input. The controller blindly applies a pre-determined input.

      Examples:
      - Toaster timer (doesn't measure toast color)
      - Washing machine cycle (doesn't measure cleanliness)
      - Stepper motor positioning (assumes no missed steps)

      Characteristics:
      - Simple and cheap
      - No stability issues
      - Cannot correct for disturbances
      - Requires accurate plant model

      ## Closed-Loop Control

      Output is measured and compared to reference. Error drives the controller.

      $$e(t) = r(t) - y(t)$$

      Where $r(t)$ is reference (setpoint), $y(t)$ is output, $e(t)$ is error.

      Examples:
      - Thermostat (measures temperature)
      - Cruise control (measures speed)
      - Servo motor (measures position)

      Characteristics:
      - Rejects disturbances
      - Reduces sensitivity to plant variations
      - Can be unstable if poorly designed
      - Requires sensors

      ## Why Negative Feedback?

      Negative feedback subtracts output from reference. If output is too high, error becomes negative, reducing the control effort. This creates self-correcting behavior.

      Positive feedback adds output to reference — any perturbation grows exponentially. Used in oscillators and latches, not regulation.
  p-i-d-terms:
    name: P, I, D terms
    notes: |
      PID control combines three terms, each responding to a different aspect of the error signal.

      ![PID controller block diagram](https://upload.wikimedia.org/wikipedia/commons/4/43/PID_en.svg)

      ## Time Domain

      $$u(t) = K_p e(t) + K_i \int_0^t e(\tau) d\tau + K_d \frac{de(t)}{dt}$$

      ## Laplace Domain

      $$C(s) = K_p + \frac{K_i}{s} + K_d s$$

      Or in standard form:

      $$C(s) = K_p \left(1 + \frac{1}{T_i s} + T_d s\right)$$

      Where $T_i = K_p/K_i$ (integral time) and $T_d = K_d/K_p$ (derivative time).

      ## Proportional (P)

      Output proportional to current error.

      - Larger $K_p$ = faster response
      - Too large = overshoot, oscillation, instability
      - Cannot eliminate steady-state error alone (except Type 1+ plants)

      ## Integral (I)

      Output proportional to accumulated error over time.

      - Eliminates steady-state error
      - Slower response than P alone
      - Too large = overshoot, slow oscillation
      - Risk of integrator windup

      ## Derivative (D)

      Output proportional to rate of change of error.

      - Predicts future error, provides damping
      - Reduces overshoot and settling time
      - Sensitive to noise (differentiation amplifies HF noise)
      - Often filtered: $K_d s \to \frac{K_d s}{1 + \tau_f s}$

      ## Common Variants

      - PI: Most common industrial controller (no noise issues)
      - PD: Used when steady-state error acceptable
      - P-only: Simplest, for non-critical applications
  root-locus:
    name: Root locus
    notes: |
      Root locus shows how closed-loop poles move in the s-plane as a parameter (usually gain $K$) varies from 0 to $\infty$.

      ![Root locus diagram](https://upload.wikimedia.org/wikipedia/commons/f/f8/Root_Locus_diagram_.svg)

      ## Basic Rules

      For characteristic equation $1 + KG(s)H(s) = 0$:

      1. **Start points ($K=0$):** Open-loop poles
      2. **End points ($K \to \infty$):** Open-loop zeros (or infinity)
      3. **Number of branches:** Number of open-loop poles
      4. **Real axis:** Locus exists where odd number of poles+zeros to the right
      5. **Asymptotes:** $(n-m)$ branches go to infinity at angles $\frac{180° + 360°k}{n-m}$
      6. **Centroid:** Asymptotes intersect real axis at $\sigma_a = \frac{\sum p_i - \sum z_i}{n-m}$

      ## Stability from Root Locus

      System stable when all branches are in LHP. Find gain $K$ where branches cross imaginary axis — this is the stability limit.

      ## Design Using Root Locus

      To place closed-loop poles at desired location:
      1. Draw root locus for plant
      2. Add compensator poles/zeros to reshape locus
      3. Choose gain for desired pole location

      ## Compensator Effects

      - Adding zero in LHP: Pulls locus left (more stable, faster)
      - Adding pole in LHP: Pushes locus right (less stable)
      - Lead compensator (zero left of pole): Improves stability margins
      - Lag compensator (pole left of zero): Improves steady-state error

      ## Software Tools

      MATLAB: `rlocus(sys)` plots root locus; `rlocfind` finds gain for desired poles

      Python: `control.root_locus(sys)`

      Root locus is excellent for understanding how controller parameters affect stability and transient response.
  steady-state-error:
    name: Steady-state error
    notes: |
      Steady-state error is the difference between desired and actual output as $t \to \infty$. A well-designed system minimizes this for expected input types.

      ## Final Value Theorem

      $$e_{ss} = \lim_{t \to \infty} e(t) = \lim_{s \to 0} s \cdot E(s)$$

      For unity feedback with reference $R(s)$:

      $$E(s) = \frac{R(s)}{1 + G(s)}$$

      ## System Type

      System type = number of integrators (poles at $s=0$) in open-loop transfer function $G(s)$.

      | Type | Step Error | Ramp Error | Parabola Error |
      |------|------------|------------|----------------|
      | 0 | $\frac{1}{1+K_p}$ | $\infty$ | $\infty$ |
      | 1 | 0 | $\frac{1}{K_v}$ | $\infty$ |
      | 2 | 0 | 0 | $\frac{1}{K_a}$ |

      ## Error Constants

      Position constant: $K_p = \lim_{s \to 0} G(s)$

      Velocity constant: $K_v = \lim_{s \to 0} s \cdot G(s)$

      Acceleration constant: $K_a = \lim_{s \to 0} s^2 \cdot G(s)$

      ## Design Implications

      To track ramps with zero steady-state error, you need at least one integrator (Type 1 system). PID controllers add an integrator via the I term.

      Higher type = better tracking but harder to stabilize. Type 2+ systems are rarely used in practice.

      ## Disturbance Rejection

      Steady-state error due to disturbances also depends on where the disturbance enters. Integrators before the disturbance point help reject it.
  tuning-methods:
    name: Tuning methods
    notes: |
      PID tuning finds gain values that give good performance for a specific plant. Many methods exist, from manual to automatic.

      ## Ziegler-Nichols (Open-Loop)

      Apply step input to open-loop plant. Measure:
      - $L$ = delay time (intersection of tangent with time axis)
      - $T$ = time constant (tangent slope)
      - $K$ = DC gain

      | Controller | $K_p$ | $T_i$ | $T_d$ |
      |------------|-------|-------|-------|
      | P | $T/(KL)$ | — | — |
      | PI | $0.9T/(KL)$ | $L/0.3$ | — |
      | PID | $1.2T/(KL)$ | $2L$ | $0.5L$ |

      ## Ziegler-Nichols (Closed-Loop)

      Use P-only control. Increase $K_p$ until sustained oscillation. Record:
      - $K_u$ = ultimate gain (gain at oscillation)
      - $T_u$ = ultimate period (oscillation period)

      | Controller | $K_p$ | $T_i$ | $T_d$ |
      |------------|-------|-------|-------|
      | P | $0.5K_u$ | — | — |
      | PI | $0.45K_u$ | $T_u/1.2$ | — |
      | PID | $0.6K_u$ | $T_u/2$ | $T_u/8$ |

      ## Cohen-Coon

      More aggressive tuning, better for self-regulating processes with significant dead time.

      ## Software/Auto-Tuning

      Modern controllers use relay feedback or model identification to auto-tune. MATLAB's `pidtune` optimizes for specified bandwidth and phase margin.

      ## Manual Tuning Rules

      1. Start with $K_i = 0$, $K_d = 0$
      2. Increase $K_p$ until acceptable response with some overshoot
      3. Add $K_i$ to eliminate steady-state error (causes more overshoot)
      4. Add $K_d$ to reduce overshoot and improve settling
