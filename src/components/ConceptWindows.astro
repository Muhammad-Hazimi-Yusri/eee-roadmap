---
// src/components/ConceptWindows.astro
// Draggable, resizable windows for displaying concept notes and PDFs
---

<!-- Container for dynamically created windows -->
<div id="concept-windows-container" class="concept-windows-container"></div>

<!-- Taskbar for minimized windows -->
<div id="concept-taskbar" class="concept-taskbar" hidden>
  <div class="concept-taskbar-items" id="concept-taskbar-items"></div>
  <div class="concept-taskbar-actions">
    <button class="taskbar-action-btn" id="minimize-all-windows" title="Minimize all windows">
      <svg width="14" height="14" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M2 6h8"/>
      </svg>
      <span class="taskbar-action-label">Minimize all</span>
    </button>
    <button class="taskbar-action-btn" id="close-all-windows" title="Close all windows">
      <svg width="14" height="14" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M2 2l8 8M10 2l-8 8"/>
      </svg>
      <span class="taskbar-action-label">Close all</span>
    </button>
  </div>
</div>

<!-- Template for a window -->
<template id="concept-window-template">
  <div class="concept-window" data-window-id="">
    <div class="concept-window-titlebar">
      <span class="concept-window-title">Concept Name</span>
      <button class="concept-window-btn concept-window-edit" aria-label="Edit notes" title="Edit notes">
        <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5">
          <path d="M8.5 1.5l2 2M1 11l.5-2L9 1.5l2 2L3.5 11 1 11z"/>
        </svg>
      </button>
      <div class="concept-window-controls">
        <button class="concept-window-btn concept-window-minimize" aria-label="Minimize" title="Minimize">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M2 6h8"/>
          </svg>
        </button>
        <button class="concept-window-btn concept-window-maximize" aria-label="Maximize" title="Maximize">
        <svg class="icon-maximize" width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="1.5" y="1.5" width="9" height="9" rx="1"/>
        </svg>
        <svg class="icon-restore" width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="1.5" style="display:none">
            <rect x="2.5" y="0.5" width="7" height="7" rx="1"/>
            <path d="M0.5 4.5v5a1 1 0 001 1h5"/>
        </svg>
        </button>
        <button class="concept-window-btn concept-window-close" aria-label="Close" title="Close">
          <svg width="12" height="12" viewBox="0 0 12 12" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M2 2l8 8M10 2l-8 8"/>
          </svg>
        </button>
      </div>
    </div>
    <div class="concept-window-content">
      <div class="concept-window-body"></div>
    </div>
    <!-- Resize handles -->
    <div class="resize-handle resize-handle-n" data-resize="n"></div>
    <div class="resize-handle resize-handle-e" data-resize="e"></div>
    <div class="resize-handle resize-handle-s" data-resize="s"></div>
    <div class="resize-handle resize-handle-w" data-resize="w"></div>
    <div class="resize-handle resize-handle-ne" data-resize="ne"></div>
    <div class="resize-handle resize-handle-se" data-resize="se"></div>
    <div class="resize-handle resize-handle-sw" data-resize="sw"></div>
    <div class="resize-handle resize-handle-nw" data-resize="nw"></div>
  </div>
</template>

<!-- Template for taskbar item -->
<template id="concept-taskbar-item-template">
  <button class="concept-taskbar-item" data-window-id="">
    <span class="concept-taskbar-item-title"></span>
  </button>
</template>

<style is:global>
  .concept-windows-container {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 1000;
  }

  /* Taskbar */
  .concept-taskbar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 40px;
    background: var(--color-bg);
    border-top: 1px solid var(--color-border);
    display: flex;
    align-items: center;
    padding: 0 0.5rem;
    z-index: 10000;
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
  }

  .concept-taskbar[hidden] {
    display: none;
  }

  .concept-taskbar-items {
    display: flex;
    gap: 0.25rem;
    overflow-x: auto;
  }

  .concept-taskbar-item {
    display: flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.75rem;
    background: var(--color-bg-grid);
    border: 1px solid var(--color-border);
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    cursor: pointer;
    white-space: nowrap;
    max-width: 150px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .concept-taskbar-item:hover {
    background: var(--color-copper);
    color: white;
    border-color: var(--color-copper);
  }
  .concept-taskbar-actions {
    display: flex;
    gap: 0.25rem;
    margin-left: auto;
    padding-left: 0.5rem;
    border-left: 1px solid var(--color-border);
  }

  .taskbar-action-btn {
    padding: 0.25rem 0.5rem;
    border: 1px solid var(--color-border);
    background: var(--color-bg);
    color: var(--color-text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 0.375rem;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.7rem;
    white-space: nowrap;
    transition: all 0.15s;
  }

  .taskbar-action-btn:hover {
    border-color: var(--color-copper);
    color: var(--color-text);
  }

  .taskbar-action-btn--glow {
    animation: pulse-glow 2s ease-in-out 3;
    border-color: var(--color-copper);
  }

  /* Hide labels when taskbar is crowded */
  .concept-taskbar--compact .taskbar-action-label {
    display: none;
  }

  /* Window */
  .concept-window {
    position: absolute;
    width: 500px;
    height: 400px;
    min-width: 250px;
    min-height: 150px;
    background: #ffffff;
    box-shadow: 
      0 4px 6px rgba(0, 0, 0, 0.1),
      0 10px 40px rgba(0, 0, 0, 0.2);
    display: flex;
    flex-direction: column;
    pointer-events: auto;
    border: 1px solid #d0d0d0;
    touch-action: none;
  }

  .concept-window--maximized {
    width: 100vw !important;
    height: 100vh !important;
    top: 0 !important;
    left: 0 !important;
    border: none;
    border-radius: 0;
  }

  .concept-window--maximized .icon-maximize {
    display: none;
  }
  
  .concept-window--maximized .icon-restore {
    display: block !important;
  }

  .dark .concept-window {
    background: #1a1a1a;
    border-color: #333;
    box-shadow: 
      0 4px 6px rgba(0, 0, 0, 0.3),
      0 10px 40px rgba(0, 0, 0, 0.5);
  }

  /* Titlebar */
  .concept-window-titlebar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.375rem 0.5rem;
    background: var(--color-bg-grid);
    border-bottom: 2px solid var(--color-copper);
    cursor: grab;
    user-select: none;
    flex-shrink: 0;
  }

  .concept-window-titlebar:active {
    cursor: grabbing;
  }

  .concept-window-title {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.8125rem;
    font-weight: 600;
    color: var(--color-text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
    margin-right: 0.5rem;
  }

  /* Window controls */
  .concept-window-controls {
    display: flex;
    gap: 0.25rem;
    flex-shrink: 0;
  }

  .concept-window-btn {
    width: 1.5rem;
    height: 1.5rem;
    border: none;
    background: transparent;
    cursor: pointer;
    color: var(--color-text-muted);
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 2px;
  }

  .concept-window-btn:hover {
    background: rgba(0, 0, 0, 0.1);
    color: var(--color-text);
  }

  :global(.dark) .concept-window-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .concept-window-close:hover {
    background: #e81123;
    color: white;
  }

  /* Edit button - positioned before controls */
  .concept-window-edit {
    margin-right: auto; /* Push controls to the right */
    margin-left: 8px;
    opacity: 0.6;
    transition: opacity 0.15s ease;
  }

  .concept-window-edit:hover {
    opacity: 1;
    background: rgba(59, 130, 246, 0.2); /* Blue tint on hover */
  }

  /* Adjust titlebar to accommodate edit button */
  .concept-window-title {
    flex-shrink: 1;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Concept Notes Editor */
  .concept-notes-editor {
    display: flex;
    flex-direction: column;
    height: 100%;
    padding: 12px;
    gap: 12px;
  }

  .concept-notes-textarea {
    flex: 1;
    width: 100%;
    min-height: 150px;
    padding: 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg);
    color: var(--text);
    font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
    font-size: 0.875rem;
    line-height: 1.5;
    resize: none;
  }

  .concept-notes-textarea:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
  }

  .concept-notes-textarea::placeholder {
    color: var(--text-muted);
    opacity: 0.7;
  }

  .concept-notes-editor-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
  }

  /* Divider between original and user notes */
  .concept-notes-divider {
    border: none;
    border-top: 1px dashed var(--border);
    margin: 16px 0;
  }

  /* User notes styling (distinguish from original) */
  .concept-notes-user {
    position: relative;
    padding-left: 12px;
    border-left: 2px solid var(--accent);
  }

  .concept-notes-user::before {
    content: '‚úèÔ∏è Your notes';
    display: block;
    font-size: 0.75rem;
    color: var(--text-muted);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  /* Content */
  .concept-window-content {
    padding: 1rem;
    overflow-y: auto;
    flex: 1;
    min-height: 0;
    overscroll-behavior: contain;
    touch-action: pan-y;
  }

  .concept-window-body {
    font-size: 0.875rem;
    line-height: 1.6;
    display: flex;
    flex-direction: column;
    height: 100%;
  }

  .concept-window-placeholder {
    color: var(--color-text-muted);
    font-style: italic;
    text-align: center;
    padding: 1.5rem;
  }

  .concept-window-notes {
    font-family: inherit;
    flex-shrink: 0;
  }

  /* Inline PDF embeds (from markdown) */
  .notes-pdf-embed {
    margin: 1rem 0;
    min-height: 200px;
    display: flex;
    flex-direction: column;
    width: 85%;
  }

  .notes-pdf-iframe {
    width: 100%;
    flex: none;
    height: 600px;
    min-height: 200px;
    border: 1px solid var(--color-border);
    border-radius: 4px 4px 0 0;
    background: #f5f5f5;
  }

  .dark .notes-pdf-iframe {
    background: #222;
  }

/* Resize divider for PDF embeds */
  .notes-pdf-resizer {
    height: 12px;
    background: var(--color-border);
    cursor: ns-resize;
    border-radius: 0 0 4px 4px;
    margin: 0;
    transition: background 0.15s;
    flex-shrink: 0;
    border: 1px solid var(--color-border);
    border-top: none;
  }

  .notes-pdf-resizer:hover,
  .notes-pdf-resizer.resizing {
    background: var(--color-copper);
  }

  .notes-pdf-resizer::after {
    content: '';
    display: block;
    width: 60px;
    height: 4px;
    background: var(--color-text-muted);
    border-radius: 2px;
    margin: 4px auto;
    opacity: 0.7;
  }

  .notes-pdf-resizer:hover::after,
  .notes-pdf-resizer.resizing::after {
    background: white;
    opacity: 1;
  }

  /* Inline images (from markdown) */
  .notes-image {
    max-width: 100%;
    height: auto;
    border-radius: 4px;
    margin: 1rem 0;
  }

  .concept-window-divider {
    border: none;
    border-top: 1px solid var(--color-border);
    margin: 1rem 0;
    flex-shrink: 0;
  }

  .concept-window-pdf-container {
    margin-top: 0.5rem;
    flex: 1;
    min-height: 300px;
  }

  .concept-window-pdf {
    width: 100%;
    height: 100%;
    min-height: 300px;
    border: 1px solid var(--color-border);
    border-radius: 4px;
    background: #f5f5f5;
  }

  .dark .concept-window-pdf {
    background: #222;
  }

  /* Resize handles */
  .resize-handle {
    position: absolute;
    background: transparent;
  }

  .resize-handle-n {
    top: -4px;
    left: 8px;
    right: 8px;
    height: 8px;
    cursor: n-resize;
  }

  .resize-handle-e {
    top: 8px;
    right: -4px;
    bottom: 8px;
    width: 8px;
    cursor: e-resize;
  }

  .resize-handle-s {
    bottom: -4px;
    left: 8px;
    right: 8px;
    height: 8px;
    cursor: s-resize;
  }

  .resize-handle-w {
    top: 8px;
    left: -4px;
    bottom: 8px;
    width: 8px;
    cursor: w-resize;
  }

  .resize-handle-ne {
    top: -4px;
    right: -4px;
    width: 12px;
    height: 12px;
    cursor: ne-resize;
  }

  .resize-handle-se {
    bottom: -4px;
    right: -4px;
    width: 12px;
    height: 12px;
    cursor: se-resize;
  }

  .resize-handle-sw {
    bottom: -4px;
    left: -4px;
    width: 12px;
    height: 12px;
    cursor: sw-resize;
  }

  .resize-handle-nw {
    top: -4px;
    left: -4px;
    width: 12px;
    height: 12px;
    cursor: nw-resize;
  }

  /* Hide resize handles when maximized */
  .concept-window--maximized .resize-handle {
    display: none;
  }

  /* Disable iframe interaction during PDF resize */
  body.pdf-resizing iframe {
    pointer-events: none;
  }

  body.pdf-resizing {
    cursor: ns-resize;
    user-select: none;
  }
</style>

<script>
  interface ConceptData {
    notesHtml?: string;
  }

  interface WindowState {
    x: number;
    y: number;
    width: number;
    height: number;
  }

  interface OpenWindow {
    id: string;
    element: HTMLElement;
    zIndex: number;
    isMinimized: boolean;
    isMaximized: boolean;
    preMaximizeState?: WindowState;
  }

  const STORAGE_KEY = 'eee-concept-window-states';
  const OPEN_WINDOWS_KEY = () => {
    const trackSlug = (window as any).trackSlug || 'unknown';
    return `eee-open-windows-${trackSlug}`;
  };
  const CASCADE_OFFSET = 30;
  const BASE_Z_INDEX = 1000;
  const DEFAULT_WIDTH = 500;
  const DEFAULT_HEIGHT = 400;

  let openWindows: OpenWindow[] = [];
  let highestZIndex = BASE_Z_INDEX;
  let cascadeCount = 0;
  // Reference viewport (set once at first window open, used for proportional scaling)
  let referenceViewportW: number | null = null;
  let referenceViewportH: number | null = null;

  // Load saved states from localStorage
  function loadStates(): Record<string, WindowState> {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      return saved ? JSON.parse(saved) : {};
    } catch {
      return {};
    }
  }

  // Save list of open windows with their state
  function saveOpenWindows() {
    const windowStates = openWindows.map(w => ({
      id: w.id,
      isMinimized: w.isMinimized,
      isMaximized: w.isMaximized
    }));
    localStorage.setItem(OPEN_WINDOWS_KEY(), JSON.stringify(windowStates));
  }

  // Load list of open windows with their state
  interface SavedWindowState {
    id: string;
    isMinimized: boolean;
    isMaximized: boolean;
  }

  function loadOpenWindows(): SavedWindowState[] {
    try {
      const saved = localStorage.getItem(OPEN_WINDOWS_KEY());
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  }

  // Restore previously open windows
  function restoreOpenWindows() {
    const savedWindows = loadOpenWindows();
    savedWindows.forEach(saved => {
      const [topicId, conceptName] = saved.id.split(':');
      if (topicId && conceptName) {
        openWindow(topicId, conceptName);
        
        // Apply saved state
        if (saved.isMinimized) {
          minimizeWindow(saved.id);
        } else if (saved.isMaximized) {
          toggleMaximize(saved.id);
        }
      }
    });
  }

  // Save states to localStorage
  function saveStates(states: Record<string, WindowState>) {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(states));
    } catch {}
  }

  // Save single window state
  function saveWindowState(windowId: string, state: WindowState) {
    const states = loadStates();
    states[windowId] = state;
    saveStates(states);
  }

  // Get current window state
  function getWindowState(win: HTMLElement): WindowState {
    return {
      x: win.offsetLeft,
      y: win.offsetTop,
      width: win.offsetWidth,
      height: win.offsetHeight
    };
  }

  // Get initial state for a window
  function getInitialState(windowId: string): WindowState {
    const viewportW = window.innerWidth;
    const viewportH = window.innerHeight;
    const isMobile = viewportW < 640;
    const isPortrait = viewportH > viewportW;
    
    // Calculate responsive dimensions
    let width: number;
    let height: number;
    
    if (isMobile) {
      // Mobile: nearly full width, leave room for edges
      width = viewportW - 16;
      // Portrait: shorter to leave room for controls, Landscape: taller
      height = isPortrait 
        ? Math.min(viewportH - 120, viewportH * 0.7) 
        : viewportH - 80;
    } else {
      // Desktop: default size clamped to viewport
      width = Math.min(DEFAULT_WIDTH, viewportW - 40);
      height = Math.min(DEFAULT_HEIGHT, viewportH - 100);
    }
    
    // If saved position exists, validate it's still on screen
    const saved = loadStates()[windowId];
    if (saved) {
      const validW = Math.min(saved.width, viewportW - 16);
      const validH = Math.min(saved.height, viewportH - 80);
      const validX = Math.max(0, Math.min(saved.x, viewportW - validW - 8));
      const validY = Math.max(0, Math.min(saved.y, viewportH - validH - 60));
      return { x: validX, y: validY, width: validW, height: validH };
    }
    
    // Position: center on mobile, cascade on desktop
    let x: number;
    let y: number;
    
    if (isMobile) {
      // Center horizontally
      x = Math.max(8, (viewportW - width) / 2);
      // Start near top so controls are visible
      y = 8 + (cascadeCount * 10);
    } else {
      // Desktop cascade
      const maxCascadeX = Math.max(0, viewportW - width - 20);
      const maxCascadeY = Math.max(0, viewportH - height - 60);
      x = Math.min(50 + (cascadeCount * CASCADE_OFFSET), maxCascadeX);
      y = Math.min(50 + (cascadeCount * CASCADE_OFFSET), maxCascadeY);
    }
    
    cascadeCount++;
    if (cascadeCount > 10) {
      cascadeCount = 0;
    }
    
    return { x, y, width, height };
  }

  // Update taskbar visibility
  function updateTaskbar() {
    const taskbar = document.getElementById('concept-taskbar');
    if (!taskbar) return;

    const hasWindows = openWindows.length > 0;
    const hasMinimized = openWindows.some(w => w.isMinimized);
    
    taskbar.hidden = !hasWindows;
    document.body.classList.toggle('has-taskbar', hasWindows);
    
    // Add compact class when many minimized windows
    const isCompact = hasMinimized && openWindows.filter(w => w.isMinimized).length >= 3;
    taskbar.classList.toggle('concept-taskbar--compact', isCompact);
    
    // Glow on first appearance
    if (hasWindows && !taskbar.dataset.hasGlowed) {
      const btns = taskbar.querySelectorAll('.taskbar-action-btn');
      btns.forEach(btn => btn.classList.add('taskbar-action-btn--glow'));
      taskbar.dataset.hasGlowed = 'true';
    }
  }

  // Bring window to front
  function bringToFront(windowId: string) {
    const win = openWindows.find(w => w.id === windowId);
    if (!win) return;
    
    highestZIndex++;
    win.zIndex = highestZIndex;
    win.element.style.zIndex = String(highestZIndex);
  }

  // Minimize window
  function minimizeWindow(windowId: string) {
    const win = openWindows.find(w => w.id === windowId);
    if (!win || win.isMinimized) return;

    win.isMinimized = true;
    win.element.style.display = 'none';

    // Add to taskbar
    const taskbarItems = document.getElementById('concept-taskbar-items');
    const template = document.getElementById('concept-taskbar-item-template') as HTMLTemplateElement;
    if (!taskbarItems || !template) return;

    const itemEl = template.content.cloneNode(true) as DocumentFragment;
    const item = itemEl.querySelector('.concept-taskbar-item') as HTMLElement;
    if (!item) return;

    item.dataset.windowId = windowId;
    const titleEl = item.querySelector('.concept-taskbar-item-title');
    const winTitle = win.element.querySelector('.concept-window-title');
    if (titleEl && winTitle) {
      titleEl.textContent = winTitle.textContent;
    }

    item.addEventListener('click', () => {
      restoreWindow(windowId);
    });

    taskbarItems.appendChild(item);
    updateTaskbar();
    saveOpenWindows();
  }

  // Restore window from minimized
  function restoreWindow(windowId: string) {
    const win = openWindows.find(w => w.id === windowId);
    if (!win || !win.isMinimized) return;

    win.isMinimized = false;
    win.element.style.display = 'flex';
    bringToFront(windowId);

    // Remove from taskbar
    const taskbarItem = document.querySelector(`.concept-taskbar-item[data-window-id="${windowId}"]`);
    taskbarItem?.remove();
    updateTaskbar();
    saveOpenWindows();
  }

  // Maximize/restore window
  function toggleMaximize(windowId: string) {
    const win = openWindows.find(w => w.id === windowId);
    if (!win) return;

    if (win.isMaximized) {
      // Restore
      win.isMaximized = false;
      win.element.classList.remove('concept-window--maximized');
      
      if (win.preMaximizeState) {
        // Clamp size to current viewport
        const viewportW = window.innerWidth;
        const viewportH = window.innerHeight;
        
        const width = Math.min(win.preMaximizeState.width, viewportW - 16);
        const height = Math.min(win.preMaximizeState.height, viewportH - 80);
        
        // Clamp position to keep window on screen
        const maxX = viewportW - width - 8;
        const maxY = viewportH - height - 60;
        
        const x = Math.max(0, Math.min(win.preMaximizeState.x, maxX));
        const y = Math.max(0, Math.min(win.preMaximizeState.y, maxY));
        
        win.element.style.left = `${x}px`;
        win.element.style.top = `${y}px`;
        win.element.style.width = `${width}px`;
        win.element.style.height = `${height}px`;
        
        // Save corrected state
        saveWindowState(windowId, { x, y, width, height });
      }
    } else {
      // Maximize
      win.preMaximizeState = getWindowState(win.element);
      win.isMaximized = true;
      win.element.classList.add('concept-window--maximized');
    }
    saveOpenWindows();
  }

  // Revalidate all window positions on viewport resize
  function initResizeHandler() {
    // Use ResizeObserver for reliable viewport change detection
    const resizeObserver = new ResizeObserver(() => {
      revalidateAllWindows();
    });
    
    // Observe the document element (catches all viewport changes)
    resizeObserver.observe(document.documentElement);
    
    // Also handle orientation changes on mobile
    window.addEventListener('orientationchange', () => {
      setTimeout(revalidateAllWindows, 100);
    });
    
    // Fallback resize event
    window.addEventListener('resize', revalidateAllWindows);
    
    // Handle visibility change (e.g., switching monitors while minimized)
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        revalidateAllWindows();
      }
    });
  }
  
  // Reposition windows proportionally relative to reference viewport
  function revalidateAllWindows() {
    const viewportW = window.innerWidth;
    const viewportH = window.innerHeight;
    
    // No reference yet (no windows opened)
    if (referenceViewportW === null || referenceViewportH === null) return;
    
    // Calculate scale factors from reference
    const scaleX = viewportW / referenceViewportW;
    const scaleY = viewportH / referenceViewportH;
    
    openWindows.forEach((winData) => {
      if (winData.isMinimized || winData.isMaximized) return;
      
      const win = winData.element;
      
      // Get saved state (original position at reference viewport)
      const saved = loadStates()[winData.id];
      if (!saved) return;
      
      // Scale from saved position
      let x = saved.x * scaleX;
      let y = saved.y * scaleY;
      let width = saved.width * scaleX;
      let height = saved.height * scaleY;
      
      // Clamp size to min/max
      const minW = 250;
      const minH = 150;
      const maxW = viewportW - 16;
      const maxH = viewportH - 80;
      
      width = Math.max(minW, Math.min(width, maxW));
      height = Math.max(minH, Math.min(height, maxH));
      
      // Clamp position to keep window on screen
      const maxX = viewportW - width - 8;
      const maxY = viewportH - height - 60;
      
      x = Math.max(0, Math.min(x, maxX));
      y = Math.max(0, Math.min(y, maxY));
      
      // Apply new position and size
      win.style.left = `${x}px`;
      win.style.top = `${y}px`;
      win.style.width = `${width}px`;
      win.style.height = `${height}px`;
    });
  }

  // Create and open a window
  function openWindow(topicId: string, conceptName: string) {
    const windowId = `${topicId}:${conceptName}`;
    
    // If already open, bring to front or restore
    const existing = openWindows.find(w => w.id === windowId);
    if (existing) {
      if (existing.isMinimized) {
        restoreWindow(windowId);
      } else {
        bringToFront(windowId);
      }
      return;
    }

    // Get concept data
    const allData = (window as any).conceptData || {};
    const topicData = allData[topicId] || {};
    const concept: ConceptData = topicData[conceptName] || {};

    // Clone template
    const template = document.getElementById('concept-window-template') as HTMLTemplateElement;
    const container = document.getElementById('concept-windows-container');
    if (!template || !container) return;

    const windowEl = template.content.cloneNode(true) as DocumentFragment;
    const win = windowEl.querySelector('.concept-window') as HTMLElement;
    if (!win) return;

    // Set window ID and title
    win.dataset.windowId = windowId;
    const titleEl = win.querySelector('.concept-window-title');
    if (titleEl) titleEl.textContent = conceptName;

    // Set content
    const bodyEl = win.querySelector('.concept-window-body');
    if (bodyEl) {
      // Load and render content (async to fetch user notes if needed)
      renderWindowContent(bodyEl, topicId, conceptName, concept.notesHtml || '');
    }

    // Update edit button title based on context
    const editBtn = win.querySelector('.concept-window-edit');
    if (editBtn) {
      const trackSlug = (window as any).trackSlug || 'unknown';
      const noteKey = `${trackSlug}/${topicId}/${conceptName}`;
      const conceptNotes = (window as any).conceptNotes || {};
      const hasUserNotes = !!conceptNotes[noteKey];
      
      editBtn.setAttribute('title', hasUserNotes ? 'Edit your notes' : 'Add your notes');
      editBtn.setAttribute('aria-label', hasUserNotes ? 'Edit your notes' : 'Add your notes');
    }
    
    // Set initial position and width
    const state = getInitialState(windowId);
    win.style.left = `${state.x}px`;
    win.style.top = `${state.y}px`;
    win.style.width = `${state.width}px`;
    win.style.height = 'auto'; // Temporary for measurement

    // Set z-index
    highestZIndex++;
    win.style.zIndex = String(highestZIndex);

    // Add to DOM (needed to measure)
    container.appendChild(win);

    // Measure and set final height
    const titlebar = win.querySelector('.concept-window-titlebar') as HTMLElement;
    const content = win.querySelector('.concept-window-content') as HTMLElement;
    const titlebarH = titlebar?.offsetHeight || 40;
    const contentH = content?.scrollHeight || 100;
    const idealHeight = titlebarH + contentH + 2; // 2px for border

    // Clamp between min and max
    const minH = 150;
    const maxH = Math.min(state.height, window.innerHeight - 80);
    const finalHeight = Math.max(minH, Math.min(idealHeight, maxH));

    win.style.height = `${finalHeight}px`;

    // Track window
    const windowData: OpenWindow = {
      id: windowId,
      element: win,
      zIndex: highestZIndex,
      isMinimized: false,
      isMaximized: false
    };
    openWindows.push(windowData);

    // Set reference viewport on first window open
    if (referenceViewportW === null) {
      referenceViewportW = window.innerWidth;
      referenceViewportH = window.innerHeight;
    }

    // Setup event listeners
    setupWindowEvents(win, windowId);

    // Apply stored PDF heights
    applyStoredPdfHeights(win);

    // Trigger tooltip init for glossary terms
    document.dispatchEvent(new CustomEvent('concept-window-opened'));
    
    // Update taskbar and persist
    updateTaskbar();
    
    // Persist open windows list
    saveOpenWindows();
  }

  // Close a window
  function closeWindow(windowId: string) {
    const index = openWindows.findIndex(w => w.id === windowId);
    if (index === -1) return;

    const win = openWindows[index];
    win.element.remove();
    openWindows.splice(index, 1);

    // Remove from taskbar if minimized
    const taskbarItem = document.querySelector(`.concept-taskbar-item[data-window-id="${windowId}"]`);
    taskbarItem?.remove();
    updateTaskbar();

    // Persist open windows list
    saveOpenWindows();
  }

  // Setup all window events
  function setupWindowEvents(win: HTMLElement, windowId: string) {
    const titlebar = win.querySelector('.concept-window-titlebar') as HTMLElement;
    const closeBtn = win.querySelector('.concept-window-close');
    const minimizeBtn = win.querySelector('.concept-window-minimize');
    const maximizeBtn = win.querySelector('.concept-window-maximize');
    const editBtn = win.querySelector('.concept-window-edit');
    const controls = win.querySelector('.concept-window-controls');

    // Close
    closeBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      closeWindow(windowId);
    });

    // Edit notes
    editBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      openNotesEditor(win, windowId);
    });

    // Minimize
    minimizeBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      minimizeWindow(windowId);
    });

    // Maximize
    maximizeBtn?.addEventListener('click', (e) => {
      e.stopPropagation();
      toggleMaximize(windowId);
    });

    // Double-click titlebar to maximize
    titlebar?.addEventListener('dblclick', (e) => {
      if (controls?.contains(e.target as Node)) return;
      toggleMaximize(windowId);
    });

    // Bring to front on click
    win.addEventListener('mousedown', () => {
      bringToFront(windowId);
    });

    // Drag
    setupDrag(win, windowId, titlebar, controls);

    // Resize
    setupResize(win, windowId);

    // Prevent page scroll when touching anywhere on window
    win.addEventListener('touchmove', (e) => {
      const target = e.target as HTMLElement;
      const content = win.querySelector('.concept-window-content') as HTMLElement;

      // If inside content area, only allow if content is actually scrollable
      if (content?.contains(target)) {
        const isScrollable = content.scrollHeight > content.clientHeight;
        if (!isScrollable) {
          e.preventDefault();
        }
        // If scrollable, let it scroll naturally (overscroll-behavior handles edge case)
        return;
      }

      // Prevent page scroll elsewhere on window
      e.preventDefault();
    }, { passive: false });
  }

  // Drag functionality
  function setupDrag(win: HTMLElement, windowId: string, titlebar: HTMLElement | null, controls: Element | null) {
    let isDragging = false;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    titlebar?.addEventListener('mousedown', (e) => {
      if (controls?.contains(e.target as Node)) return;
      
      const winData = openWindows.find(w => w.id === windowId);
      if (winData?.isMaximized) return;

      isDragging = true;
      dragOffsetX = e.clientX - win.offsetLeft;
      dragOffsetY = e.clientY - win.offsetTop;
      bringToFront(windowId);
    });

    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;

      const x = e.clientX - dragOffsetX;
      const y = e.clientY - dragOffsetY;

      const maxX = window.innerWidth - win.offsetWidth;
      const maxY = window.innerHeight - win.offsetHeight;

      win.style.left = `${Math.max(0, Math.min(x, maxX))}px`;
      win.style.top = `${Math.max(0, Math.min(y, maxY))}px`;
    });

    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        // Save normalized to reference viewport
      if (referenceViewportW && referenceViewportH) {
        const state = getWindowState(win);
        const scaleX = referenceViewportW / window.innerWidth;
        const scaleY = referenceViewportH / window.innerHeight;
        saveWindowState(windowId, {
          x: state.x * scaleX,
          y: state.y * scaleY,
          width: state.width * scaleX,
          height: state.height * scaleY
        });
      } else {
        saveWindowState(windowId, getWindowState(win));
      }
      }
    });

    // Touch support - prevent page scroll when dragging
    titlebar?.addEventListener('touchstart', (e) => {
      if (controls?.contains(e.target as Node)) return;
      
      const winData = openWindows.find(w => w.id === windowId);
      if (winData?.isMaximized) return;
    
      e.preventDefault(); // Prevent page scroll
      const touch = e.touches[0];
      isDragging = true;
      dragOffsetX = touch.clientX - win.offsetLeft;
      dragOffsetY = touch.clientY - win.offsetTop;
      bringToFront(windowId);
    }, { passive: false }); // Note: passive: false to allow preventDefault

    document.addEventListener('touchmove', (e) => {
      if (!isDragging) return;

      const touch = e.touches[0];
      const x = touch.clientX - dragOffsetX;
      const y = touch.clientY - dragOffsetY;

      const maxX = window.innerWidth - win.offsetWidth;
      const maxY = window.innerHeight - win.offsetHeight;

      win.style.left = `${Math.max(0, Math.min(x, maxX))}px`;
      win.style.top = `${Math.max(0, Math.min(y, maxY))}px`;
    }, { passive: true });

    document.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        // Save normalized to reference viewport
        if (referenceViewportW && referenceViewportH) {
          const state = getWindowState(win);
          const scaleX = referenceViewportW / window.innerWidth;
          const scaleY = referenceViewportH / window.innerHeight;
          saveWindowState(windowId, {
            x: state.x * scaleX,
            y: state.y * scaleY,
            width: state.width * scaleX,
            height: state.height * scaleY
          });
        } else {
          saveWindowState(windowId, getWindowState(win));
}
      }
    });
  }

  /// Resize functionality
  function setupResize(win: HTMLElement, windowId: string) {
    const handles = win.querySelectorAll('.resize-handle');
  let isResizing = false;
  let resizeDir = '';
  let startX = 0;
  let startY = 0;
  let startWidth = 0;
  let startHeight = 0;
  let startLeft = 0;
  let startTop = 0;

  function startResize(clientX: number, clientY: number, dir: string) {
    const winData = openWindows.find(w => w.id === windowId);
    if (winData?.isMaximized) return false;

    isResizing = true;
    resizeDir = dir;
    startX = clientX;
    startY = clientY;
    startWidth = win.offsetWidth;
    startHeight = win.offsetHeight;
    startLeft = win.offsetLeft;
    startTop = win.offsetTop;
    bringToFront(windowId);
    return true;
  }

  function doResize(clientX: number, clientY: number) {
    if (!isResizing) return;

    const dx = clientX - startX;
    const dy = clientY - startY;
    const minW = 250;
    const minH = 150;

    let newWidth = startWidth;
    let newHeight = startHeight;
    let newLeft = startLeft;
    let newTop = startTop;

    if (resizeDir.includes('e')) {
      newWidth = Math.max(minW, startWidth + dx);
    }
    if (resizeDir.includes('w')) {
      const w = Math.max(minW, startWidth - dx);
      newLeft = startLeft + (startWidth - w);
      newWidth = w;
    }
    if (resizeDir.includes('s')) {
      newHeight = Math.max(minH, startHeight + dy);
    }
    if (resizeDir.includes('n')) {
      const h = Math.max(minH, startHeight - dy);
      newTop = startTop + (startHeight - h);
      newHeight = h;
    }

    // Constrain to viewport
    const maxW = window.innerWidth - newLeft - 10;
    const maxH = window.innerHeight - newTop - 10;
    
    win.style.width = `${Math.min(newWidth, maxW)}px`;
    win.style.height = `${Math.min(newHeight, maxH)}px`;
    win.style.left = `${Math.max(0, newLeft)}px`;
    win.style.top = `${Math.max(0, newTop)}px`;
  }

  function endResize() {
    if (isResizing) {
      isResizing = false;
      // Save normalized to reference viewport
      if (referenceViewportW && referenceViewportH) {
        const state = getWindowState(win);
        const scaleX = referenceViewportW / window.innerWidth;
        const scaleY = referenceViewportH / window.innerHeight;
        saveWindowState(windowId, {
          x: state.x * scaleX,
          y: state.y * scaleY,
          width: state.width * scaleX,
          height: state.height * scaleY
        });
      } else {
        saveWindowState(windowId, getWindowState(win));
      }
    }
  }

  // Mouse events
  handles.forEach(handle => {
    handle.addEventListener('mousedown', (e) => {
        e.stopPropagation();
        const dir = (handle as HTMLElement).dataset.resize || '';
        startResize((e as MouseEvent).clientX, (e as MouseEvent).clientY, dir);
      });
  
      // Touch events
      handle.addEventListener('touchstart', (e) => {
        e.stopPropagation();
        e.preventDefault();
        const touch = (e as TouchEvent).touches[0];
        const dir = (handle as HTMLElement).dataset.resize || '';
        startResize(touch.clientX, touch.clientY, dir);
      }, { passive: false });
    });
  
    document.addEventListener('mousemove', (e) => doResize(e.clientX, e.clientY));
    document.addEventListener('mouseup', endResize);
  
    document.addEventListener('touchmove', (e) => {
      if (!isResizing) return;
      e.preventDefault();
      const touch = e.touches[0];
      doResize(touch.clientX, touch.clientY);
    }, { passive: false });
  
    document.addEventListener('touchend', endResize);
    document.addEventListener('touchcancel', endResize);
  }

  // Taskbar action buttons
  function initTaskbarActions() {
    const minimizeAllBtn = document.getElementById('minimize-all-windows');
    const closeAllBtn = document.getElementById('close-all-windows');

    minimizeAllBtn?.addEventListener('click', () => {
      openWindows.forEach(w => {
        if (!w.isMinimized) {
          minimizeWindow(w.id);
        }
      });
    });

    closeAllBtn?.addEventListener('click', () => {
      // Grab IDs first, then close
      const idsToClose = openWindows.map(w => w.id);
      idsToClose.forEach(id => closeWindow(id));
    });
  }

  // Open notes editor in the concept window
  function openNotesEditor(win: HTMLElement, windowId: string) {
    const [topicId, conceptName] = windowId.split(':');
    const trackSlug = (window as any).trackSlug || 'unknown';
    
    // Check if this is a custom concept
    const isCustomTrack = (window as any).isCustomTrack || false;
    const conceptData = (window as any).conceptData || {};
    const concept = conceptData[topicId]?.[conceptName] || {};
    const isCustomConcept = isCustomTrack || concept.isCustom || false;
    
    const bodyEl = win.querySelector('.concept-window-body');
    if (!bodyEl) return;
    
    // Store original content for cancel
    const originalHtml = bodyEl.innerHTML;
    
    // Determine what to load in the editor
    let existingContent = '';
    
    if (isCustomConcept) {
      // Custom concept: load the raw markdown from conceptNotes or empty
      // For custom concepts, we store markdown in conceptNotes with same key pattern
      const noteKey = `${trackSlug}/${topicId}/${conceptName}`;
      const conceptNotes = (window as any).conceptNotes || {};
      existingContent = conceptNotes[noteKey] || '';
    } else {
      // Official concept: load user's additional notes
      const noteKey = `${trackSlug}/${topicId}/${conceptName}`;
      const conceptNotes = (window as any).conceptNotes || {};
      existingContent = conceptNotes[noteKey] || '';
    }
    
    // Different placeholder text based on concept type
    const placeholder = isCustomConcept 
      ? `Write your concept notes in Markdown...

Supports:
- **bold**, *italic*
- LaTeX: $E = mc^2$
- Images: ![alt](url)
- PDFs: ![label](file.pdf)`
      : `Add your personal notes for this concept...

Your notes will appear above the official content.

Supports: **bold**, *italic*, LaTeX: $E = mc^2$`;
    
    // Create editor UI
    bodyEl.innerHTML = `
      <div class="concept-notes-editor">
        <textarea class="concept-notes-textarea" placeholder="${placeholder}">${existingContent}</textarea>
        <div class="concept-notes-editor-actions">
          <button class="btn btn--sm concept-notes-cancel">Cancel</button>
          <button class="btn btn--sm btn--primary concept-notes-save">Save</button>
        </div>
      </div>
    `;
    
    // Focus textarea
    const textarea = bodyEl.querySelector('.concept-notes-textarea') as HTMLTextAreaElement;
    textarea?.focus();
    
    // Cancel button - restore original content
    bodyEl.querySelector('.concept-notes-cancel')?.addEventListener('click', () => {
      bodyEl.innerHTML = originalHtml;
    });
    
    // Save button
    bodyEl.querySelector('.concept-notes-save')?.addEventListener('click', async () => {
      const markdown = textarea?.value || '';
      await saveConceptNotes(windowId, markdown, win, isCustomConcept);
    });
  }

  // Save concept notes to Supabase and update display
  async function saveConceptNotes(
    windowId: string,
    markdown: string, 
    win: HTMLElement,
    isCustomConcept: boolean
  ) {
    const [topicId, conceptName] = windowId.split(':');
    const trackSlug = (window as any).trackSlug || 'unknown';
    const noteKey = `${trackSlug}/${topicId}/${conceptName}`;
    
    const bodyEl = win.querySelector('.concept-window-body');
    if (!bodyEl) return;
    
    // Show saving state
    const saveBtn = bodyEl.querySelector('.concept-notes-save') as HTMLButtonElement;
    if (saveBtn) {
      saveBtn.disabled = true;
      saveBtn.textContent = 'Saving...';
    }
    
    try {
      const { loadCustomContent, saveCustomContent } = await import('../lib/sync');
      const { parseNotesClient } = await import('../utils/parseNotesClient');
      
      // Load existing content
      const content = await loadCustomContent();
      
      // Initialize conceptNotes if needed
      if (!content.conceptNotes) {
        content.conceptNotes = {};
      }
      
      // Update or remove the note
      if (markdown.trim()) {
        content.conceptNotes[noteKey] = markdown;
      } else {
        delete content.conceptNotes[noteKey];
      }
      
      // Save to Supabase
      const success = await saveCustomContent(content);
      
      if (!success) {
        alert('Failed to save. Are you signed in?');
        if (saveBtn) {
          saveBtn.disabled = false;
          saveBtn.textContent = 'Save';
        }
        return;
      }
      
      // Update local cache
      const conceptNotes = (window as any).conceptNotes || {};
      if (markdown.trim()) {
        conceptNotes[noteKey] = markdown;
      } else {
        delete conceptNotes[noteKey];
      }
      (window as any).conceptNotes = conceptNotes;
      
      // Parse the markdown
      const notesHtml = markdown.trim() ? parseNotesClient(markdown) : '';
      
      // Update conceptData
      const conceptData = (window as any).conceptData || {};
      if (!conceptData[topicId]) conceptData[topicId] = {};
      if (!conceptData[topicId][conceptName]) conceptData[topicId][conceptName] = {};
      
      const existing = conceptData[topicId][conceptName];
      
      if (isCustomConcept) {
        // Custom concept: replace entire content
        existing.notesHtml = notesHtml ? `<div class="concept-notes-user">${notesHtml}</div>` : '';
      } else {
        // Official concept: store original, show user notes on top
        if (!existing.originalHtml && existing.notesHtml) {
          existing.originalHtml = existing.notesHtml;
        }
        const originalHtml = existing.originalHtml || '';
        
        if (notesHtml && originalHtml) {
          existing.notesHtml = `<div class="concept-notes-user">${notesHtml}</div><hr class="concept-notes-divider">${originalHtml}`;
        } else if (notesHtml) {
          existing.notesHtml = `<div class="concept-notes-user">${notesHtml}</div>`;
        } else {
          existing.notesHtml = originalHtml;
        }
      }
      
      (window as any).conceptData = conceptData;
      
      // Re-render window body
      renderWindowBody(bodyEl, existing.notesHtml, isCustomConcept);
      
    } catch (err) {
      console.error('Failed to save concept notes:', err);
      alert('Failed to save notes.');
      if (saveBtn) {
        saveBtn.disabled = false;
        saveBtn.textContent = 'Save';
      }
    }
  }
  
  // Render window body content
  function renderWindowBody(bodyEl: Element, notesHtml: string, isCustomConcept: boolean = false) {
    if (notesHtml) {
      bodyEl.innerHTML = `<div class="concept-window-notes">${notesHtml}</div>`;
    } else if (isCustomConcept) {
      bodyEl.innerHTML = `
        <div class="concept-window-placeholder">
          üìù No notes yet.<br>
          <span class="placeholder-hint">Click the <strong>‚úèÔ∏è edit button</strong> in the titlebar to add content.</span>
        </div>
      `;
    } else {
      bodyEl.innerHTML = `
        <div class="concept-window-placeholder">
          üìù Notes not yet uploaded for this concept.
        </div>
      `;
    }
  }

  // Load user notes and render window content
  async function renderWindowContent(bodyEl: Element, topicId: string, conceptName: string, originalHtml: string) {
    const trackSlug = (window as any).trackSlug || 'unknown';
    const noteKey = `${trackSlug}/${topicId}/${conceptName}`;
    
    // Load conceptNotes if not already loaded
    if (!(window as any).conceptNotes) {
      try {
        const { loadCustomContent } = await import('../lib/sync');
        const content = await loadCustomContent();
        (window as any).conceptNotes = content.conceptNotes || {};
      } catch {
        (window as any).conceptNotes = {};
      }
    }
    
    const conceptNotes = (window as any).conceptNotes || {};
    const userMarkdown = conceptNotes[noteKey] || '';
    
    if (userMarkdown) {
      await renderWindowBodyWithUserNotes(bodyEl, originalHtml, userMarkdown);
    } else if (originalHtml) {
      bodyEl.innerHTML = `<div class="concept-window-notes">${originalHtml}</div>`;
    } else {
      const isCustomTrack = (window as any).isCustomTrack || false;
      const conceptData = (window as any).conceptData || {};
      const concept = conceptData[topicId]?.[conceptName] || {};
      const isCustomConcept = isCustomTrack || concept.isCustom || false;
      
      if (isCustomConcept) {
        bodyEl.innerHTML = `
          <div class="concept-window-placeholder">
            üìù No notes yet.<br>
            <span class="placeholder-hint">Click the <strong>‚úèÔ∏è edit button</strong> in the titlebar to add content.</span>
          </div>
        `;
      } else {
        bodyEl.innerHTML = `
          <div class="concept-window-placeholder">
            üìù Notes not yet uploaded for this concept.
          </div>
        `;
      }
    }
  }

  // Render window body with parsed user notes
  async function renderWindowBodyWithUserNotes(bodyEl: Element, originalHtml: string, userMarkdown: string) {
    // Show loading state briefly
    bodyEl.innerHTML = `<div class="concept-window-notes">Loading...</div>`;
    
    try {
      const { parseNotesClient } = await import('../utils/parseNotesClient');
      const userHtml = parseNotesClient(userMarkdown);
      
      if (originalHtml) {
        // User notes on TOP, original below
        bodyEl.innerHTML = `<div class="concept-window-notes"><div class="concept-notes-user">${userHtml}</div><hr class="concept-notes-divider">${originalHtml}</div>`;
      } else {
        bodyEl.innerHTML = `<div class="concept-window-notes"><div class="concept-notes-user">${userHtml}</div></div>`;
      }
    } catch (err) {
      console.error('Failed to parse user notes:', err);
      if (originalHtml) {
        bodyEl.innerHTML = `<div class="concept-window-notes">${originalHtml}</div>`;
      }
    }
  }

  // Expose global API
  (window as any).conceptModal = {
    open: openWindow,
    close: closeWindow,
    minimize: minimizeWindow,
    restore: restoreWindow,
    toggleMaximize,
    bringToFront
  };

  initResizeHandler();
  restoreOpenWindows();
  initTaskbarActions();

  // ============================================
  // PDF RESIZER LOGIC
  // ============================================
  const PDF_HEIGHT_STORAGE_KEY = 'eee-pdf-heights';

  function loadPdfHeights(): Record<string, number> {
    try {
      const saved = localStorage.getItem(PDF_HEIGHT_STORAGE_KEY);
      return saved ? JSON.parse(saved) : {};
    } catch {
      return {};
    }
  }

  function savePdfHeight(pdfSrc: string, heightPercent: number) {
    try {
      const heights = loadPdfHeights();
      // Store as percentage (0-100+)
      heights[pdfSrc] = heightPercent;
      localStorage.setItem(PDF_HEIGHT_STORAGE_KEY, JSON.stringify(heights));
    } catch {}
  }

  function getWindowContentHeight(embed: HTMLElement): number {
    const content = embed.closest('.concept-window-content') as HTMLElement;
    return content?.clientHeight || window.innerHeight;
  }

  function initPdfResizers() {
    document.addEventListener('mousedown', (e) => {
      const target = e.target as HTMLElement;
      if (!target.classList.contains('notes-pdf-resizer')) return;

      e.preventDefault();
      const resizer = target;
      const embed = resizer.closest('.notes-pdf-embed') as HTMLElement;
      const iframe = embed?.querySelector('.notes-pdf-iframe') as HTMLElement;
      if (!embed || !iframe) return;

      // CRITICAL: Disable iframe pointer events during drag
      document.body.classList.add('pdf-resizing');
      resizer.classList.add('resizing');
      
      const startY = e.clientY;
      const startHeight = iframe.offsetHeight;

      const onMouseMove = (e: MouseEvent) => {
        const delta = e.clientY - startY;
        const newHeight = Math.max(200, startHeight + delta);
        iframe.style.height = `${newHeight}px`;
        
        // Auto-scroll the content area to follow the resize
        const content = embed.closest('.concept-window-content') as HTMLElement;
        if (content) {
          const resizerRect = resizer.getBoundingClientRect();
          const contentRect = content.getBoundingClientRect();
          // If resizer is near or below the visible area, scroll to keep it visible
          if (resizerRect.bottom > contentRect.bottom - 20) {
            content.scrollTop += delta;
          }
        }
      };

      const onMouseUp = () => {
        document.body.classList.remove('pdf-resizing');
        resizer.classList.remove('resizing');
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);

        // Save height as percentage of content area
        const src = iframe.getAttribute('src') || '';
        const match = src.match(/file=([^&]+)/);
        if (match) {
          const pdfPath = decodeURIComponent(match[1]);
          const contentHeight = getWindowContentHeight(embed);
          const heightPercent = (iframe.offsetHeight / contentHeight) * 100;
          savePdfHeight(pdfPath, heightPercent);
        }
      };

      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });

    // Touch support
    document.addEventListener('touchstart', (e) => {
      const target = e.target as HTMLElement;
      if (!target.classList.contains('notes-pdf-resizer')) return;

      const resizer = target;
      const embed = resizer.closest('.notes-pdf-embed') as HTMLElement;
      const iframe = embed?.querySelector('.notes-pdf-iframe') as HTMLElement;
      if (!embed || !iframe) return;

      document.body.classList.add('pdf-resizing');
      resizer.classList.add('resizing');
      
      const startY = e.touches[0].clientY;
      const startHeight = iframe.offsetHeight;

      const onTouchMove = (e: TouchEvent) => {
        const delta = e.touches[0].clientY - startY;
        const newHeight = Math.max(200, startHeight + delta);
        iframe.style.height = `${newHeight}px`;
      };

      const onTouchEnd = () => {
        document.body.classList.remove('pdf-resizing');
        resizer.classList.remove('resizing');
        document.removeEventListener('touchmove', onTouchMove);
        document.removeEventListener('touchend', onTouchEnd);

        const src = iframe.getAttribute('src') || '';
        const match = src.match(/file=([^&]+)/);
        if (match) {
          const pdfPath = decodeURIComponent(match[1]);
          const contentHeight = getWindowContentHeight(embed);
          const heightPercent = (iframe.offsetHeight / contentHeight) * 100;
          savePdfHeight(pdfPath, heightPercent);
        }
      };

      document.addEventListener('touchmove', onTouchMove, { passive: true });
      document.addEventListener('touchend', onTouchEnd);
    }, { passive: true });
  }

  function applyStoredPdfHeights(container: HTMLElement) {
    const heights = loadPdfHeights();
    const iframes = container.querySelectorAll('.notes-pdf-iframe') as NodeListOf<HTMLElement>;
    const content = container.closest('.concept-window-content') as HTMLElement || container;
    const contentHeight = content.clientHeight || 400;
    
    iframes.forEach((iframe) => {
      const src = iframe.getAttribute('src') || '';
      const match = src.match(/file=([^&]+)/);
      if (match) {
        const pdfPath = decodeURIComponent(match[1]);
        if (heights[pdfPath]) {
          // Convert percentage back to pixels, with min/max constraints
          const heightPx = Math.max(200, Math.min((heights[pdfPath] / 100) * contentHeight, contentHeight - 50));
          iframe.style.height = `${heightPx}px`;
        }
      }
    });
  }

  // Initialize on load
  initPdfResizers();
</script>