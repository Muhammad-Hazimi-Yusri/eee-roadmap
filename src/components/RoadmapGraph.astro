---
/**
 * Interactive graph visualization of roadmap topics and prerequisites.
 * Uses Cytoscape.js with dagre layout.
 * Mobile: tap to open fullscreen modal.
 */
import { getTrackColorMap } from '../utils/trackColors';
import graphData from '../data/graph-data.json';

const trackSlugs = graphData.tracks.map((t: { slug: string }) => t.slug);
const colorMap = getTrackColorMap(trackSlugs);

// Pass data to client
const clientData = {
  nodes: graphData.nodes,
  edges: graphData.edges,
  tracks: graphData.tracks,
  colors: colorMap,
};
---

<!-- Track filters -->
<div class="graph-filters" id="graph-filters">
  <button class="graph-filter-pill graph-filter-pill--all is-active" data-track="all">
    All
  </button>
  {graphData.tracks.map((track: { slug: string; title: string }) => (
    <button 
      class="graph-filter-pill is-active" 
      data-track={track.slug}
      style={`--pill-color: ${colorMap[track.slug]}`}
    >
      <span class="graph-filter-dot"></span>
      {track.title}
    </button>
  ))}
</div>

<!-- Desktop: inline graph -->
<div class="graph-wrapper">
  <div class="graph-container" id="roadmap-graph">
    <div class="graph-loading">Loading graph...</div>
  </div>
  
  <!-- Legend -->
  <div class="graph-legend">
    <div class="graph-legend-item">
      <span class="graph-legend-node graph-legend-node--default"></span>
      <span>Topic</span>
    </div>
    <div class="graph-legend-item">
      <span class="graph-legend-node graph-legend-node--complete"></span>
      <span>Completed</span>
    </div>
    <div class="graph-legend-item">
      <span class="graph-legend-node graph-legend-node--important"></span>
      <span>Important</span>
    </div>
  </div>
  
  <!-- Mobile tap hint -->
  <button class="graph-mobile-hint" id="graph-expand-btn" aria-label="Expand graph fullscreen">
    <span>Tap to explore</span>
  </button>
  
  <!-- Desktop fullscreen button -->
  <button class="graph-fullscreen-btn" id="graph-fullscreen-btn" aria-label="View fullscreen">
    ⛶
  </button>
</div>

<!-- Fullscreen modal -->
<div class="graph-modal" id="graph-modal" hidden>
  <div class="graph-modal-header">
    <span class="graph-modal-title">Topic Connections</span>
    <button class="graph-modal-close" id="graph-modal-close" aria-label="Close">✕</button>
  </div>
  <div class="graph-modal-container" id="roadmap-graph-modal"></div>
  <div class="graph-modal-hint">Pinch to zoom • Drag to pan • Tap topic to navigate</div>
</div>

<script define:vars={{ clientData }}>
  window.__graphData = clientData;
</script>

<script>
  import cytoscape from 'cytoscape';
  import dagre from 'cytoscape-dagre';

  cytoscape.use(dagre);

  function getGraphStyle(isDark: boolean) {
    return [
      {
        selector: 'node[type="track"]',
        style: {
          'background-color': 'data(color)',
          'background-opacity': isDark ? 0.25 : 0.15,
          'border-width': 2,
          'border-color': 'data(color)',
          'label': 'data(label)',
          'font-size': '14px',
          'font-weight': 'bold',
          'text-valign': 'top',
          'text-halign': 'center',
          'text-margin-y': -8,
          'padding': '25px',
          'color': isDark ? '#ffffff' : '#1e293b',
          'text-background-color': isDark ? '#000000' : 'transparent',
          'text-background-opacity': isDark ? 0.7 : 0,
          'text-background-padding': '6px',
        },
      },
      {
        selector: 'node[type="topic"]',
        style: {
          'background-color': 'data(color)',
          'label': 'data(label)',
          'font-size': '9px',
          'text-valign': 'bottom',
          'text-halign': 'center',
          'text-margin-y': 5,
          'width': 22,
          'height': 22,
          'text-wrap': 'ellipsis',
          'text-max-width': '70px',
          'color': isDark ? '#e2e8f0' : '#1f2937',
          'text-background-color': isDark ? '#1e293b' : '#ffffff',
          'text-background-opacity': 0.85,
          'text-background-padding': '2px',
        },
      },
      // Completed: inner ring style
      {
        selector: 'node[type="topic"][allComplete]',
        style: {
          'background-color': isDark ? '#0f172a' : '#ffffff',
          'border-width': 4,
          'border-color': 'data(color)',
        },
      },
      // Important: glow effect using underlay
      {
        selector: 'node[type="topic"][hasImportant]',
        style: {
          'border-width': 3,
          'border-color': isDark ? '#facc15' : '#eab308',
          'underlay-color': isDark ? '#facc15' : '#eab308',
          'underlay-padding': 6,
          'underlay-opacity': 0.4,
        },
      },
      // Both completed and important
      {
        selector: 'node[type="topic"][allComplete][hasImportant]',
        style: {
          'background-color': isDark ? '#1e293b' : '#ffffff',
          'border-width': 4,
          'border-color': isDark ? '#facc15' : '#eab308',
          'underlay-color': isDark ? '#facc15' : '#eab308',
          'underlay-padding': 6,
          'underlay-opacity': 0.4,
        },
      },{
        selector: 'node[type="topic"]',
        style: {
          'background-color': 'data(color)',
          'label': 'data(label)',
          'font-size': '9px',
          'text-valign': 'bottom',
          'text-halign': 'center',
          'text-margin-y': 5,
          'width': 22,
          'height': 22,
          'text-wrap': 'ellipsis',
          'text-max-width': '70px',
          'color': isDark ? '#e2e8f0' : '#1f2937',
          'text-background-color': isDark ? '#1e293b' : '#ffffff',
          'text-background-opacity': 0.85,
          'text-background-padding': '2px',
        },
      },
      // Completed: inner ring style
      {
        selector: 'node[type="topic"][allComplete]',
        style: {
          'background-color': isDark ? '#0f172a' : '#ffffff',
          'border-width': 4,
          'border-color': 'data(color)',
        },
      },
      // Important: glow effect
      {
        selector: 'node[type="topic"][hasImportant]',
        style: {
          'border-width': 3,
          'border-color': isDark ? '#fbbf24' : '#f59e0b',
          'border-style': 'solid',
          'shadow-blur': 8,
          'shadow-color': isDark ? '#fbbf24' : '#f59e0b',
          'shadow-opacity': 0.6,
          'shadow-offset-x': 0,
          'shadow-offset-y': 0,
        },
      },
      // Both completed and important
      {
        selector: 'node[type="topic"][allComplete][hasImportant]',
        style: {
          'background-color': isDark ? '#0f172a' : '#ffffff',
          'border-width': 4,
          'border-color': isDark ? '#fbbf24' : '#f59e0b',
          'shadow-blur': 8,
          'shadow-color': isDark ? '#fbbf24' : '#f59e0b',
          'shadow-opacity': 0.6,
          'shadow-offset-x': 0,
          'shadow-offset-y': 0,
        },
      },
      {
        selector: 'edge',
        style: {
          'width': 1.2,
          'line-color': isDark ? '#64748b' : '#94a3b8',
          'target-arrow-color': isDark ? '#94a3b8' : '#64748b',
          'target-arrow-shape': 'triangle',
          'curve-style': 'bezier',
          'arrow-scale': 0.7,
        },
      },
    ];
  }

  function getProgress(): { complete: string[]; important: string[] } {
    try {
      const saved = localStorage.getItem('eee-progress-v2');
      return saved ? JSON.parse(saved) : { complete: [], important: [] };
    } catch {
      return { complete: [], important: [] };
    }
  }

  function getNodeStatus(conceptKeys: string[], progress: { complete: string[]; important: string[] }) {
    const hasComplete = conceptKeys.some(k => progress.complete.includes(k));
    const allComplete = conceptKeys.length > 0 && conceptKeys.every(k => progress.complete.includes(k));
    const hasImportant = conceptKeys.some(k => progress.important.includes(k));
    return { hasComplete, allComplete, hasImportant };
  }

  function buildElements(data: any) {
    const elements: any[] = [];
    const progress = getProgress();

    for (const track of data.tracks) {
      elements.push({
        data: {
          id: `track:${track.slug}`,
          label: track.title,
          type: 'track',
          color: data.colors[track.slug],
        },
      });
    }

    for (const node of data.nodes) {
      const conceptKeys = node.conceptKeys || [];
      const status = getNodeStatus(conceptKeys, progress);
      
      const nodeData: any = {
        id: node.id,
        label: node.label,
        parent: `track:${node.track}`,
        type: 'topic',
        track: node.track,
        color: data.colors[node.track],
      };

      // Only add status properties if true (so selectors work correctly)
      if (status.allComplete) nodeData.allComplete = true;
      if (status.hasImportant) nodeData.hasImportant = true;

      elements.push({ data: nodeData });
    }

    for (const edge of data.edges) {
      elements.push({
        data: {
          source: edge.source,
          target: edge.target,
        },
      });
    }

    return elements;
  }

  function createGraph(container: HTMLElement, data: any) {
    const isDark = document.documentElement.classList.contains('dark');
    const cy = cytoscape({
      container,
      elements: buildElements(data),
      style: getGraphStyle(isDark) as any,
      layout: {
        name: 'dagre',
        rankDir: 'TB',
        nodeSep: 40,
        rankSep: 55,
        padding: 25,
      } as any,
      userZoomingEnabled: true,
      userPanningEnabled: true,
      boxSelectionEnabled: false,
    });

    // Click to navigate
    cy.on('tap', 'node[type="topic"]', (evt) => {
      const node = evt.target;
      const id = node.id();
      const [track, topicId] = id.split('/');
      window.location.href = `/roadmaps/${track}/#${topicId}`;
    });

    // Store reference for filters
    (container as any)._cy = cy;

    return cy;
  }

  function initGraph() {
    const container = document.getElementById('roadmap-graph');
    const data = (window as any).__graphData;
    if (!container || !data) return;

    container.innerHTML = '';
    createGraph(container, data);
  }

  function initModal() {
    const expandBtn = document.getElementById('graph-expand-btn');
    const fullscreenBtn = document.getElementById('graph-fullscreen-btn');
    const modal = document.getElementById('graph-modal') as HTMLElement | null;
    const modalContainer = document.getElementById('roadmap-graph-modal') as HTMLElement | null;
    const closeBtn = document.getElementById('graph-modal-close');
    const data = (window as any).__graphData;

    if (!modal || !modalContainer || !closeBtn || !data) return;

    let modalCy: any = null;

    function openModal() {
      modal!.hidden = false;
      document.body.style.overflow = 'hidden';

      if (!modalCy) {
        modalCy = createGraph(modalContainer!, data);
      } else {
        modalCy.resize();
        modalCy.fit();
      }
    }

    expandBtn?.addEventListener('click', openModal);
    fullscreenBtn?.addEventListener('click', openModal);

    closeBtn.addEventListener('click', () => {
      modal.hidden = true;
      document.body.style.overflow = '';
    });

    // Close on escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && !modal.hidden) {
        modal.hidden = true;
        document.body.style.overflow = '';
      }
    });
  }

  function initFilters() {
    const filterContainer = document.getElementById('graph-filters');
    const graphContainer = document.getElementById('roadmap-graph');
    const data = (window as any).__graphData;
    
    if (!filterContainer || !graphContainer || !data) return;

    const STORAGE_KEY = 'eee-graph-filters';
    const allPill = filterContainer.querySelector('[data-track="all"]');
    const trackPills = filterContainer.querySelectorAll('[data-track]:not([data-track="all"])');
    
    // Load saved state
    function loadFilterState(): Set<string> {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (saved) {
          return new Set(JSON.parse(saved));
        }
      } catch {}
      // Default: all tracks visible
      return new Set(data.tracks.map((t: any) => t.slug));
    }

    // Save state
    function saveFilterState(visible: Set<string>) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify([...visible]));
    }

    let visibleTracks = loadFilterState();

    // Get cytoscape instance from container
    function getCy() {
      return (graphContainer as any)._cy;
    }

    // Update graph visibility
    function updateGraph() {
      const cy = getCy();
      if (!cy) return;

      cy.batch(() => {
        cy.nodes().forEach((node: any) => {
          const nodeTrack = node.data('track');
          if (node.data('type') === 'track') {
            // Track parent node
            const slug = node.id().replace('track:', '');
            if (visibleTracks.has(slug)) {
              node.style('display', 'element');
            } else {
              node.style('display', 'none');
            }
          } else if (nodeTrack) {
            // Topic node
            if (visibleTracks.has(nodeTrack)) {
              node.style('display', 'element');
            } else {
              node.style('display', 'none');
            }
          }
        });

        // Hide edges where source or target is hidden
        cy.edges().forEach((edge: any) => {
          const sourceVisible = edge.source().style('display') !== 'none';
          const targetVisible = edge.target().style('display') !== 'none';
          if (sourceVisible && targetVisible) {
            edge.style('display', 'element');
          } else {
            edge.style('display', 'none');
          }
        });
      });

      // Animate layout
      cy.layout({
        name: 'dagre',
        rankDir: 'TB',
        nodeSep: 40,
        rankSep: 55,
        padding: 25,
        animate: true,
        animationDuration: 300,
      } as any).run();
    }

    // Update pill states
    function updatePills() {
      const allVisible = visibleTracks.size === data.tracks.length;

      allPill?.classList.toggle('is-active', allVisible);

      trackPills.forEach(pill => {
        const track = pill.getAttribute('data-track');
        if (track) {
          pill.classList.toggle('is-active', visibleTracks.has(track));
        }
      });
    }

    // Handle "All" click
    allPill?.addEventListener('click', () => {
      const allVisible = visibleTracks.size === data.tracks.length;
      
      if (allVisible) {
        // Don't allow hiding all - keep at least one
        return;
      } else {
        // Show all
        visibleTracks = new Set(data.tracks.map((t: any) => t.slug));
      }
      
      saveFilterState(visibleTracks);
      updatePills();
      updateGraph();
    });

    // Handle track pill clicks
    trackPills.forEach(pill => {
      pill.addEventListener('click', () => {
        const track = pill.getAttribute('data-track');
        if (!track) return;

        if (visibleTracks.has(track)) {
          // Don't allow hiding if it's the last one
          if (visibleTracks.size === 1) return;
          visibleTracks.delete(track);
        } else {
          visibleTracks.add(track);
        }

        saveFilterState(visibleTracks);
        updatePills();
        updateGraph();
      });
    });

    // Apply initial state
    updatePills();
    
    // Wait for graph to init then apply filter
    setTimeout(() => {
      if (visibleTracks.size < data.tracks.length) {
        updateGraph();
      }
    }, 100);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initGraph();
      initModal();
      initFilters();
    });
  } else {
    initGraph();
    initModal();
    initFilters();
  }
</script>

<style>
  .graph-wrapper {
    position: relative;
  }

  .graph-container {
    width: 100%;
    height: 400px;
    border: 1px solid var(--color-border);
    background: var(--color-bg);
    position: relative;
  }

  .graph-loading {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.875rem;
    color: var(--color-text-muted);
  }

  /* Mobile hint overlay */
  .graph-mobile-hint {
    display: none;
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.3);
    border: none;
    cursor: pointer;
    align-items: center;
    justify-content: center;
  }

  .graph-mobile-hint span {
    background: var(--color-bg);
    padding: 0.75rem 1.5rem;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.875rem;
    border: 2px solid var(--color-text);
  }

  @media (max-width: 768px) {
    .graph-container {
      height: 250px;
    }

    .graph-mobile-hint {
      display: flex;
    }
  }

  /* Fullscreen modal */
  .graph-modal {
    position: fixed;
    inset: 0;
    z-index: 9999;
    background: var(--color-bg);
    display: flex;
    flex-direction: column;
  }

  .graph-modal[hidden] {
    display: none;
  }

  .graph-modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 1rem;
    border-bottom: 1px solid var(--color-border);
  }

  .graph-modal-title {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.875rem;
    font-weight: 600;
  }

  .graph-modal-close {
    background: none;
    border: 2px solid var(--color-text);
    width: 2.5rem;
    height: 2.5rem;
    font-size: 1.25rem;
    cursor: pointer;
    color: var(--color-text);
  }

  .graph-modal-close:hover {
    background: var(--color-text);
    color: var(--color-bg);
  }

  .graph-modal-container {
    flex: 1;
    min-height: 0;
  }

  .graph-modal-hint {
    padding: 0.75rem;
    text-align: center;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    border-top: 1px solid var(--color-border);
  }

  /* Desktop fullscreen button */
  .graph-fullscreen-btn {
    position: absolute;
    top: 0.5rem;
    right: 0.5rem;
    width: 2rem;
    height: 2rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    cursor: pointer;
    font-size: 1rem;
    color: var(--color-text-muted);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0.7;
    transition: opacity 0.15s;
  }

  .graph-fullscreen-btn:hover {
    opacity: 1;
    border-color: var(--color-text);
    color: var(--color-text);
  }

  @media (max-width: 768px) {
    .graph-fullscreen-btn {
      display: none;
    }
  }

  /* Legend */
  .graph-legend {
    display: flex;
    gap: 1rem;
    justify-content: center;
    padding: 0.75rem;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    border: 1px solid var(--color-border);
    border-top: none;
    background: var(--color-bg);
  }

  .graph-legend-item {
    display: flex;
    align-items: center;
    gap: 0.375rem;
  }

  .graph-legend-node {
    width: 14px;
    height: 14px;
    border-radius: 50%;
  }

  .graph-legend-node--default {
    background: var(--color-copper);
  }

  .graph-legend-node--complete {
    background: var(--color-bg);
    border: 3px solid var(--color-copper);
  }

  .graph-legend-node--important {
    background: var(--color-copper);
    border: 2px solid #f59e0b;
    box-shadow: 0 0 6px #f59e0b;
  }

  @media (max-width: 768px) {
    .graph-legend {
      gap: 0.75rem;
      font-size: 0.625rem;
    }
    
    .graph-legend-node {
      width: 12px;
      height: 12px;
    }
}

  /* Track filters */
  .graph-filters {
    display: flex;
    gap: 0.5rem;
    padding: 0.75rem 0;
    overflow-x: auto;
    scrollbar-width: thin;
    scrollbar-color: var(--color-border) transparent;
    -webkit-overflow-scrolling: touch;
    mask-image: linear-gradient(to right, transparent, black 1rem, black calc(100% - 1rem), transparent);
    -webkit-mask-image: linear-gradient(to right, transparent, black 1rem, black calc(100% - 1rem), transparent);
  }

  .graph-filters::-webkit-scrollbar {
    height: 4px;
  }

  .graph-filters::-webkit-scrollbar-track {
    background: transparent;
  }

  .graph-filters::-webkit-scrollbar-thumb {
    background: var(--color-border);
    border-radius: 2px;
  }

  .graph-filter-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.375rem 0.75rem;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    white-space: nowrap;
    border: 1px solid var(--color-border);
    background: var(--color-bg);
    color: var(--color-text-muted);
    cursor: pointer;
    transition: all 0.15s ease;
    flex-shrink: 0;
  }

  .graph-filter-pill:hover {
    border-color: var(--color-text);
  }

  .graph-filter-pill.is-active {
    border-color: var(--pill-color, var(--color-text));
    color: var(--color-text);
  }

  .graph-filter-pill--all {
    --pill-color: var(--color-text);
    font-weight: 600;
  }

  .graph-filter-pill--all.is-active {
    background: var(--color-text);
    color: var(--color-bg);
  }

  .graph-filter-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--pill-color);
    opacity: 0.4;
    transition: opacity 0.15s;
  }

  .graph-filter-pill.is-active .graph-filter-dot {
    opacity: 1;
  }
</style>