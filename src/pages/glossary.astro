---
import Layout from '../layouts/Layout.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { internalHref } from '../utils/url';
import { Marked } from 'marked';
import markedKatex from 'marked-katex-extension';

// Import glossary data (generated by build script)
import glossaryData from '../data/_glossary.json';

// Setup marked with KaTeX
const marked = new Marked();
marked.use(markedKatex({ throwOnError: false }));

// Parse definitions
const { terms: rawTerms } = glossaryData;
const terms = rawTerms.map(term => ({
  ...term,
  definition: marked.parse(term.definition || '') as string
}));

// Group terms by first letter
const grouped: Record<string, typeof terms> = {};
const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');

for (const term of terms) {
  const firstLetter = term.term.charAt(0).toUpperCase();
  if (!grouped[firstLetter]) {
    grouped[firstLetter] = [];
  }
  grouped[firstLetter].push(term);
}

// Sort terms within each group
for (const letter of Object.keys(grouped)) {
  grouped[letter].sort((a, b) => a.term.localeCompare(b.term));
}

// Count for stats
const termCount = terms.length;
---

<Layout title="Glossary">
  <Header />
  <main class="glossary-page">
    <div class="container py-12">
      <h1 class="text-2xl font-bold mb-2">Glossary</h1>
      <p class="text-muted mb-6">
        {termCount} terms and acronyms across all tracks.
      </p>

      <!-- Search filter -->
      <div class="glossary-search-wrapper mb-6">
        <svg class="glossary-search-icon" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"/>
          <path d="m21 21-4.35-4.35"/>
        </svg>
        <input 
          type="text" 
          id="glossary-filter" 
          class="glossary-search-input" 
          placeholder="Filter terms..."
          autocomplete="off"
        />
        <span id="glossary-count" class="glossary-count">{termCount} terms</span>
      </div>

      <!-- A-Z Navigation -->
      <nav class="glossary-nav mb-8" aria-label="Alphabetical navigation">
        {alphabet.map(letter => (
          <a 
            href={grouped[letter] ? `#letter-${letter}` : undefined}
            class:list={[
              'glossary-nav-letter',
              { 'glossary-nav-letter--disabled': !grouped[letter] }
            ]}
            aria-disabled={!grouped[letter]}
          >
            {letter}
          </a>
        ))}
      </nav>

      <!-- Terms list -->
      <div class="glossary-content" id="glossary-content">
        {alphabet.filter(letter => grouped[letter]).map(letter => (
          <section class="glossary-section" id={`letter-${letter}`} data-letter={letter}>
            <h2 class="glossary-letter-heading">{letter}</h2>
            <div class="glossary-terms">
              {grouped[letter].map(entry => (
                <article 
                  class="glossary-term" 
                  id={entry.id}
                  data-term={entry.term.toLowerCase()}
                  data-acronyms={(entry.acronyms || []).join(' ').toLowerCase()}
                >
                  <header class="glossary-term-header">
                    <h3 class="glossary-term-name">{entry.term}</h3>
                    {entry.acronyms?.length > 0 && (
                      <span class="glossary-term-acronyms">
                        {entry.acronyms.join(', ')}
                      </span>
                    )}
                  </header>
                  
                  <div class="glossary-term-definition" set:html={entry.definition} />
                  
                  {entry.categories?.length > 0 && (
                    <div class="glossary-term-categories">
                      {entry.categories.map(cat => (
                        <span class="glossary-category-tag">{cat}</span>
                      ))}
                    </div>
                  )}
                  
                  {entry.see_also?.length > 0 && (
                    <div class="glossary-term-see-also">
                      <span class="see-also-label">See also:</span>
                      {entry.see_also.map((ref, i) => {
                        const refTerm = terms.find(t => 
                          t.term === ref || 
                          t.acronyms?.includes(ref)
                        );
                        return (
                          <>
                            {refTerm ? (
                              <a href={`#${refTerm.id}`} class="see-also-link">{ref}</a>
                            ) : (
                              <span class="see-also-text">{ref}</span>
                            )}
                            {i < entry.see_also.length - 1 && ', '}
                          </>
                        );
                      })}
                    </div>
                  )}
                  
                  {entry.appears_in?.length > 0 && (
                    <details class="glossary-appears-in">
                      <summary class="appears-in-summary">
                        Appears in {entry.appears_in.length} topic{entry.appears_in.length > 1 ? 's' : ''}
                      </summary>
                      <ul class="appears-in-list">
                        {entry.appears_in.map((ref, i) => (
                          <li hidden={i >= 10}>
                            <a href={internalHref(`roadmaps/${ref.track}#${ref.topicId}`)}>
                              {ref.trackTitle} → {ref.topicTitle}
                            </a>
                          </li>
                        ))}
                        {entry.appears_in.length > 10 && (
                          <li>
                              <button class="appears-in-show-all" data-term-id={entry.id}>
                              Show all {entry.appears_in.length} →
                              </button>
                          </li>
                        )}
                      </ul>
                    </details>
                  )}
                </article>
              ))}
            </div>
          </section>
        ))}
      </div>

      <!-- No results message -->
      <div id="glossary-no-results" class="glossary-no-results" hidden>
        No terms match your search.
      </div>
    </div>
  </main>
  <Footer />
</Layout>

<script>
  const filterInput = document.getElementById('glossary-filter') as HTMLInputElement;
  const countDisplay = document.getElementById('glossary-count')!;
  const noResults = document.getElementById('glossary-no-results')!;
  const terms = document.querySelectorAll('.glossary-term');
  const sections = document.querySelectorAll('.glossary-section');

  function filterTerms() {
    const query = filterInput.value.toLowerCase().trim();
    let visibleCount = 0;

    terms.forEach(term => {
      const termName = term.getAttribute('data-term') || '';
      const acronyms = term.getAttribute('data-acronyms') || '';
      const matches = query === '' || 
        termName.includes(query) || 
        acronyms.includes(query);
      
      (term as HTMLElement).hidden = !matches;
      if (matches) visibleCount++;
    });

    // Hide empty sections
    sections.forEach(section => {
      const visibleTerms = section.querySelectorAll('.glossary-term:not([hidden])');
      (section as HTMLElement).hidden = visibleTerms.length === 0;
    });

    // Update count
    countDisplay.textContent = `${visibleCount} term${visibleCount !== 1 ? 's' : ''}`;
    
    // Show/hide no results message
    noResults.hidden = visibleCount > 0;
  }

  filterInput.addEventListener('input', filterTerms);

  // Handle hash navigation on load
  if (window.location.hash) {
    const targetId = window.location.hash.slice(1);
    const target = document.getElementById(targetId);
    if (target) {
      setTimeout(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'start' });
        target.classList.add('glossary-term--highlighted');
        setTimeout(() => {
          target.classList.remove('glossary-term--highlighted');
        }, 2000);
      }, 100);
    }
  }

  // Show all appears-in links
    document.querySelectorAll('.appears-in-show-all').forEach(btn => {
    btn.addEventListener('click', () => {
        const list = btn.closest('.appears-in-list');
        const hiddenItems = list?.querySelectorAll('li[hidden]');
        hiddenItems?.forEach(li => (li as HTMLElement).hidden = false);
        (btn.parentElement as HTMLElement).hidden = true;
    });
    });
</script>

<style>
  .glossary-page {
    min-height: 100vh;
  }

  /* Search */
  .glossary-search-wrapper {
    position: relative;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    max-width: 400px;
  }

  .glossary-search-icon {
    position: absolute;
    left: 0.75rem;
    color: var(--color-muted);
    pointer-events: none;
  }

  .glossary-search-input {
    flex: 1;
    padding: 0.625rem 0.75rem 0.625rem 2.5rem;
    font-size: 0.9375rem;
    font-family: inherit;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: 4px;
    color: var(--color-text);
  }

  .glossary-search-input:focus {
    outline: none;
    border-color: var(--color-copper);
  }

  .glossary-count {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.75rem;
    color: var(--color-muted);
    white-space: nowrap;
  }

  /* A-Z Navigation */
  .glossary-nav {
    display: flex;
    flex-wrap: wrap;
    gap: 0.25rem;
    padding: 0.75rem;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
  }

  .glossary-nav-letter {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 2rem;
    height: 2rem;
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.875rem;
    font-weight: 600;
    text-decoration: none;
    color: var(--color-text);
    border: 1px solid transparent;
    transition: all 0.15s;
  }

  .glossary-nav-letter:hover:not(.glossary-nav-letter--disabled) {
    background: var(--color-copper);
    color: #111;
  }

  .glossary-nav-letter--disabled {
    color: var(--color-muted);
    opacity: 0.4;
    cursor: default;
  }

  /* Sections */
  .glossary-section {
    margin-bottom: 2rem;
  }

  .glossary-letter-heading {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--color-copper);
    padding-bottom: 0.5rem;
    border-bottom: 2px solid var(--color-border);
    margin-bottom: 1rem;
  }

  .glossary-terms {
    display: grid;
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  @media (min-width: 900px) {
    .glossary-terms {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  /* Individual term */
  .glossary-term {
    padding: 1rem;
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-left: 3px solid var(--color-copper);
    transition: border-color 0.3s, box-shadow 0.3s;
  }

  .glossary-term[hidden] {
    display: none;
  }

  .glossary-term--highlighted {
    border-color: var(--color-copper);
    box-shadow: 0 0 0 2px var(--color-copper);
  }

  .glossary-term-header {
    display: flex;
    flex-wrap: wrap;
    align-items: baseline;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .glossary-term-name {
    font-size: 1.0625rem;
    font-weight: 600;
    margin: 0;
  }

  .glossary-term-acronyms {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.8125rem;
    color: var(--color-copper);
  }

  .glossary-term-definition {
    font-size: 0.9375rem;
    line-height: 1.6;
    color: var(--color-text);
  }

  .glossary-term-definition :global(p) {
    margin: 0.5rem 0;
  }

  .glossary-term-definition :global(p:first-child) {
    margin-top: 0;
  }

  .glossary-term-definition :global(code) {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.875em;
    background: var(--color-bg);
    padding: 0.125rem 0.25rem;
    border-radius: 2px;
  }

  /* Categories */
  .glossary-term-categories {
    display: flex;
    flex-wrap: wrap;
    gap: 0.375rem;
    margin-top: 0.75rem;
  }

  .glossary-category-tag {
    font-family: 'IBM Plex Mono', monospace;
    font-size: 0.6875rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    padding: 0.125rem 0.5rem;
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    color: var(--color-muted);
  }

  /* See also */
  .glossary-term-see-also {
    margin-top: 0.75rem;
    font-size: 0.875rem;
  }

  .see-also-label {
    color: var(--color-muted);
    margin-right: 0.25rem;
  }

  .see-also-link {
    color: var(--color-copper);
    text-decoration: none;
  }

  .see-also-link:hover {
    text-decoration: underline;
  }

  /* Appears in */
  .glossary-appears-in {
    margin-top: 0.75rem;
    font-size: 0.8125rem;
  }

  .appears-in-summary {
    cursor: pointer;
    color: var(--color-muted);
    font-family: 'IBM Plex Mono', monospace;
  }

  .appears-in-summary:hover {
    color: var(--color-text);
  }

  .appears-in-list {
    margin: 0.5rem 0 0 1rem;
    padding: 0;
    list-style: none;
  }

  .appears-in-list li {
    padding: 0.25rem 0;
  }

  .appears-in-list a {
    color: var(--color-text);
    text-decoration: none;
  }

  .appears-in-list a:hover {
    color: var(--color-copper);
  }

  .appears-in-more {
    color: var(--color-muted);
    font-style: italic;
  }

  /* No results */
  .glossary-no-results {
    padding: 2rem;
    text-align: center;
    color: var(--color-muted);
    font-size: 0.9375rem;
  }

  .glossary-no-results[hidden] {
    display: none;
  }
</style>