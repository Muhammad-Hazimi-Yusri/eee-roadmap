---
import Layout from '../../layouts/Layout.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import { internalHref } from '../../utils/url';
import { getAllTracks, roadmaps } from '../../data';
import * as LucideIcons from '@lucide/astro';
import pkg from '../../../package.json';

const VERSION = pkg.version;  

const allTracks = getAllTracks();

function getIcon(iconName: string) {
  const pascalName = iconName
    .split('-')
    .map(part => part.charAt(0).toUpperCase() + part.slice(1))
    .join('');
  return (LucideIcons as any)[pascalName] || LucideIcons.HelpCircle;
}

const tracksData = allTracks.map(({ slug, meta }) => ({
  slug,
  title: meta.title,
  description: meta.description,
  href: internalHref(`roadmaps/${slug}`),
  sections: (roadmaps[slug]?.sections ?? []).map(section => ({
    id: section.id,
    title: section.title,
    topics: section.items.map(item => ({ id: item.id, title: item.title }))
  }))
}));
---

<Layout title="All Tracks">
  <Header />
  <main class="tracks-page">
    <div class="container py-12">
      <h1 class="text-2xl font-bold mb-2">All Learning Tracks</h1>
      <p class="tracks-instruction text-muted mb-8">
        <span class="instruction-desktop">Click a box to see what's inside</span>
        <span class="instruction-mobile">Double-tap a box to see what's inside</span>
      </p>
      
      <div class="tracks-grid">
        {allTracks.map(({ slug, meta }) => {
          const IconComponent = getIcon(meta.icon);
          const sections = roadmaps[slug]?.sections ?? [];
          const topicCount = sections.reduce((sum, s) => sum + s.items.length, 0);
          
          return (
            <article class="box-card" data-slug={slug}>
              {/* Box lid (opens on hover) */}
              <div class="box-card__lid">
                <div class="box-card__lid-front">
                  <span class="box-card__label box-card__label--unverified">⚠ UNVERIFIED</span>
                </div>
                <div class="box-card__lid-top"></div>
              </div>
              
              {/* Box base with PCB inside */}
              <div class="box-card__base">
                {/* PCB preview peeking out */}
                <div class="box-card__pcb-preview">
                  <div class="pcb-peek">
                    <div class="pcb-peek__traces"></div>
                  </div>
                </div>
                
                {/* Box content */}
                <div class="box-card__content">
                  <div class="box-card__header">
                    <IconComponent class="box-card__icon" />
                    <span class="box-card__title">{meta.title}</span>
                  </div>
                  
                  <p class="box-card__desc">{meta.description}</p>
                  
                  <div class="box-card__meta">
                    <span class="box-card__stat">{sections.length} sections</span>
                    <span class="box-card__stat">{topicCount} topics</span>
                  </div>
                  
                  <div class="box-card__sections">
                    {sections.map((section) => (
                      <span class="box-card__section">{section.title}</span>
                    ))}
                  </div>
                </div>
              </div>
              
              {/* Tape strips */}
              <div class="box-card__tape box-card__tape--h"></div>
              <div class="box-card__tape box-card__tape--v"></div>
            </article>
          );
        })}
      </div>

      {/* Mobile hint popup */}
      <div class="tap-hint" id="tap-hint">
        Tap again to open
      </div>
    </div>

    {/* PCB Modal */}
    <div class="pcb-modal-backdrop" id="modal-backdrop">
      <div class="pcb-modal" id="modal">
        {/* Solder mask green background with traces */}
        <div class="pcb-modal__board">
          {/* Mounting holes */}
          <div class="pcb-hole pcb-hole--tl"></div>
          <div class="pcb-hole pcb-hole--tr"></div>
          <div class="pcb-hole pcb-hole--bl"></div>
          <div class="pcb-hole pcb-hole--br"></div>
          
          {/* Decorative traces */}
          <svg class="pcb-modal__traces" id="modal-traces" viewBox="0 0 600 400">
            <!-- Populated by JS -->
          </svg>
          
          {/* Silkscreen content */}
          <div class="pcb-modal__silkscreen">
            <button class="pcb-modal__close" id="modal-close" aria-label="Close">×</button>
            
            <div class="pcb-modal__header">
              <div class="pcb-modal__chip">
                <span class="pcb-modal__chip-notch"></span>
                <span class="pcb-modal__chip-label" id="modal-title">Track Name</span>
              </div>
            </div>
            
            <p class="pcb-modal__desc" id="modal-desc"></p>
            
            <a class="pcb-modal__cta" id="modal-link" href="#">
              <span class="pcb-modal__cta-pad"></span>
              Open Roadmap →
              <span class="pcb-modal__cta-pad"></span>
            </a>
            
            <div class="pcb-modal__sections" id="modal-sections">
              <!-- Populated by JS -->
            </div>
            
            {/* Reference designator */}
            <div class="pcb-modal__refdes">
              <span>REV {VERSION}</span>
              <span>EEE-ROADMAP</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>
  <Footer />
</Layout>

<script define:vars={{ tracksData }}>
  window.tracksData = tracksData;
</script>

<script>
  interface TrackData {
    slug: string;
    title: string;
    description: string;
    href: string;
    sections: { id: string; title: string; topics: { id: string; title: string }[] }[];
  }
  
  const tracksData = (window as any).tracksData as TrackData[];
  
  const backdrop = document.getElementById('modal-backdrop')!;
  const modal = document.getElementById('modal')!;
  const modalClose = document.getElementById('modal-close')!;
  const modalTitle = document.getElementById('modal-title')!;
  const modalDesc = document.getElementById('modal-desc')!;
  const modalLink = document.getElementById('modal-link') as HTMLAnchorElement;
  const modalSections = document.getElementById('modal-sections')!;
  const tracesSvg = document.getElementById('modal-traces')!;

  let activeCard: HTMLElement | null = null;

  // Draw traces connecting elements after DOM is updated
  function drawTraces() {
    const board = document.querySelector('.pcb-modal__board') as HTMLElement;
    if (!board) return;
    
    const boardRect = board.getBoundingClientRect();
    const width = Math.round(boardRect.width);
    const height = Math.round(boardRect.height);
    
    tracesSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
    
    const COPPER = '#b8860b';
    const paths: string[] = [];
    const vias: string[] = [];
    
    // Helper: create path with 45° routing
    const trace = (d: string, opacity = 0.5, strokeWidth = 2.5) => 
      `<path d="${d}" stroke="${COPPER}" stroke-width="${strokeWidth}" fill="none" opacity="${opacity}" stroke-linecap="round" stroke-linejoin="round" />`;
    
    const via = (x: number, y: number, r = 5, opacity = 0.6) =>
      `<circle cx="${x}" cy="${y}" r="${r}" fill="${COPPER}" opacity="${opacity}" /><circle cx="${x}" cy="${y}" r="${r * 0.4}" fill="#0d4028" opacity="0.8" />`;

    // === TOP LEFT CORNER ===
    paths.push(trace(`M0,30 H15 L30,45 V70`, 0.5));
    paths.push(trace(`M0,50 H10 L25,65`, 0.4, 2));
    paths.push(trace(`M20,0 V15 L35,30 H55`, 0.5));
    paths.push(trace(`M40,0 V10 L50,20`, 0.4, 2));
    vias.push(via(30, 45));
    vias.push(via(35, 30));
    
    // === TOP RIGHT CORNER ===
    paths.push(trace(`M${width},35 H${width-20} L${width-40},55 V75`, 0.5));
    paths.push(trace(`M${width},55 H${width-15} L${width-30},70`, 0.4, 2));
    paths.push(trace(`M${width-25},0 V20 L${width-45},40`, 0.5));
    paths.push(trace(`M${width-50},0 V15 L${width-65},30 H${width-85}`, 0.4, 2));
    vias.push(via(width - 40, 55));
    vias.push(via(width - 45, 40));
    
    // === BOTTOM LEFT CORNER ===
    paths.push(trace(`M0,${height-40} H20 L40,${height-60} V${height-80}`, 0.5));
    paths.push(trace(`M0,${height-70} H15 L30,${height-85}`, 0.4, 2));
    paths.push(trace(`M25,${height} V${height-20} L45,${height-40}`, 0.5));
    vias.push(via(40, height - 60));
    vias.push(via(25, height - 20));
    
    // === BOTTOM RIGHT CORNER ===
    paths.push(trace(`M${width},${height-45} H${width-25} L${width-50},${height-70}`, 0.5));
    paths.push(trace(`M${width-30},${height} V${height-25} L${width-55},${height-50} H${width-80}`, 0.5));
    paths.push(trace(`M${width},${height-80} H${width-20} L${width-35},${height-95}`, 0.4, 2));
    vias.push(via(width - 50, height - 70));
    vias.push(via(width - 55, height - 50));
    
    // === LEFT EDGE - busy traces ===
    for (let i = 0; i < 6; i++) {
      const y = 100 + i * 50;
      if (y < height - 100) {
        const len = 25 + (i * 13) % 35;
        const drop = 15 + (i * 7) % 25;
        paths.push(trace(`M0,${y} H${len} L${len + drop},${y + drop}`, 0.35 + (i % 2) * 0.15, 2));
        if (i % 2 === 0) vias.push(via(len + drop, y + drop, 4, 0.5));
      }
    }
    
    // === RIGHT EDGE - busy traces ===
    for (let i = 0; i < 6; i++) {
      const y = 120 + i * 50;
      if (y < height - 100) {
        const len = 30 + (i * 11) % 40;
        const drop = 20 + (i * 9) % 20;
        const dir = i % 2 === 0 ? 1 : -1;
        paths.push(trace(`M${width},${y} H${width - len} L${width - len - drop},${y + drop * dir}`, 0.35 + (i % 2) * 0.15, 2));
        if (i % 3 === 0) vias.push(via(width - len - drop, y + drop * dir, 4, 0.5));
      }
    }
    
    // === HORIZONTAL RUNS with 45° jogs ===
    paths.push(trace(`M0,${height * 0.3} H40 L55,${height * 0.3 + 15} H90`, 0.3, 1.5));
    paths.push(trace(`M${width},${height * 0.4} H${width - 50} L${width - 70},${height * 0.4 - 20} H${width - 100}`, 0.3, 1.5));
    paths.push(trace(`M0,${height * 0.6} H30 L50,${height * 0.6 - 20}`, 0.3, 1.5));
    paths.push(trace(`M${width},${height * 0.7} H${width - 35} L${width - 55},${height * 0.7 + 20}`, 0.3, 1.5));
    
    // === DIAGONAL CROSS TRACES (background interest) ===
    paths.push(trace(`M60,${height - 30} L90,${height - 60} V${height - 90}`, 0.25, 1.5));
    paths.push(trace(`M${width - 70},${height - 25} L${width - 100},${height - 55}`, 0.25, 1.5));
    
    // === POWER/GROUND RAILS (thicker, top and bottom) ===
    paths.push(trace(`M50,15 H${width - 50}`, 0.2, 4));
    paths.push(trace(`M50,${height - 15} H${width - 50}`, 0.2, 4));
    
    tracesSvg.innerHTML = paths.join('\n') + '\n' + vias.join('\n');
  }

  function openModal(slug: string, cardEl: HTMLElement) {
    const data = tracksData.find(t => t.slug === slug);
    if (!data) return;

    activeCard = cardEl;
    
    modalTitle.textContent = data.title.toUpperCase();
    modalDesc.textContent = data.description;
    modalLink.href = data.href;
    
    // Build sections HTML
    modalSections.innerHTML = data.sections.map((section, sectionIndex) => `
      <div class="pcb-section" data-section-index="${sectionIndex}">
        <div class="pcb-section__header">
          <span class="pcb-section__title">${section.title}</span>
        </div>
        <ul class="pcb-section__topics">
          ${section.topics.map((topic) => `
            <li class="pcb-topic">
              <span class="pcb-topic__pad"></span>
              <span class="pcb-topic__name">${topic.title}</span>
            </li>
          `).join('')}
        </ul>
      </div>
    `).join('');

    const rect = cardEl.getBoundingClientRect();
    modal.style.setProperty('--origin-x', `${rect.left + rect.width / 2}px`);
    modal.style.setProperty('--origin-y', `${rect.top + rect.height / 2}px`);
    
    backdrop.classList.add('is-open');
    cardEl.classList.add('is-selected');
    document.body.style.overflow = 'hidden';
    
    // Draw traces after modal is visible and laid out
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        drawTraces();
      });
    });
  }

  function closeModal() {
    backdrop.classList.remove('is-open');
    if (activeCard) {
      activeCard.classList.remove('is-selected');
      activeCard = null;
    }
    document.body.style.overflow = '';
  }

  // Card click handlers
  const tapHint = document.getElementById('tap-hint');
  let hintTimeout: ReturnType<typeof setTimeout> | null = null;

  document.querySelectorAll('.box-card').forEach(card => {
    let isOpened = false;
    
    card.addEventListener('click', (e) => {
      const target = e.target as HTMLElement;
      if (target.closest('a')) return;
      
      const isMobile = window.matchMedia('(hover: none)').matches;
      
      if (isMobile && !isOpened) {
        document.querySelectorAll('.box-card').forEach(c => {
          c.classList.remove('is-opened');
        });
        card.classList.add('is-opened');
        isOpened = true;
        
        if (hintTimeout) clearTimeout(hintTimeout);
        hintTimeout = setTimeout(() => {
          if (card.classList.contains('is-opened')) {
            tapHint?.classList.add('is-visible');
            setTimeout(() => {
              tapHint?.classList.remove('is-visible');
            }, 2000);
          }
        }, 1000);
        
        return;
      }
      
      if (hintTimeout) clearTimeout(hintTimeout);
      tapHint?.classList.remove('is-visible');
      
      const slug = card.getAttribute('data-slug');
      if (slug) openModal(slug, card as HTMLElement);
    });
  });

  document.addEventListener('click', (e) => {
    const target = e.target as HTMLElement;
    if (!target.closest('.box-card')) {
      document.querySelectorAll('.box-card').forEach(c => {
        c.classList.remove('is-opened');
      });
      tapHint?.classList.remove('is-visible');
      if (hintTimeout) clearTimeout(hintTimeout);
    }
  });

  modalClose.addEventListener('click', closeModal);
  backdrop.addEventListener('click', (e) => {
    if (e.target === backdrop) closeModal();
  });
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closeModal();
  });
  
  // Redraw traces on resize
  window.addEventListener('resize', () => {
    if (backdrop.classList.contains('is-open')) {
      drawTraces();
    }
  });
</script>

<style is:global>
  /* ==================== PAGE ==================== */
  .tracks-page {
    min-height: 100vh;
  }

  .tracks-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 2rem;
  }

  /* ==================== BOX CARD ==================== */
  .box-card {
    --box-color: #d4a574;
    --box-dark: #b8956a;
    --box-light: #e6c9a8;
    --tape-color: #c9a86c;
    
    position: relative;
    cursor: pointer;
    perspective: 800px;
  }

  .box-card__base {
    position: relative;
    background: linear-gradient(145deg, var(--box-light) 0%, var(--box-color) 50%, var(--box-dark) 100%);
    border: 2px solid var(--box-dark);
    padding: 1.5rem;
    padding-top: 2rem;
    min-height: 200px;
    transition: box-shadow 0.3s ease;
  }

  /* Inner shadow to show box depth */
  .box-card__base::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 50px;
    background: linear-gradient(180deg, rgba(0,0,0,0.2) 0%, transparent 100%);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
    z-index: 0;
  }

  .box-card:hover .box-card__base::before,
  .box-card.is-opened .box-card__base::before {
    opacity: 1;
  }

  .box-card:hover .box-card__base,
  .box-card.is-opened .box-card__base {
    box-shadow: 
      inset 0 15px 30px -10px rgba(0, 0, 0, 0.25),
      inset 2px 0 8px -4px rgba(0, 0, 0, 0.15),
    inset -2px 0 8px -4px rgba(0, 0, 0, 0.15),
    0 8px 25px rgba(0, 0, 0, 0.2);
}
  .box-card:hover .box-card__base {
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
  }

  /* Lid */
  .box-card__lid {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 40px;
    z-index: 10;
    transform-style: preserve-3d;
    transform-origin: top center;
    transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
  }

  .box-card:hover .box-card__lid {
    transform: rotateX(-95deg);
  }

  .box-card__lid-front {
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 40px;
    background: linear-gradient(180deg, var(--box-light) 0%, var(--box-color) 100%);
    border: 2px solid var(--box-dark);
    border-bottom: none;
    display: flex;
    align-items: center;
    justify-content: center;
    backface-visibility: hidden;
  }

  .box-card__lid-top {
    position: absolute;
    bottom: 100%;
    left: -2px;
    right: -2px;
    height: 20px;
    background: var(--box-color);
    border: 2px solid var(--box-dark);
    border-bottom: none;
    transform-origin: bottom center;
    transform: rotateX(90deg);
  }

  /* Label on lid */
  .box-card__label {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.5625rem;
    font-weight: 700;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    padding: 0.125rem 0.5rem;
    border: 1px dashed;
  }

  .box-card__label--unverified {
    color: #b45309;
    background: #fef3c7;
    border-color: #b45309;
  }

  .box-card__label--verified {
    color: #047857;
    background: #d1fae5;
    border-color: #047857;
  }

  /* Box base shadow on hover/open */
  .box-card:hover .box-card__base,
  .box-card.is-opened .box-card__base {
    box-shadow: 
      inset 0 20px 30px -15px rgba(0, 0, 0, 0.3),
      0 8px 30px rgba(0, 0, 0, 0.2);
  }

  /* Lid gets depth when open */
  .box-card:hover .box-card__lid-front,
  .box-card.is-opened .box-card__lid-front {
    box-shadow: 
      0 10px 25px rgba(0, 0, 0, 0.4),
      inset 0 -2px 4px rgba(0, 0, 0, 0.2);
  }

  /* Lid top face */
  .box-card__lid-top {
    position: absolute;
    bottom: 100%;
    left: -2px;
    right: -2px;
    height: 25px;
    background: linear-gradient(180deg, var(--box-dark) 0%, var(--box-color) 100%);
    border: 2px solid var(--box-dark);
    border-bottom: none;
    transform-origin: bottom center;
    transform: rotateX(90deg);
  }

  /* Inner shadow to show depth of box */
  .box-card__base::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 40px;
    background: linear-gradient(180deg, rgba(0,0,0,0.15) 0%, transparent 100%);
    opacity: 0;
    transition: opacity 0.3s;
    pointer-events: none;
  }

  .box-card:hover .box-card__base::after,
  .box-card.is-opened .box-card__base::after {
    opacity: 1;
  }

  /* PCB peek styling */
  .box-card__pcb-preview {
    position: absolute;
    top: 8px;
    left: 8%;
    right: 8%;
    height: 35px;
    overflow: hidden;
    opacity: 0;
    transform: translateY(15px);
    transition: opacity 0.3s ease 0.15s, transform 0.3s ease 0.15s;
    z-index: 2;
  }

  .box-card:hover .box-card__pcb-preview {
    opacity: 1;
    transform: translateY(0);
  }

  .pcb-peek {
    height: 70px;
    background: #1a5c38;
    border: 2px solid #0d4028;
    border-radius: 2px;
    box-shadow: 
      inset 0 -10px 20px rgba(0, 0, 0, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.2);
    position: relative;
  }

  .pcb-peek__traces {
    position: absolute;
    inset: 0;
    background: 
      linear-gradient(90deg, transparent 8px, #b8860b 8px, #b8860b 9px, transparent 9px),
      linear-gradient(0deg, transparent 8px, #b8860b 8px, #b8860b 9px, transparent 9px);
    background-size: 12px 12px;
    opacity: 0.25;
  }

  /* Tape */
  .box-card__tape {
    position: absolute;
    background: var(--tape-color);
    opacity: 0.6;
    z-index: 5; /* Below lid (10) */
    pointer-events: none;
    transition: opacity 0.3s;
  }

  .box-card__tape--h {
    top: 38px; /* Move below lid */
    left: 15%;
    right: 15%;
    height: 18px;
    background: linear-gradient(
      180deg,
      transparent 0%,
      var(--tape-color) 15%,
      var(--tape-color) 85%,
      transparent 100%
    );
  }

  .box-card__tape--v {
    display: none; /* Remove vertical tape, too cluttered */
  }

  .box-card:hover .box-card__tape {
    opacity: 0.2;
  }

  /* PCB Preview (peeking out) */
  .box-card__pcb-preview {
    position: absolute;
    top: 0;
    left: 10%;
    right: 10%;
    height: 30px;
    overflow: hidden;
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.3s ease 0.1s, transform 0.3s ease 0.1s;
  }

  .box-card:hover .box-card__pcb-preview {
    opacity: 1;
    transform: translateY(0);
  }

  .pcb-peek {
    height: 60px;
    background: #1a5c38;
    border: 2px solid #0d4028;
    border-radius: 2px;
  }

  .pcb-peek__traces {
    height: 100%;
    background: repeating-linear-gradient(
      90deg,
      transparent,
      transparent 8px,
      #b8860b 8px,
      #b8860b 9px
    );
    opacity: 0.3;
  }

  /* Box content */
  .box-card__content {
    position: relative;
    z-index: 1;
  }

  .box-card__header {
    display: flex;
    align-items: center;
    gap: 0.625rem;
    margin-bottom: 0.5rem;
  }

  .box-card__icon {
    width: 1.25rem;
    height: 1.25rem;
    color: #5d4e37;
    flex-shrink: 0;
  }

  .box-card__title {
    font-family: "IBM Plex Mono", monospace;
    font-size: 1rem;
    font-weight: 700;
    color: #3d2e1f;
  }

  .box-card__desc {
    font-size: 0.8125rem;
    color: #5d4e37;
    line-height: 1.5;
    margin-bottom: 0.75rem;
  }

  .box-card__meta {
    display: flex;
    gap: 1rem;
    margin-bottom: 0.75rem;
  }

  .box-card__stat {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.6875rem;
    color: #8b7355;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .box-card__sections {
    display: flex;
    flex-wrap: wrap;
    gap: 0.375rem;
    padding-top: 0.75rem;
    border-top: 1px dashed #b8956a;
  }

  .box-card__section {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.5625rem;
    text-transform: uppercase;
    letter-spacing: 0.03em;
    color: #5d4e37;
    padding: 0.1875rem 0.375rem;
    background: rgba(255, 255, 255, 0.3);
    border: 1px solid #b8956a;
  }

  /* Mobile tap-to-open state */
  .box-card.is-opened .box-card__lid {
    transform: rotateX(-95deg);
  }

  .box-card.is-opened .box-card__base {
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
  }

  .box-card.is-opened .box-card__pcb-preview {
    opacity: 1;
    transform: translateY(0);
  }

  .box-card.is-opened .box-card__tape {
    opacity: 0.2;
  }

  .box-card.is-opened .box-card__lid-front {
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
  }

  /* ==================== PCB MODAL ==================== */
  .pcb-modal-backdrop {
    position: fixed;
    inset: 0;
    z-index: 9999;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    background: rgba(0, 0, 0, 0);
    visibility: hidden;
    transition: background 0.3s ease, visibility 0.3s;
  }

  .pcb-modal-backdrop.is-open {
    background: rgba(0, 0, 0, 0.7);
    visibility: visible;
  }

  .pcb-modal {
    --origin-x: 50%;
    --origin-y: 50%;
    
    width: 100%;
    max-width: 600px;
    max-height: 85vh;
    overflow-y: auto;
    transform: scale(0.7) rotateX(20deg);
    opacity: 0;
    transition: 
      transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
      opacity 0.3s ease;
  }

  .pcb-modal-backdrop.is-open .pcb-modal {
    transform: scale(1) rotateX(0deg);
    opacity: 1;
  }

  /* The actual PCB board */
  .pcb-modal__board {
    --pcb-green: #1a5c38;
    --pcb-green-light: #228b4a;
    --pcb-copper: #b8860b;
    --pcb-gold: #daa520;
    --pcb-silkscreen: #f5f5f0;
    
    position: relative;
    background: var(--pcb-green);
    border: 3px solid #0d4028;
    border-radius: 4px;
    padding: 1.5rem;
    box-shadow: 
      0 4px 8px rgba(0, 0, 0, 0.3),
      inset 0 1px 0 rgba(255, 255, 255, 0.1);
  }

  /* Mounting holes */
  .pcb-hole {
    position: absolute;
    width: 14px;
    height: 14px;
    border: 3px solid var(--pcb-copper);
    border-radius: 50%;
    background: #111;
  }

  .pcb-hole::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 6px;
    height: 6px;
    background: #333;
    border-radius: 50%;
  }

  .pcb-hole--tl { top: 8px; left: 8px; }
  .pcb-hole--tr { top: 8px; right: 8px; }
  .pcb-hole--bl { bottom: 8px; left: 8px; }
  .pcb-hole--br { bottom: 8px; right: 8px; }

  /* Traces SVG */
  .pcb-modal__traces {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0; /* Behind silkscreen content */
  }

  .pcb-modal__traces path {
    fill: none;
  }

  .pcb-modal__traces circle {
    /* styles applied inline */
  }

  /* Silkscreen layer */
  .pcb-modal__silkscreen {
    position: relative;
    z-index: 1;
    color: var(--pcb-silkscreen);
  }

  .pcb-modal__close {
    position: absolute;
    top: 0;
    right: 0;
    width: 32px;
    height: 32px;
    background: var(--pcb-copper);
    border: none;
    color: #111;
    font-size: 1.25rem;
    font-weight: bold;
    cursor: pointer;
    transition: background 0.2s;
  }

  .pcb-modal__close:hover {
    background: var(--pcb-gold);
  }

  /* Chip header */
  .pcb-modal__header {
    margin-bottom: 1rem;
    padding-right: 2.5rem;
  }

  .pcb-modal__chip {
    display: inline-flex;
    align-items: center;
    gap: 0.75rem;
    background: #111;
    padding: 0.5rem 1rem;
    border: 1px solid #333;
    position: relative;
  }

  .pcb-modal__chip::before,
  .pcb-modal__chip::after {
    content: '';
    position: absolute;
    left: -6px;
    width: 4px;
    height: 8px;
    background: var(--pcb-copper);
  }

  .pcb-modal__chip::before { top: 25%; }
  .pcb-modal__chip::after { bottom: 25%; }

  .pcb-modal__chip-notch {
    width: 8px;
    height: 8px;
    border: 2px solid #444;
    border-radius: 50%;
    background: #222;
  }

  .pcb-modal__chip-label {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.875rem;
    font-weight: 600;
    letter-spacing: 0.1em;
  }

  .pcb-modal__desc {
    font-size: 0.875rem;
    line-height: 1.6;
    margin-bottom: 1rem;
    opacity: 0.9;
  }

  /* CTA button as a component */
  .pcb-modal__cta {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 1rem;
    background: var(--pcb-copper);
    color: #111;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.8125rem;
    font-weight: 600;
    text-decoration: none;
    margin-bottom: 1.5rem;
    transition: background 0.2s, transform 0.2s;
  }

  .pcb-modal__cta:hover {
    background: var(--pcb-gold);
    transform: translateY(-2px);
  }

  .pcb-modal__cta-pad {
    width: 6px;
    height: 6px;
    background: #111;
    border-radius: 1px;
  }

  /* ==================== PCB SECTIONS (IC + SMD Layout) ==================== */
  .pcb-modal__sections {
    display: flex;
    flex-direction: column;
    gap: 1.25rem;
    position: relative;
    z-index: 2;
  }

  /* Container for each section group */
  .pcb-section {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  /* Section header = IC Chip */
  .pcb-section__header {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.875rem;
    background: linear-gradient(180deg, #1a1a1a 0%, #0a0a0a 100%);
    border: 2px solid #333;
    border-radius: 2px;
    width: fit-content;
    position: relative;
    box-shadow: 
      0 3px 8px rgba(0, 0, 0, 0.5),
      inset 0 1px 0 rgba(255, 255, 255, 0.05);
  }

  /* IC notch/dot */
  .pcb-section__header::before {
    content: '';
    width: 8px;
    height: 8px;
    background: radial-gradient(circle, #333 30%, #1a1a1a 70%);
    border-radius: 50%;
    border: 1px solid #444;
    flex-shrink: 0;
  }

  /* IC pins on left */
  .pcb-section__header::after {
    content: '';
    position: absolute;
    left: -8px;
    top: 50%;
    transform: translateY(-50%);
    width: 8px;
    height: 60%;
    background: repeating-linear-gradient(
      180deg,
      transparent 0px,
      transparent 3px,
      var(--pcb-copper) 3px,
      var(--pcb-copper) 6px,
      transparent 6px,
      transparent 9px
    );
  }

  .pcb-section__icon {
    display: none;
  }

  .pcb-section__title {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.6875rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    color: #ccc;
  }

  /* Topics container = SMD components layout */
  .pcb-section__topics {
    list-style: none;
    margin: 0;
    padding: 0;
    padding-left: 1rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.375rem;
    position: relative;
  }

  /* Trace from IC to topics area */
  .pcb-section__topics::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    bottom: 0;
    width: 3px;
    background: linear-gradient(
      180deg,
      var(--pcb-copper) 0%,
      var(--pcb-copper) 85%,
      transparent 100%
    );
    opacity: 0.5;
    border-radius: 2px;
  }

  /* Topic = SMD component */
  .pcb-topic {
    display: inline-flex;
    align-items: center;
    gap: 0.375rem;
    padding: 0.3125rem 0.5rem;
    background: linear-gradient(180deg, #1f1f1f 0%, #141414 100%);
    border: 1px solid #2a2a2a;
    border-radius: 2px;
    font-size: 0.6875rem;
    transition: all 0.15s;
    position: relative;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }

  .pcb-topic:hover {
    background: linear-gradient(180deg, #2a2a2a 0%, #1a1a1a 100%);
    border-color: var(--pcb-copper);
    transform: translateY(-1px);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
  }

  /* SMD pads on sides */
  .pcb-topic__pad {
    width: 4px;
    height: 10px;
    background: linear-gradient(180deg, #d4a84b 0%, #b8860b 50%, #8a6508 100%);
    border-radius: 1px;
    flex-shrink: 0;
    box-shadow: 0 0 2px rgba(184, 134, 11, 0.5);
  }

  .pcb-topic__name {
    color: rgba(245, 245, 240, 0.85);
    white-space: nowrap;
  }

  /* Right pad */
  .pcb-topic::after {
    content: '';
    width: 4px;
    height: 10px;
    background: linear-gradient(180deg, #d4a84b 0%, #b8860b 50%, #8a6508 100%);
    border-radius: 1px;
    box-shadow: 0 0 2px rgba(184, 134, 11, 0.5);
  }

  /* Section divider line */
  .pcb-section:not(:last-child)::after {
    content: '';
    display: block;
    margin-top: 0.75rem;
    height: 1px;
    background: linear-gradient(
      90deg,
      transparent 0%,
      rgba(184, 134, 11, 0.3) 10%,
      rgba(184, 134, 11, 0.3) 90%,
      transparent 100%
    );
  }

  /* Reference designator */
  .pcb-modal__refdes {
    display: flex;
    justify-content: space-between;
    margin-top: 1rem;
    padding-top: 0.75rem;
    border-top: 1px solid rgba(255, 255, 255, 0.1);
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.5625rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    opacity: 0.6;
    color: var(--pcb-silkscreen);
  }

  /* ==================== DARK MODE ==================== */

  :global(.dark) .box-card {
    --box-color: #6b5a4d;
    --box-dark: #4a3f36;
    --box-light: #8b7a6b;
    --tape-color: #7a6850;
  }

  :global(.dark) .box-card__title { 
    color: #f5f0e8; 
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }
  :global(.dark) .box-card__desc { 
    color: #e0d8cc; 
  }
  :global(.dark) .box-card__icon { 
    color: #d4c4a8; 
  }
  :global(.dark) .box-card__stat {
    color: #c4b89c;
  }
  :global(.dark) .box-card__section {
    color: #e0d8cc;
    background: rgba(0, 0, 0, 0.25);
    border-color: #5a4a3a;
  }
  :global(.dark) .box-card__label--unverified {
    background: #4a3520;
    color: #f0c060;
    border-color: #6a4a20;
  }

  /* ==================== RESPONSIVE ==================== */
  @media (max-width: 640px) {
    .tracks-grid {
      gap: 1.5rem;
    }

    .pcb-modal {
      max-height: 90vh;
    }

    .pcb-modal__board {
      padding: 1rem;
    }
  }

  .instruction-mobile {
    display: none;
  }

  @media (hover: none) {
    .instruction-desktop {
      display: none;
    }
    .instruction-mobile {
      display: inline;
    }
  }

  .tap-hint {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: var(--color-copper);
    color: white;
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, transform 0.3s, visibility 0.3s;
    z-index: 1000;
    pointer-events: none;
  }

  .tap-hint.is-visible {
    opacity: 1;
    visibility: visible;
    transform: translateX(-50%) translateY(0);
  }

  /* DEBUG - Force styles */
.pcb-section {
  display: flex !important;
  flex-direction: column !important;
  gap: 0.5rem !important;
  margin-bottom: 1rem !important;
}

.pcb-section__header {
  display: inline-flex !important;
  background: #0a0a0a !important;
  border: 2px solid #444 !important;
  padding: 0.5rem 0.875rem !important;
  width: fit-content !important;
}

.pcb-section__topics {
  display: flex !important;
  flex-wrap: wrap !important;
  gap: 0.5rem !important;
  padding-left: 1rem !important;
}

.pcb-topic {
  display: inline-flex !important;
  background: #141414 !important;
  border: 1px solid #333 !important;
  padding: 0.375rem 0.5rem !important;
  border-radius: 2px !important;
  align-items: center !important;
  gap: 0.375rem !important;
}

.pcb-topic__pad {
  width: 4px !important;
  height: 12px !important;
  background: #b8860b !important;
  display: block !important;
}

.pcb-topic::after {
  content: '' !important;
  width: 4px !important;
  height: 12px !important;
  background: #b8860b !important;
  display: block !important;
}
</style>