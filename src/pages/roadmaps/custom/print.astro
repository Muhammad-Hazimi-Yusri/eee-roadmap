---
import PrintLayout from '../../../layouts/PrintLayout.astro';
---

<PrintLayout title="Custom Track - Print">
  <div class="print-page" id="print-page">
    <!-- Sidebar: checkbox tree (built client-side) -->
    <aside class="print-sidebar no-print" id="print-sidebar">
      <a href="#" class="print-back-link" id="back-link">&larr; Back to track</a>
      <h2 class="print-sidebar-title">Print Mode</h2>

      <label class="print-tree-item print-tree-track">
        <input type="checkbox" data-select-all />
        <span>Select all</span>
      </label>

      <div class="print-tree" id="print-tree">
        <!-- Built client-side -->
      </div>

      <button class="btn print-btn" id="print-btn">Print / Save as PDF</button>
    </aside>

    <!-- Preview area -->
    <main class="print-preview">
      <div class="print-header" id="print-header">
        <h1 class="print-title" id="print-title">Loading...</h1>
        <p class="print-meta" id="print-meta"></p>
        <p class="print-url" id="print-url"></p>
      </div>

      <div class="print-empty-msg" id="print-empty-msg">
        Select items from the sidebar to preview them here.
      </div>

      <div id="print-content">
        <!-- Sections built client-side -->
      </div>
    </main>
  </div>

  <!-- Error state -->
  <div id="print-error" class="print-error-msg" hidden>
    <p>Custom track not found.</p>
    <a href="/roadmaps/" class="btn">&larr; Back to tracks</a>
  </div>
</PrintLayout>

<script>
  import { loadCustomContent } from '../../../lib/sync';
  import { marked } from 'marked';
  import markedKatex from 'marked-katex-extension';

  // Configure marked for client-side parsing (no fs-dependent PDF manifest)
  marked.use(markedKatex({ throwOnError: false }));

  function escapeHtml(str: string): string {
    return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  }

  function parseNotesClient(markdown: string): string {
    return marked.parse(markdown, { async: false }) as string;
  }

  async function init() {
    const params = new URLSearchParams(window.location.search);
    const slug = params.get('track');

    if (!slug) {
      showError();
      return;
    }

    // Set back link
    const backLink = document.getElementById('back-link') as HTMLAnchorElement;
    if (backLink) backLink.href = `/roadmaps/custom/?track=${slug}`;

    try {
      const content = await loadCustomContent();
      const track = content.tracks?.[slug];

      if (!track) {
        showError();
        return;
      }

      // Clean up null items
      track.sections = (track.sections || []).map((section: any) => ({
        ...section,
        items: (section.items || []).filter((item: any) => item !== null)
      }));

      const sections = track.sections;

      // Count totals
      let totalTopics = 0;
      let totalConcepts = 0;
      for (const section of sections) {
        totalTopics += section.items.length;
        for (const item of section.items) {
          totalConcepts += item.concepts?.length ?? 0;
        }
      }

      // Update header
      const titleEl = document.getElementById('print-title');
      const metaEl = document.getElementById('print-meta');
      const urlEl = document.getElementById('print-url');
      if (titleEl) titleEl.textContent = track.meta.title;
      if (metaEl) metaEl.textContent = `${sections.length} sections \u00b7 ${totalTopics} topics \u00b7 ${totalConcepts} concepts`;
      if (urlEl) urlEl.textContent = `eee-roadmap.muhammadhazimiyusri.uk/roadmaps/custom/?track=${slug}`;

      // Parse concept notes
      const conceptNotesMap: Record<string, Record<string, string>> = {};
      for (const section of sections) {
        for (const item of section.items) {
          if (item.concepts) {
            conceptNotesMap[item.id] = {};
            for (const concept of item.concepts) {
              if (concept.notes) {
                conceptNotesMap[item.id][concept.name] = parseNotesClient(concept.notes);
              }
            }
          }
        }
      }

      // Build sidebar tree
      const tree = document.getElementById('print-tree')!;
      tree.innerHTML = sections.map((section: any) => `
        <div class="print-tree-section">
          <label class="print-tree-item print-tree-item--section">
            <input type="checkbox" data-section-check="${escapeHtml(section.id)}" />
            <span>${escapeHtml(section.title)}</span>
          </label>
          <div class="print-tree-children">
            ${section.items.map((item: any) => `
              <div class="print-tree-topic">
                <label class="print-tree-item print-tree-item--topic">
                  <input type="checkbox"
                    data-topic-check="${escapeHtml(item.id)}"
                    data-parent-section="${escapeHtml(section.id)}"
                  />
                  <span>${escapeHtml(item.title)}</span>
                </label>
                ${item.concepts && item.concepts.length > 0 ? `
                  <div class="print-tree-children">
                    ${item.concepts.map((c: any) => `
                      <label class="print-tree-item print-tree-item--concept">
                        <input type="checkbox"
                          data-concept-check="${escapeHtml(item.id)}:${escapeHtml(c.name)}"
                          data-parent-topic="${escapeHtml(item.id)}"
                          data-parent-section="${escapeHtml(section.id)}"
                        />
                        <span>${escapeHtml(c.name)}</span>
                      </label>
                    `).join('')}
                  </div>
                ` : ''}
              </div>
            `).join('')}
          </div>
        </div>
      `).join('');

      // Build preview content
      const contentEl = document.getElementById('print-content')!;
      contentEl.innerHTML = sections.map((section: any) => `
        <div class="print-section" data-print-section="${escapeHtml(section.id)}" hidden>
          <h2 class="print-section-title">${escapeHtml(section.title)}</h2>
          ${section.items.map((item: any) => {
            const prereqs = (item.prerequisites || []).map((p: string) => {
              const parts = p.split('/');
              return parts.length >= 2
                ? (parts.length > 2 ? parts.slice(2).join('/') : parts[1].replace(/-/g, ' '))
                : p;
            });

            return `
              <div class="print-topic" data-print-topic="${escapeHtml(item.id)}" hidden>
                <h3 class="print-topic-title">
                  ${escapeHtml(item.title)}
                  ${item.optional ? '<span class="print-optional-badge">optional</span>' : ''}
                </h3>
                <p class="print-description">${escapeHtml(item.description || '')}</p>

                ${prereqs.length > 0 ? `
                  <div class="print-field">
                    <span class="print-field-label">Prerequisites:</span>
                    <span class="print-field-value">${prereqs.map(escapeHtml).join(', ')}</span>
                  </div>
                ` : ''}

                ${item.outcomes && item.outcomes.length > 0 ? `
                  <div class="print-field">
                    <span class="print-field-label">You'll learn to:</span>
                    <ul class="print-outcomes">
                      ${item.outcomes.map((o: string) => `<li>${escapeHtml(o)}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}

                ${item.concepts && item.concepts.length > 0 ? `
                  <div class="print-concepts-area">
                    ${item.concepts.map((c: any) => `
                      <div class="print-concept" data-print-concept="${escapeHtml(item.id)}:${escapeHtml(c.name)}" hidden>
                        <span class="print-concept-name">${escapeHtml(c.name)}</span>
                        ${conceptNotesMap[item.id]?.[c.name] ? `
                          <div class="print-concept-notes">${conceptNotesMap[item.id][c.name]}</div>
                        ` : ''}
                      </div>
                    `).join('')}
                  </div>
                ` : ''}

                ${item.resources && item.resources.length > 0 ? `
                  <div class="print-field">
                    <span class="print-field-label">Resources:</span>
                    <ul class="print-resources">
                      ${item.resources.map((r: any) => `
                        <li>
                          <span class="print-resource-label">${escapeHtml(r.label)}</span>
                          <span class="print-resource-url">${escapeHtml(r.url)}</span>
                        </li>
                      `).join('')}
                    </ul>
                  </div>
                ` : ''}
              </div>
            `;
          }).join('')}
        </div>
      `).join('');

      // Wire up checkbox logic (same as PrintRoadmap.astro)
      initCheckboxes();

    } catch (err) {
      console.error('Failed to load custom track for print:', err);
      showError();
    }
  }

  function showError() {
    const page = document.getElementById('print-page');
    const error = document.getElementById('print-error');
    if (page) page.hidden = true;
    if (error) error.hidden = false;
  }

  function initCheckboxes() {
    const selectAll = document.querySelector<HTMLInputElement>('[data-select-all]');
    const sectionChecks = document.querySelectorAll<HTMLInputElement>('[data-section-check]');
    const topicChecks = document.querySelectorAll<HTMLInputElement>('[data-topic-check]');
    const conceptChecks = document.querySelectorAll<HTMLInputElement>('[data-concept-check]');
    const printBtn = document.getElementById('print-btn');
    const emptyMsg = document.getElementById('print-empty-msg');

    function updatePreview() {
      document.querySelectorAll<HTMLElement>('[data-print-section]').forEach(el => {
        const id = el.dataset.printSection!;
        const hasCheckedTopic = document.querySelector<HTMLInputElement>(
          `[data-topic-check][data-parent-section="${id}"]:checked`
        );
        const hasCheckedConcept = document.querySelector<HTMLInputElement>(
          `[data-concept-check][data-parent-section="${id}"]:checked`
        );
        el.hidden = !hasCheckedTopic && !hasCheckedConcept;
      });

      document.querySelectorAll<HTMLElement>('[data-print-topic]').forEach(el => {
        const id = el.dataset.printTopic!;
        const topicCheck = document.querySelector<HTMLInputElement>(`[data-topic-check="${id}"]`);
        const hasCheckedConcept = document.querySelector<HTMLInputElement>(
          `[data-concept-check][data-parent-topic="${id}"]:checked`
        );
        el.hidden = !topicCheck?.checked && !hasCheckedConcept;
      });

      document.querySelectorAll<HTMLElement>('[data-print-concept]').forEach(el => {
        const key = el.dataset.printConcept!;
        const check = document.querySelector<HTMLInputElement>(`[data-concept-check="${CSS.escape(key)}"]`);
        el.hidden = !check?.checked;
      });

      const anyChecked = document.querySelector<HTMLInputElement>(
        '[data-concept-check]:checked, [data-topic-check]:checked'
      );
      if (emptyMsg) emptyMsg.hidden = !!anyChecked;
    }

    function updateParentStates() {
      topicChecks.forEach(tc => {
        const topicId = tc.dataset.topicCheck!;
        const children = document.querySelectorAll<HTMLInputElement>(
          `[data-concept-check][data-parent-topic="${topicId}"]`
        );
        if (children.length === 0) return;
        const checkedCount = Array.from(children).filter(c => c.checked).length;
        tc.checked = checkedCount === children.length;
        tc.indeterminate = checkedCount > 0 && checkedCount < children.length;
      });

      sectionChecks.forEach(sc => {
        const sectionId = sc.dataset.sectionCheck!;
        const children = document.querySelectorAll<HTMLInputElement>(
          `[data-topic-check][data-parent-section="${sectionId}"]`
        );
        if (children.length === 0) return;
        const allChecked = Array.from(children).every(c => c.checked && !c.indeterminate);
        const someChecked = Array.from(children).some(c => c.checked || c.indeterminate);
        sc.checked = allChecked;
        sc.indeterminate = someChecked && !allChecked;
      });

      if (selectAll) {
        const allChecked = Array.from(sectionChecks).every(c => c.checked && !c.indeterminate);
        const someChecked = Array.from(sectionChecks).some(c => c.checked || c.indeterminate);
        selectAll.checked = allChecked;
        selectAll.indeterminate = someChecked && !allChecked;
      }
    }

    selectAll?.addEventListener('change', () => {
      const checked = selectAll.checked;
      sectionChecks.forEach(c => { c.checked = checked; c.indeterminate = false; });
      topicChecks.forEach(c => { c.checked = checked; c.indeterminate = false; });
      conceptChecks.forEach(c => { c.checked = checked; });
      updatePreview();
    });

    sectionChecks.forEach(sc => {
      sc.addEventListener('change', () => {
        const sectionId = sc.dataset.sectionCheck!;
        const checked = sc.checked;
        sc.indeterminate = false;
        document.querySelectorAll<HTMLInputElement>(
          `[data-topic-check][data-parent-section="${sectionId}"]`
        ).forEach(tc => { tc.checked = checked; tc.indeterminate = false; });
        document.querySelectorAll<HTMLInputElement>(
          `[data-concept-check][data-parent-section="${sectionId}"]`
        ).forEach(cc => { cc.checked = checked; });
        updateParentStates();
        updatePreview();
      });
    });

    topicChecks.forEach(tc => {
      tc.addEventListener('change', () => {
        const topicId = tc.dataset.topicCheck!;
        const checked = tc.checked;
        tc.indeterminate = false;
        document.querySelectorAll<HTMLInputElement>(
          `[data-concept-check][data-parent-topic="${topicId}"]`
        ).forEach(cc => { cc.checked = checked; });
        updateParentStates();
        updatePreview();
      });
    });

    conceptChecks.forEach(cc => {
      cc.addEventListener('change', () => {
        updateParentStates();
        updatePreview();
      });
    });

    printBtn?.addEventListener('click', () => window.print());
  }

  init();
</script>

<style is:global>
  /* ========================================
     PRINT PAGE LAYOUT
     ======================================== */
  .print-page {
    display: flex;
    min-height: 100vh;
  }

  /* Sidebar */
  .print-sidebar {
    position: sticky;
    top: 0;
    width: 300px;
    min-width: 300px;
    height: 100vh;
    overflow-y: auto;
    padding: 1.5rem 1rem;
    border-right: 2px solid var(--color-border);
    background: var(--color-bg);
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .print-back-link {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    color: var(--color-text-muted);
  }

  .print-sidebar-title {
    font-size: 1rem;
    margin: 0;
  }

  .print-tree {
    flex: 1;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .print-tree-item {
    display: flex;
    align-items: flex-start;
    gap: 0.375rem;
    font-family: "IBM Plex Mono", monospace;
    cursor: pointer;
    padding: 0.125rem 0;
  }

  .print-tree-item input[type="checkbox"] {
    margin-top: 0.2rem;
    flex-shrink: 0;
    cursor: pointer;
  }

  .print-tree-item span {
    font-size: 0.75rem;
    line-height: 1.3;
  }

  .print-tree-track {
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--color-border);
  }

  .print-tree-track span {
    font-weight: 600;
  }

  .print-tree-item--section span {
    font-weight: 600;
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    color: var(--color-copper);
  }

  .print-tree-item--topic span {
    font-size: 0.725rem;
  }

  .print-tree-item--concept span {
    font-size: 0.675rem;
    color: var(--color-text-muted);
  }

  .print-tree-children {
    padding-left: 1.25rem;
    display: flex;
    flex-direction: column;
    gap: 0.125rem;
  }

  .print-btn {
    margin-top: auto;
    width: 100%;
    justify-content: center;
  }

  /* Preview area */
  .print-preview {
    flex: 1;
    padding: 2rem 2.5rem;
    min-width: 0;
  }

  .print-header {
    margin-bottom: 2rem;
    padding-bottom: 1rem;
    border-bottom: 2px solid var(--color-text);
  }

  .print-title {
    font-size: 1.5rem;
    margin: 0 0 0.25rem;
  }

  .print-meta {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    color: var(--color-text-muted);
    margin: 0;
  }

  .print-url {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.65rem;
    color: var(--color-text-muted);
    margin: 0.25rem 0 0;
  }

  .print-empty-msg {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.875rem;
    color: var(--color-text-muted);
    padding: 3rem 0;
    text-align: center;
  }

  .print-error-msg {
    text-align: center;
    padding: 3rem;
    font-family: "IBM Plex Mono", monospace;
  }

  .print-error-msg p {
    margin-bottom: 1rem;
    color: var(--color-text-muted);
  }

  /* Sections */
  .print-section {
    margin-bottom: 2rem;
  }

  .print-section-title {
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    padding: 0.5rem 0.75rem;
    background: var(--color-bg-grid);
    border-left: 4px solid var(--color-copper);
    margin-bottom: 1rem;
  }

  /* Topics */
  .print-topic {
    margin-bottom: 1.25rem;
    padding: 0.75rem 1rem;
    border: 1px solid var(--color-border);
    break-inside: avoid;
  }

  .print-topic-title {
    font-size: 0.95rem;
    margin: 0 0 0.5rem;
  }

  .print-optional-badge {
    font-size: 0.6rem;
    font-weight: 400;
    color: var(--color-text-muted);
    border: 1px dashed var(--color-border);
    padding: 0.1rem 0.3rem;
    margin-left: 0.5rem;
    vertical-align: middle;
  }

  .print-description {
    font-size: 0.8rem;
    color: var(--color-text-muted);
    margin: 0 0 0.5rem;
  }

  .print-field {
    margin-bottom: 0.5rem;
  }

  .print-field-label {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.7rem;
    color: var(--color-text-muted);
    display: block;
    margin-bottom: 0.125rem;
  }

  .print-field-value {
    font-size: 0.8rem;
  }

  .print-outcomes {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .print-outcomes li {
    font-size: 0.8rem;
    padding-left: 1rem;
    position: relative;
  }

  .print-outcomes li::before {
    content: '\2192';
    position: absolute;
    left: 0;
    color: var(--color-pcb);
  }

  /* Concepts */
  .print-concepts-area {
    margin-top: 0.5rem;
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
  }

  .print-concept {
    padding: 0.375rem 0.5rem;
    background: var(--color-bg-grid);
    border: 1px solid var(--color-border);
  }

  .print-concept-name {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.75rem;
    font-weight: 600;
  }

  .print-concept-notes {
    margin-top: 0.375rem;
    font-size: 0.8rem;
    padding-left: 0.5rem;
    border-left: 2px solid var(--color-copper);
  }

  .print-concept-notes p {
    margin: 0.25rem 0;
  }

  .print-concept-notes img {
    max-width: 400px;
    max-height: 300px;
  }

  .print-concept-notes .notes-pdf-embed {
    display: none;
  }

  .print-concept-notes .glossary-link {
    color: inherit;
    text-decoration: none;
    cursor: default;
  }

  /* Resources */
  .print-resources {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .print-resources li {
    font-size: 0.75rem;
    margin-bottom: 0.125rem;
  }

  .print-resource-label {
    font-weight: 500;
  }

  .print-resource-url {
    font-family: "IBM Plex Mono", monospace;
    font-size: 0.6rem;
    color: var(--color-text-muted);
    margin-left: 0.5rem;
    word-break: break-all;
  }

  /* ========================================
     PRINT MEDIA
     ======================================== */
  @media print {
    .no-print {
      display: none !important;
    }

    .print-page {
      display: block;
    }

    body {
      background-image: none !important;
      background-color: white !important;
      color: black !important;
    }

    :root,
    :root.dark {
      --color-bg: #ffffff;
      --color-bg-grid: #f0f0f0;
      --color-text: #000000;
      --color-text-muted: #444444;
      --color-copper: #8B6914;
      --color-pcb: #2d5016;
      --color-border: #999999;
      --color-paper: #ffffff;
    }

    @page {
      size: A4;
      margin: 1.5cm;
    }

    .print-preview {
      padding: 0;
    }

    .print-topic {
      break-inside: avoid;
    }

    .print-section-title {
      break-after: avoid;
    }

    .print-concept-notes img {
      max-width: 250px;
      max-height: 200px;
    }
  }
</style>
