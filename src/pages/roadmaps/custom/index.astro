---
// src/pages/roadmaps/custom/index.astro

import Layout from '../../../layouts/Layout.astro';
import Header from '../../../components/Header.astro';
import Footer from '../../../components/Footer.astro';
import RoadmapSettings from '../../../components/RoadmapSettings.astro';
import ConceptModal from '../../../components/ConceptWindows.astro';
import { getAllTracks, roadmaps } from '../../../data';

// Build tracks structure for prerequisite picker
const officialTracksData = getAllTracks().map(({ slug, meta }) => ({
  slug,
  title: meta.title,
  isCustom: false,
  sections: (roadmaps[slug]?.sections ?? []).map(section => ({
    id: section.id,
    title: section.title,
    topics: section.items.map(item => ({
      id: item.id,
      title: item.title,
    }))
  }))
}));
---

<Layout title="Custom Track">
  <Header />
  <main class="roadmap-page">
    <div class="container py-8">
      <!-- Header section - populated client-side -->
      <div id="track-header">
        <p class="loading-placeholder">Loading custom track...</p>
      </div>

      <!-- Settings panel & concept windows -->
      <RoadmapSettings />
      <ConceptModal />

      <!-- Editor container (hidden by default) -->
      <div id="editor-container" class="editor-container" hidden>
        <div class="editor-toolbar">
          <button class="btn btn--outline" id="preview-toggle-btn">üëÅ Preview</button>
          <button class="btn btn--primary" id="save-track-btn">üíæ Save</button>
          <button class="btn btn--outline" id="cancel-edit-btn">‚úï Cancel</button>
        </div>
        <div id="editor-form" class="editor-form">
          <!-- Form fields will be injected here -->
        </div>
      </div>

      <!-- Preview container (hidden by default) -->
      <div id="preview-container" class="preview-container" hidden>
        <div class="editor-toolbar">
          <button class="btn btn--outline" id="edit-toggle-btn">‚úé Edit</button>
          <button class="btn btn--primary" id="save-track-btn-preview">üíæ Save</button>
          <button class="btn btn--outline" id="cancel-edit-btn-preview">‚úï Cancel</button>
        </div>
        <div id="preview-roadmap" class="roadmap"></div>
      </div>

      <!-- Roadmap content - populated client-side -->
      <div id="custom-roadmap-container" class="roadmap"></div>

      <!-- Error state (hidden by default) -->
      <div id="track-error" class="error-message" hidden>
        <p>Custom track not found.</p>
        <a href="/roadmaps/" class="btn">‚Üê Back to tracks</a>
      </div>
    </div>
  </main>
  <Footer />
</Layout>

<script define:vars={{ officialTracksData }}>
  window.officialTracksData = officialTracksData;
</script>

<script>
  import { loadCustomContent, saveCustomContent } from '../../../lib/sync';
  import { renderRoadmapHtml } from '../../../utils/renderRoadmap';
  import { initRoadmapInteractions } from '../../../utils/roadmapInteractions';
  import { parseNotesClient } from '../../../utils/parseNotesClient';
  import Sortable from 'sortablejs';

  // Track collapsed state
  const collapsedSections = new Set<number>();
  const collapsedTopics = new Set<string>();
  // Track Sortable instances for cleanup
  let sectionsSortable: Sortable | null = null;
  let topicsSortables: Sortable[] = [];

  function generateSlug(title: string): string {
    return title
      .toLowerCase()
      .trim()
      .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with dashes
      .replace(/^-+|-+$/g, '');      // Remove leading/trailing dashes
  }

  function exportTrack(slug: string, track: any) {
    // Get concept notes for this track
    const allConceptNotes = (window as any).conceptNotes || {};
    const trackConceptNotes: Record<string, string> = {};
    
    // Filter conceptNotes to only include this track's notes
    const trackPrefix = `${slug}/`;
    Object.entries(allConceptNotes).forEach(([key, value]) => {
      if (key.startsWith(trackPrefix)) {
        trackConceptNotes[key] = value as string;
      }
    });

    // Build export object
    const exportData = {
      meta: track.meta,
      sections: track.sections,
      ...(Object.keys(trackConceptNotes).length > 0 && { conceptNotes: trackConceptNotes })
    };

    // Create and trigger download
    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `${slug}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  async function openPrereqPicker(onSelect: (prereq: string) => void) {    // Get official tracks from window
    const officialTracks = (window as any).officialTracksData || [];
    
    // Get custom tracks from Supabase
    const customContent = await loadCustomContent();
    const customTracks = Object.entries(customContent.tracks || {}).map(([slug, track]: [string, any]) => ({
      slug,
      title: track.meta.title,
      isCustom: true,
      sections: (track.sections || []).map((section: any) => ({
        id: section.id,
        title: section.title,
        topics: (section.items || [])
          .filter((item: any) => item && item.id)
          .map((item: any) => ({
            id: item.id,
            title: item.title || '',
          }))
      }))
    }));

    // Combine all tracks
    const allTracks = [...officialTracks, ...customTracks];

    // Create modal
    const modal = document.createElement('div');
    modal.className = 'prereq-picker-modal';
    modal.innerHTML = `
      <div class="prereq-picker-backdrop"></div>
      <div class="prereq-picker-content">
        <h3 class="prereq-picker-title">Select Prerequisite</h3>
        
        <div class="prereq-picker-selects">
          <div class="prereq-picker-field">
            <label class="editor-label">Track</label>
            <select id="prereq-track" class="editor-input">
              <option value="">-- Select track --</option>
              ${officialTracks.length > 0 ? `<optgroup label="Official Tracks">
                ${officialTracks.map((t: any) => `<option value="${t.slug}" data-custom="false">${t.title}</option>`).join('')}
              </optgroup>` : ''}
              ${customTracks.length > 0 ? `<optgroup label="My Custom Tracks">
                ${customTracks.map((t: any) => `<option value="${t.slug}" data-custom="true">${t.title}</option>`).join('')}
              </optgroup>` : ''}
            </select>
          </div>

          <div class="prereq-picker-field">
            <label class="editor-label">Section</label>
            <select id="prereq-section" class="editor-input" disabled>
              <option value="">-- Select section --</option>
            </select>
          </div>

          <div class="prereq-picker-field">
            <label class="editor-label">Topic</label>
            <select id="prereq-topic" class="editor-input" disabled>
              <option value="">-- Select topic --</option>
            </select>
          </div>

          <div class="prereq-picker-field">
            <label class="editor-label">Display Label (optional)</label>
            <input type="text" id="prereq-label" class="editor-input" placeholder="Custom label..." />
          </div>
        </div>

        <div class="prereq-picker-preview">
          <span class="editor-label">Preview:</span>
          <code id="prereq-preview">-</code>
        </div>

        <div class="prereq-picker-actions">
          <button type="button" class="btn btn--outline" id="prereq-cancel">Cancel</button>
          <button type="button" class="btn btn--primary" id="prereq-confirm" disabled>Add Prerequisite</button>
        </div>
      </div>
    `;

    document.body.appendChild(modal);

    // State
    let selectedTrack: any = null;
    let selectedSection: any = null;
    let selectedTopic: any = null;

    const trackSelect = modal.querySelector('#prereq-track') as HTMLSelectElement;
    const sectionSelect = modal.querySelector('#prereq-section') as HTMLSelectElement;
    const topicSelect = modal.querySelector('#prereq-topic') as HTMLSelectElement;
    const labelInput = modal.querySelector('#prereq-label') as HTMLInputElement;
    const previewEl = modal.querySelector('#prereq-preview') as HTMLElement;
    const confirmBtn = modal.querySelector('#prereq-confirm') as HTMLButtonElement;

    function updatePreview() {
      if (!selectedTrack || !selectedTopic) {
        previewEl.textContent = '-';
        confirmBtn.disabled = true;
        return;
      }

      const prefix = selectedTrack.isCustom ? `custom:${selectedTrack.slug}` : selectedTrack.slug;
      const label = labelInput.value.trim() || selectedTopic.title;
      const prereqStr = `${prefix}/${selectedTopic.id}/${label}`;
      previewEl.textContent = prereqStr;
      confirmBtn.disabled = false;
    }

    // Track change
    trackSelect.addEventListener('change', () => {
      const slug = trackSelect.value;
      const isCustom = trackSelect.selectedOptions[0]?.dataset.custom === 'true';
      selectedTrack = allTracks.find(t => t.slug === slug && t.isCustom === isCustom) || null;
      selectedSection = null;
      selectedTopic = null;

      // Update section dropdown
      sectionSelect.innerHTML = '<option value="">-- Select section --</option>';
      if (selectedTrack) {
        selectedTrack.sections.forEach((s: any) => {
          const opt = document.createElement('option');
          opt.value = s.id;
          opt.textContent = s.title;
          sectionSelect.appendChild(opt);
        });
        sectionSelect.disabled = false;
      } else {
        sectionSelect.disabled = true;
      }

      topicSelect.innerHTML = '<option value="">-- Select topic --</option>';
      topicSelect.disabled = true;
      updatePreview();
    });

    // Section change
    sectionSelect.addEventListener('change', () => {
      const sectionId = sectionSelect.value;
      selectedSection = selectedTrack?.sections.find((s: any) => s.id === sectionId) || null;
      selectedTopic = null;

      // Update topic dropdown
      topicSelect.innerHTML = '<option value="">-- Select topic --</option>';
      if (selectedSection) {
        selectedSection.topics.forEach((t: any) => {
          const opt = document.createElement('option');
          opt.value = t.id;
          opt.textContent = t.title;
          topicSelect.appendChild(opt);
        });
        topicSelect.disabled = false;
      } else {
        topicSelect.disabled = true;
      }
      updatePreview();
    });

    // Topic change
    topicSelect.addEventListener('change', () => {
      const topicId = topicSelect.value;
      selectedTopic = selectedSection?.topics.find((t: any) => t.id === topicId) || null;
      updatePreview();
    });

    // Label change
    labelInput.addEventListener('input', updatePreview);

    // Cancel
    modal.querySelector('#prereq-cancel')?.addEventListener('click', () => {
      modal.remove();
    });

    // Backdrop click to close
    modal.querySelector('.prereq-picker-backdrop')?.addEventListener('click', () => {
      modal.remove();
    });

    // Confirm
    confirmBtn.addEventListener('click', () => {
      if (!selectedTrack || !selectedTopic) return;
      
      const prefix = selectedTrack.isCustom ? `custom:${selectedTrack.slug}` : selectedTrack.slug;
      const label = labelInput.value.trim() || selectedTopic.title;
      const prereqStr = `${prefix}/${selectedTopic.id}/${label}`;
      
      onSelect(prereqStr);
      modal.remove();
    });
  }

  function handleHashAnchor() {
    const hash = window.location.hash;
    console.log('handleHashAnchor - hash:', hash);
    if (!hash) return;
    
    const id = hash.slice(1); // Remove #
    console.log('handleHashAnchor - looking for id:', id);
    const node = document.getElementById(id);
    console.log('handleHashAnchor - found node:', node);
    if (!node) return;
    
    // Expand the topic
    const button = node.querySelector('.node-button');
    const content = node.querySelector('.node-content');
    console.log('handleHashAnchor - button:', button, 'content:', content);
    if (button && content) {
      button.setAttribute('aria-expanded', 'true');
      (content as HTMLElement).hidden = false;
    }
    
    // Scroll to it
    setTimeout(() => {
      node.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 100);
  }

  async function initCustomTrack() {
    const params = new URLSearchParams(window.location.search);
    const slug = params.get('track');
    const isEditMode = params.get('edit') === 'true';
    const isNewMode = params.get('new') === 'true';

    const header = document.getElementById('track-header');
    const container = document.getElementById('custom-roadmap-container');
    const errorEl = document.getElementById('track-error');

    // Import track from file
    const isImportMode = params.get('import') === 'true';
    if (isImportMode) {
      const importData = sessionStorage.getItem('eee-import-track');
      sessionStorage.removeItem('eee-import-track'); // Clear after reading
      
      if (!importData) {
        alert('No import data found. Please try importing again.');
        window.location.href = '/roadmaps/';
        return;
      }
      
      try {
        const track = JSON.parse(importData);
        
        // Store conceptNotes if present (will be saved with track)
        if (track.conceptNotes) {
          (window as any).importedConceptNotes = track.conceptNotes;
          delete track.conceptNotes; // Remove from track data
        }
        
        initEditor(track, null, true); // true = isImport
      } catch (err) {
        console.error('Failed to parse import data:', err);
        alert('Failed to load import data.');
        window.location.href = '/roadmaps/';
      }
      return;
    }

    // Create new track
    if (isNewMode) {
      initEditor(null); // null = new track
      return;
    }

    // Need a slug for view/edit
    if (!slug) {
      showError();
      return;
    }

    try {
      const content = await loadCustomContent();
      const track = content.tracks?.[slug];

      if (!track) {
        showError();
        return;
      }

      // Clean up any null items in sections
      track.sections = (track.sections || []).map((section: any) => ({
        ...section,
        items: (section.items || []).filter((item: any) => item !== null)
      }));

      if (isEditMode) {
        initEditor(track, slug);
        return;
      }


      // Set trackSlug for progress tracking
      (window as any).trackSlug = slug;
      (window as any).isCustomTrack = true;

      // Render header
      if (header) {
        header.innerHTML = `
          <p class="font-mono text-xs uppercase tracking-widest text-muted mb-2">// custom track</p>
          <div class="custom-track-header-row">
            <h1 class="text-3xl font-bold">${track.meta.title}</h1>
            <div class="custom-track-actions">
              <a href="/roadmaps/custom/print/?track=${slug}" class="btn btn--outline" id="print-track-btn">
                <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 6 2 18 2 18 9"/><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"/><rect x="6" y="14" width="12" height="8"/></svg>
                Print
              </a>
              <button class="btn btn--outline" id="export-track-btn">‚Üë Export</button>
              <button class="btn btn--outline" id="edit-track-btn">‚úé Edit</button>
              <button class="btn btn--outline btn--danger" id="delete-track-btn">üóë Delete</button>
            </div>
          </div>
          <p class="text-muted">${track.meta.description}</p>
        `;

        document.getElementById('edit-track-btn')?.addEventListener('click', () => {
          window.location.search = `?track=${slug}&edit=true`;
        });

        document.getElementById('export-track-btn')?.addEventListener('click', () => {
          exportTrack(slug, track);
        });

        document.getElementById('delete-track-btn')?.addEventListener('click', async () => {
          const { confirmDeleteTrack, deleteCustomTrack } = await import('../../../utils/customContent');
          const confirmed = await confirmDeleteTrack(track.meta.title);
          if (!confirmed) return;
          const success = await deleteCustomTrack(slug);
          if (success) {
            window.location.href = '/roadmaps/';
          } else {
            alert('Failed to delete track. Are you signed in?');
          }
        });
      }

      // Render roadmap
      if (container) {
        container.innerHTML = renderRoadmapHtml(track.sections);
      }

      // Build conceptData for ConceptWindows (merge conceptNotes from Supabase)
      const conceptNotes = content.conceptNotes || {};
      (window as any).conceptNotes = conceptNotes;
      buildConceptData(track.sections, slug, conceptNotes);

      // Initialize interactions for the rendered roadmap
      initRoadmapInteractions();

      // Handle hash anchor (auto-expand and scroll)
      handleHashAnchor();

    } catch (err) {
      console.error('Failed to load custom track:', err);
      showError();
    }

    function showError() {
      if (header) header.style.display = 'none';
      if (container) container.style.display = 'none';
      if (errorEl) errorEl.hidden = false;
    }
  }

 function buildConceptData(sections: any[], slug: string, conceptNotes: Record<string, string>) {
    const conceptData: Record<string, Record<string, { notesHtml?: string; isCustom?: boolean }>> = {};

    for (const section of sections) {
      for (const item of (section.items || []).filter((i: any) => i !== null)) {
        if (item.concepts?.length) {
          conceptData[item.id] = {};
          for (const concept of item.concepts) {
            const noteKey = `${slug}/${item.id}/${concept.name}`;
            // conceptNotes override track structure notes for custom concepts
            const rawNotes = conceptNotes[noteKey] || concept.notesHtml || concept.notes || '';
            conceptData[item.id][concept.name] = {
              notesHtml: rawNotes ? parseNotesClient(rawNotes) : '',
              isCustom: true,
            };
          }
        }
      }
    }

    (window as any).conceptData = conceptData;
  }

  initCustomTrack();

function initEditor(track: any, slug?: string | null, isImport: boolean = false) {
    const header = document.getElementById('track-header');
    const viewContainer = document.getElementById('custom-roadmap-container');
    const editorContainer = document.getElementById('editor-container');
    const previewContainer = document.getElementById('preview-container');

    // Hide view mode elements
    if (viewContainer) viewContainer.hidden = true;
    
    // Update header
    if (header) {
      const mode = isImport ? 'Import' : (track ? 'Edit' : 'Create');
      const title = track?.meta?.title || 'New Track';
      header.innerHTML = `
        <p class="font-mono text-xs uppercase tracking-widest text-muted mb-2">// ${mode.toLowerCase()} custom track</p>
        <h1 class="text-3xl font-bold mb-2">${title}</h1>
      `;
    }

    // Show editor
    if (editorContainer) editorContainer.hidden = false;

    // Initialize form with track data or empty template
    const editorState = track ? structuredClone(track) : getEmptyTrack();
    renderEditorForm(editorState);

    // Toggle preview
    document.getElementById('preview-toggle-btn')?.addEventListener('click', () => {
      if (editorContainer) editorContainer.hidden = true;
      if (previewContainer) previewContainer.hidden = false;
      renderPreview(editorState);
    });

    // Toggle back to edit
    document.getElementById('edit-toggle-btn')?.addEventListener('click', () => {
      if (previewContainer) previewContainer.hidden = true;
      if (editorContainer) editorContainer.hidden = false;
    });

    // Cancel buttons
    const handleCancel = () => {
      if (slug) {
        window.location.search = `?track=${slug}`;
      } else {
        window.location.href = '/roadmaps/';
      }
    };
    document.getElementById('cancel-edit-btn')?.addEventListener('click', handleCancel);
    document.getElementById('cancel-edit-btn-preview')?.addEventListener('click', handleCancel);

    // Save buttons
    const handleSave = async () => {
      // Validate required fields
      if (!editorState.meta.title.trim()) {
        alert('Title is required');
        return;
      }
      if (!editorState.meta.description.trim()) {
        alert('Description is required');
        return;
      }

      // Generate slug from title
      const newSlug = generateSlug(editorState.meta.title);
      
      // Validate slug
      if (!newSlug) {
        alert('Could not generate a valid slug from title');
        return;
      }

      try {
        // Load existing custom content
        const content = await loadCustomContent();
        
        // Check for duplicate (different track with same slug)
        const existingTrack = content.tracks[newSlug];
        if (existingTrack && newSlug !== slug) {
          alert(`A track with this title already exists: "${existingTrack.meta.title}"`);
          return;
        }
        
        // If renaming (slug changed), remove old entry
        if (slug && slug !== newSlug) {
          delete content.tracks[slug];
        }
        
        // Add/update track
        content.tracks[newSlug] = editorState;
        
        // If importing, also save the conceptNotes
        const importedNotes = (window as any).importedConceptNotes;
        if (importedNotes) {
          if (!content.conceptNotes) {
            content.conceptNotes = {};
          }
          
          // Remap conceptNotes keys to use new slug (in case title changed)
          Object.entries(importedNotes).forEach(([key, value]) => {
            // Key format: "old-slug/topic-id/concept-name"
            const parts = key.split('/');
            if (parts.length >= 3) {
              const [, ...rest] = parts; // Remove old slug
              const newKey = `${newSlug}/${rest.join('/')}`;
              content.conceptNotes![newKey] = value as string;
            }
          });
          
          // Clean up
          delete (window as any).importedConceptNotes;
        }
        
        // Save to Supabase
        const success = await saveCustomContent(content);
        
        if (success) {
          // Redirect to view mode
          window.location.href = `/roadmaps/custom/?track=${newSlug}`;
        } else {
          alert('Failed to save. Are you signed in?');
        }
      } catch (err) {
        console.error('Save error:', err);
        alert('Error saving track. Please try again.');
      }
    };
    document.getElementById('save-track-btn')?.addEventListener('click', handleSave);
    document.getElementById('save-track-btn-preview')?.addEventListener('click', handleSave);
  }

  function getEmptyTrack() {
    return {
      meta: {
        title: '',
        description: '',
        icon: 'book',
        featured: false,
        category: 'custom',
        order: 999
      },
      sections: []
    };
  }

  function renderEditorForm(state: any) {
    const form = document.getElementById('editor-form');
    if (!form) return;

    form.innerHTML = `
      <fieldset class="editor-fieldset">
        <legend class="editor-legend">Track Info</legend>
        
        <div class="editor-field">
          <label class="editor-label" for="track-title">Title *</label>
          <input 
            type="text" 
            id="track-title" 
            class="editor-input" 
            value="${state.meta.title}" 
            placeholder="e.g. Power Electronics"
            required
          />
        </div>

        <div class="editor-field">
          <label class="editor-label" for="track-description">Description *</label>
          <textarea 
            id="track-description" 
            class="editor-input editor-textarea" 
            placeholder="Brief description of what this track covers..."
            required
          >${state.meta.description}</textarea>
        </div>

        <div class="editor-field-row editor-field-row--3">
        <div class="editor-field">
          <label class="editor-label" for="track-icon">Icon</label>
          <input 
            type="text" 
            id="track-icon" 
            class="editor-input" 
            value="${state.meta.icon || 'book'}" 
            placeholder="lucide icon name"
          />
          <span class="editor-hint">See <a href="https://lucide.dev/icons/" target="_blank">lucide.dev/icons</a></span>
        </div>

        <div class="editor-field">
          <label class="editor-label" for="track-category">Category</label>
          <select id="track-category" class="editor-input">
            <option value="custom" ${state.meta.category === 'custom' ? 'selected' : ''}>Custom</option>
            <option value="core" ${state.meta.category === 'core' ? 'selected' : ''}>Core</option>
            <option value="specialization" ${state.meta.category === 'specialization' ? 'selected' : ''}>Specialization</option>
            <option value="misc" ${state.meta.category === 'misc' ? 'selected' : ''}>Misc</option>
          </select>
        </div>

        <div class="editor-field">
          <label class="editor-label" for="track-order">Order</label>
          <input 
            type="number" 
            id="track-order" 
            class="editor-input" 
            value="${state.meta.order || 999}" 
            min="0"
          />
          <span class="editor-hint">Lower = earlier in list</span>
        </div>
      </div>
      </fieldset>

      <fieldset class="editor-fieldset">
        <legend class="editor-legend">Sections</legend>
        <div id="sections-container"></div>
        <button type="button" class="btn btn--outline add-section-btn" id="add-section-btn">+ Add Section</button>
      </fieldset>
    `;

    // Bind meta field changes to state
    bindMetaFields(state);

    // Add section button (bind once here, not in bindSectionEvents)
    document.getElementById('add-section-btn')?.addEventListener('click', () => {
      state.sections.push({
        id: `section-${Date.now()}`,
        title: '',
        items: []
      });
      renderSections(state);
      // Focus the new section's title input
      const inputs = document.querySelectorAll('.editor-section-title');
      const lastInput = inputs[inputs.length - 1] as HTMLInputElement;
      lastInput?.focus();
    });
    
    // Render existing sections
    renderSections(state);
  }

  function bindMetaFields(state: any) {
    document.getElementById('track-title')?.addEventListener('input', (e) => {
      state.meta.title = (e.target as HTMLInputElement).value;
    });
    document.getElementById('track-description')?.addEventListener('input', (e) => {
      state.meta.description = (e.target as HTMLTextAreaElement).value;
    });
    document.getElementById('track-icon')?.addEventListener('input', (e) => {
      state.meta.icon = (e.target as HTMLInputElement).value;
    });
    document.getElementById('track-category')?.addEventListener('change', (e) => {
      state.meta.category = (e.target as HTMLSelectElement).value;
    });
  }

  function renderSections(state: any) {
    const container = document.getElementById('sections-container');
    if (!container) return;

    if (state.sections.length === 0) {
      container.innerHTML = '<p class="text-muted">No sections yet. Add one below.</p>';
      // Don't return early - still need to bind Add Section button
      bindSectionEvents(state);
      return;
    }

    container.innerHTML = state.sections.map((section: any, sectionIndex: number) => `
      <div class="editor-section" data-section-index="${sectionIndex}">
        <div class="editor-section-header">
          <span class="drag-handle" title="Drag to reorder">‚†ø</span>
          <button type="button" class="collapse-toggle collapse-toggle--section" data-section="${sectionIndex}" title="Toggle collapse">
            <span class="collapse-icon">‚ñº</span>
          </button>
          <input 
            type="text" 
            class="editor-input editor-section-title" 
            value="${section.title}" 
            placeholder="Section title"
            data-field="section-title"
            data-section="${sectionIndex}"
          />
          <button type="button" class="btn btn--danger btn--sm remove-section-btn" data-section="${sectionIndex}">‚úï</button>
        </div>
        
        <div class="editor-section-body" data-section-body="${sectionIndex}">
          <div class="editor-topics" id="topics-${sectionIndex}">
            ${section.items.map((item: any, topicIndex: number) => renderTopicEditor(item, sectionIndex, topicIndex)).join('')}
          </div>
          
          <button type="button" class="btn btn--outline btn--sm add-topic-btn" data-section="${sectionIndex}">+ Add Topic</button>
        </div>        
      </div>
    `).join('');

    // Bind section events
    bindSectionEvents(state);

    // Initialize drag-and-drop for sections
    const sectionsContainer = document.getElementById('sections-container');
    if (sectionsContainer) {
      // Destroy previous instance
      if (sectionsSortable) {
        sectionsSortable.destroy();
      }
      sectionsSortable = Sortable.create(sectionsContainer, {
        animation: 150,
        handle: '.drag-handle',
        ghostClass: 'sortable-ghost',
        chosenClass: 'sortable-chosen',
        forceFallback: true,
        fallbackClass: 'sortable-fallback',
        scroll: true,
        bubbleScroll: true,
        scrollSensitivity: 100,
        scrollSpeed: 15,
        onEnd: (evt) => {
          if (evt.oldIndex !== undefined && evt.newIndex !== undefined) {
            const [moved] = state.sections.splice(evt.oldIndex, 1);
            state.sections.splice(evt.newIndex, 0, moved);
          }
        }
      });
    }
    
    // Initialize drag-and-drop for topics within each section
    // Destroy previous instances
    topicsSortables.forEach(s => s.destroy());
    topicsSortables = [];
    
    state.sections.forEach((_: any, sectionIndex: number) => {
      const topicsContainer = document.getElementById(`topics-${sectionIndex}`);
      if (topicsContainer) {
        const sortable = Sortable.create(topicsContainer, {
          animation: 150,
          handle: '.drag-handle',
          ghostClass: 'sortable-ghost',
          chosenClass: 'sortable-chosen',
          forceFallback: true,
          fallbackClass: 'sortable-fallback',
          scroll: true,
          bubbleScroll: true,
          scrollSensitivity: 100,
          scrollSpeed: 15,
          onEnd: (evt) => {
            if (evt.oldIndex !== undefined && evt.newIndex !== undefined) {
              const [moved] = state.sections[sectionIndex].items.splice(evt.oldIndex, 1);
              state.sections[sectionIndex].items.splice(evt.newIndex, 0, moved);
            }
          }
        });
        topicsSortables.push(sortable);
      }
    });
  }

  function renderTopicEditor(item: any, sectionIndex: number, topicIndex: number): string {
    return `
      <div class="editor-topic" data-section="${sectionIndex}" data-topic="${topicIndex}">
        <div class="editor-topic-header">
          <span class="drag-handle" title="Drag to reorder">‚†ø</span>
          <button type="button" class="collapse-toggle collapse-toggle--topic" data-section="${sectionIndex}" data-topic="${topicIndex}" title="Toggle collapse">
            <span class="collapse-icon">‚ñº</span>
          </button>
          <input
            type="text" 
            class="editor-input editor-topic-title" 
            value="${item.title}" 
            placeholder="Topic title"
            data-field="topic-title"
            data-section="${sectionIndex}"
            data-topic="${topicIndex}"
          />
          <button type="button" class="btn btn--danger btn--sm remove-topic-btn" data-section="${sectionIndex}" data-topic="${topicIndex}">‚úï</button>
        </div>
        
        <div class="editor-topic-body" data-topic-body="${sectionIndex}-${topicIndex}">
          <textarea 
            class="editor-input editor-topic-desc" 
            placeholder="Topic description..."
            data-field="topic-description"
            data-section="${sectionIndex}"
            data-topic="${topicIndex}"
          >${item.description || ''}</textarea>
          
          <div class="editor-concepts">
            <span class="editor-label">Concepts:</span>
            <span class="editor-hint editor-hint--inline">(click concept to edit notes)</span>
            <div class="editor-concepts-list" id="concepts-${sectionIndex}-${topicIndex}">
              ${(item.concepts || []).map((c: any, conceptIndex: number) => `
                <span class="editor-concept-pill ${c.notes ? 'has-notes' : ''}" data-section="${sectionIndex}" data-topic="${topicIndex}" data-concept="${conceptIndex}" title="Click to edit notes">
                  ${c.name}
                  ${c.notes ? '<span class="concept-notes-indicator">\u00b7</span>' : ''}
                  <button type="button" class="remove-concept-btn" data-section="${sectionIndex}" data-topic="${topicIndex}" data-concept="${conceptIndex}">√ó</button>
                </span>
              `).join('')}
              <input
                type="text"
                class="editor-concept-input"
                placeholder="+ Add concept"
                data-section="${sectionIndex}"
                data-topic="${topicIndex}"
              />
            </div>
            <div class="editor-concept-notes-area" id="concept-notes-area-${sectionIndex}-${topicIndex}"></div>
          </div>

          <div class="editor-prereqs">
          <span class="editor-label">Prerequisites:</span>
          <div class="editor-prereqs-list" id="prereqs-${sectionIndex}-${topicIndex}">
            ${(item.prerequisites || []).map((prereq: string, prereqIndex: number) => `
              <span class="editor-prereq-pill" data-section="${sectionIndex}" data-topic="${topicIndex}" data-prereq="${prereqIndex}">
                ${prereq}
                <button type="button" class="remove-prereq-btn" data-section="${sectionIndex}" data-topic="${topicIndex}" data-prereq="${prereqIndex}">√ó</button>
              </span>
            `).join('')}
            <button 
              type="button"
              class="btn btn--outline btn--sm open-prereq-picker"
              data-section="${sectionIndex}"
              data-topic="${topicIndex}"
            >+ Add</button>
          </div>
        </div>

          <div class="editor-resources">
            <span class="editor-label">Resources:</span>
            <div class="editor-resources-list" id="resources-${sectionIndex}-${topicIndex}">
              ${(item.resources || []).map((r: any, resourceIndex: number) => `
                <div class="editor-resource-item" data-section="${sectionIndex}" data-topic="${topicIndex}" data-resource="${resourceIndex}">
                  <a href="${r.url}" target="_blank" class="editor-resource-link">${r.label}</a>
                  <button type="button" class="remove-resource-btn" data-section="${sectionIndex}" data-topic="${topicIndex}" data-resource="${resourceIndex}">√ó</button>
                </div>
              `).join('')}
            </div>
            <div class="editor-resource-add">
              <input 
                type="text" 
                class="editor-input editor-resource-label" 
                placeholder="Label"
                data-section="${sectionIndex}"
                data-topic="${topicIndex}"
              />
              <input 
                type="url" 
                class="editor-input editor-resource-url" 
                placeholder="https://..."
                data-section="${sectionIndex}"
                data-topic="${topicIndex}"
              />
              <button type="button" class="btn btn--outline btn--sm add-resource-btn" data-section="${sectionIndex}" data-topic="${topicIndex}">+</button>
            </div>
          </div>
        </div>
      </div>
    `;
  }

  function bindSectionEvents(state: any) {
    // Section title changes
    document.querySelectorAll('[data-field="section-title"]').forEach(input => {
      input.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        const sectionIndex = parseInt(target.dataset.section!);
        state.sections[sectionIndex].title = target.value;
        // Update ID based on title
        state.sections[sectionIndex].id = generateSlug(target.value) || `section-${Date.now()}`;
      });
    });

    // Topic title changes
    document.querySelectorAll('[data-field="topic-title"]').forEach(input => {
      input.addEventListener('input', (e) => {
        const target = e.target as HTMLInputElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        state.sections[sectionIndex].items[topicIndex].title = target.value;
        // Update ID based on title
        state.sections[sectionIndex].items[topicIndex].id = generateSlug(target.value) || `topic-${Date.now()}`;
      });
    });

    // Topic description changes
    document.querySelectorAll('[data-field="topic-description"]').forEach(input => {
      input.addEventListener('input', (e) => {
        const target = e.target as HTMLTextAreaElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        state.sections[sectionIndex].items[topicIndex].description = target.value;
      });
    });

    // Remove section
    document.querySelectorAll('.remove-section-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        state.sections.splice(sectionIndex, 1);
        renderSections(state);
      });
    });

    // Toggle section collapse
    document.querySelectorAll('.collapse-toggle--section').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const target = e.currentTarget as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const body = document.querySelector(`[data-section-body="${sectionIndex}"]`);
        const icon = target.querySelector('.collapse-icon');
        
        if (body) {
          const isCollapsed = body.classList.toggle('collapsed');
          if (icon) icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
          
          // Track state
          if (isCollapsed) {
            collapsedSections.add(sectionIndex);
          } else {
            collapsedSections.delete(sectionIndex);
          }
        }
      });
    });

    // Toggle topic collapse
    document.querySelectorAll('.collapse-toggle--topic').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const target = e.currentTarget as HTMLButtonElement;
        const sectionIndex = target.dataset.section;
        const topicIndex = target.dataset.topic;
        const key = `${sectionIndex}-${topicIndex}`;
        const body = document.querySelector(`[data-topic-body="${key}"]`);
        const icon = target.querySelector('.collapse-icon');
        
        if (body) {
          const isCollapsed = body.classList.toggle('collapsed');
          if (icon) icon.textContent = isCollapsed ? '‚ñ∂' : '‚ñº';
          
          // Track state
          if (isCollapsed) {
            collapsedTopics.add(key);
          } else {
            collapsedTopics.delete(key);
          }
        }
      });
    });

    // Restore collapsed state after re-render
    collapsedSections.forEach(sectionIndex => {
      const body = document.querySelector(`[data-section-body="${sectionIndex}"]`);
      const icon = document.querySelector(`.collapse-toggle--section[data-section="${sectionIndex}"] .collapse-icon`);
      if (body) body.classList.add('collapsed');
      if (icon) icon.textContent = '‚ñ∂';
    });

    collapsedTopics.forEach(key => {
      const body = document.querySelector(`[data-topic-body="${key}"]`);
      const [sectionIndex, topicIndex] = key.split('-');
      const icon = document.querySelector(`.collapse-toggle--topic[data-section="${sectionIndex}"][data-topic="${topicIndex}"] .collapse-icon`);
      if (body) body.classList.add('collapsed');
      if (icon) icon.textContent = '‚ñ∂';
    });

    // Add topic
    document.querySelectorAll('.add-topic-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicId = `topic-${Date.now()}`; // Temporary, will update on title change
        state.sections[sectionIndex].items.push({
          id: topicId,
          title: '',
          description: '',
          concepts: []
        });
        renderSections(state);
        // Focus the new topic's title input
        const topicInputs = document.querySelectorAll(`[data-section="${sectionIndex}"][data-field="topic-title"]`);
        const lastInput = topicInputs[topicInputs.length - 1] as HTMLInputElement;
        lastInput?.focus();
      });
    });

    // Remove topic
    document.querySelectorAll('.remove-topic-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        state.sections[sectionIndex].items.splice(topicIndex, 1);
        renderSections(state);
      });
    });

    // Add concept (on Enter)
    document.querySelectorAll('.editor-concept-input').forEach(input => {
      input.addEventListener('keydown', (e: Event) => {
        const keyEvent = e as KeyboardEvent;
        if (keyEvent.key === 'Enter') {
          keyEvent.preventDefault();
          const target = e.target as HTMLInputElement;
          const value = target.value.trim();
          if (!value) return;
          
          const sectionIndex = parseInt(target.dataset.section!);
          const topicIndex = parseInt(target.dataset.topic!);
          
          if (!state.sections[sectionIndex].items[topicIndex].concepts) {
            state.sections[sectionIndex].items[topicIndex].concepts = [];
          }
          state.sections[sectionIndex].items[topicIndex].concepts.push({ name: value });
          renderSections(state);
        }
      });
    });

    // Remove concept
    document.querySelectorAll('.remove-concept-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        const conceptIndex = parseInt(target.dataset.concept!);
        state.sections[sectionIndex].items[topicIndex].concepts.splice(conceptIndex, 1);
        renderSections(state);
      });
    });

    // Edit concept notes (click pill to toggle inline editor)
    document.querySelectorAll('.editor-concept-pill').forEach(pill => {
      pill.addEventListener('click', (e) => {
        if ((e.target as HTMLElement).classList.contains('remove-concept-btn')) return;

        const target = e.currentTarget as HTMLElement;
        const si = parseInt(target.dataset.section!);
        const ti = parseInt(target.dataset.topic!);
        const ci = parseInt(target.dataset.concept!);

        const concept = state.sections[si].items[ti].concepts[ci];
        const area = document.getElementById(`concept-notes-area-${si}-${ti}`);
        if (!area) return;

        // Toggle off if clicking same concept
        const existing = area.querySelector(`[data-notes-for="${ci}"]`);
        if (existing) {
          existing.remove();
          return;
        }

        // Close any other open editor in this topic
        area.innerHTML = '';

        area.innerHTML = `
          <div class="concept-notes-editor" data-notes-for="${ci}">
            <label class="concept-notes-label">${concept.name} ‚Äî notes (markdown)</label>
            <textarea class="editor-input concept-notes-textarea" placeholder="Enter markdown notes for this concept...">${concept.notes || ''}</textarea>
            <div class="concept-notes-actions">
              <button type="button" class="btn btn--outline btn--sm concept-notes-save">Save</button>
              <button type="button" class="btn btn--sm concept-notes-cancel">Cancel</button>
            </div>
          </div>
        `;

        const textarea = area.querySelector('.concept-notes-textarea') as HTMLTextAreaElement;
        textarea?.focus();

        area.querySelector('.concept-notes-save')?.addEventListener('click', () => {
          const notes = (area.querySelector('.concept-notes-textarea') as HTMLTextAreaElement).value.trim();
          state.sections[si].items[ti].concepts[ci].notes = notes || undefined;
          renderSections(state);
        });

        area.querySelector('.concept-notes-cancel')?.addEventListener('click', () => {
          area.innerHTML = '';
        });
      });
    });

    // Add resource
    document.querySelectorAll('.add-resource-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        
        const labelInput = document.querySelector(
          `.editor-resource-label[data-section="${sectionIndex}"][data-topic="${topicIndex}"]`
        ) as HTMLInputElement;
        const urlInput = document.querySelector(
          `.editor-resource-url[data-section="${sectionIndex}"][data-topic="${topicIndex}"]`
        ) as HTMLInputElement;
        
        const label = labelInput?.value.trim();
        const url = urlInput?.value.trim();
        
        if (!label || !url) {
          alert('Both label and URL are required');
          return;
        }
        
        if (!state.sections[sectionIndex].items[topicIndex].resources) {
          state.sections[sectionIndex].items[topicIndex].resources = [];
        }
        state.sections[sectionIndex].items[topicIndex].resources.push({ label, url });
        renderSections(state);
      });
    });

    // Remove resource
    document.querySelectorAll('.remove-resource-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        const resourceIndex = parseInt(target.dataset.resource!);
        state.sections[sectionIndex].items[topicIndex].resources.splice(resourceIndex, 1);
        renderSections(state);
      });
    });

    // Open prerequisite picker
    document.querySelectorAll('.open-prereq-picker').forEach(btn => {
      btn.addEventListener('click', async (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        
              await openPrereqPicker((prereq: string) => {
          if (!state.sections[sectionIndex].items[topicIndex].prerequisites) {
            state.sections[sectionIndex].items[topicIndex].prerequisites = [];
          }
          state.sections[sectionIndex].items[topicIndex].prerequisites.push(prereq);
          renderSections(state);
        });
      });
    });

    // Remove prerequisite
    document.querySelectorAll('.remove-prereq-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.target as HTMLButtonElement;
        const sectionIndex = parseInt(target.dataset.section!);
        const topicIndex = parseInt(target.dataset.topic!);
        const prereqIndex = parseInt(target.dataset.prereq!);
        state.sections[sectionIndex].items[topicIndex].prerequisites.splice(prereqIndex, 1);
        renderSections(state);
      });
    });
  }

  function renderPreview(state: any) {
    const preview = document.getElementById('preview-roadmap');
    if (!preview) return;

    // Set trackSlug for progress tracking (use temp slug for new tracks)
    const params = new URLSearchParams(window.location.search);
    const slug = params.get('track') || 'new-track-preview';
    (window as any).trackSlug = slug;
    (window as any).isCustomTrack = true;

    import('../../../utils/renderRoadmap').then(({ renderRoadmapHtml }) => {
      preview.innerHTML = renderRoadmapHtml(state.sections);
      
      // Initialize interactions for preview
      import('../../../utils/roadmapInteractions').then(({ initRoadmapInteractions }) => {
        initRoadmapInteractions();
      });
    });
  }
</script>

<style is:global>
  .loading-placeholder {
    font-family: var(--font-mono);
    color: var(--color-text-muted);
    padding: 2rem;
    text-align: center;
  }

  .error-message {
    text-align: center;
    padding: 3rem;
  }

  .error-message p {
    margin-bottom: 1rem;
    color: var(--color-text-muted);
  }

  .custom-track-header-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 1rem;
    margin-bottom: 0.5rem;
  }

  .edit-track-btn {
    flex-shrink: 0;
  }

  .custom-track-actions {
    display: flex;
    gap: 0.5rem;
    flex-shrink: 0;
  }

  .btn--danger {
    color: #b91c1c;
    border-color: #b91c1c;
  }

  .btn--danger:hover {
    background: #b91c1c;
    color: #fff;
  }

  .editor-container,
  .preview-container {
    margin-bottom: 2rem;
  }

  .editor-toolbar {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
    padding-bottom: 1rem;
    border-bottom: 1px dashed var(--color-border);
  }

  .editor-form {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .editor-fieldset {
    border: 1px solid var(--color-border);
    padding: 1.5rem;
    margin: 0;
  }

  .editor-legend {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    padding: 0 0.5rem;
    color: var(--color-text-muted);
  }

  .editor-field {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    margin-bottom: 1rem;
  }

  .editor-field:last-child {
    margin-bottom: 0;
  }

  .editor-field-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
  }

  .editor-label {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    font-weight: 500;
    color: var(--color-text);
  }

  .editor-input {
    font-family: inherit;
    font-size: 0.875rem;
    padding: 0.5rem 0.75rem;
    border: 1px solid var(--color-border);
    background: var(--color-bg);
    color: var(--color-text);
  }

  .editor-input:focus {
    outline: none;
    border-color: var(--color-copper);
  }

  .editor-textarea {
    min-height: 80px;
    resize: vertical;
  }

  .editor-hint {
    font-size: 0.7rem;
    color: var(--color-text-muted);
  }

  .editor-hint a {
    color: var(--color-copper);
  }

  .add-section-btn {
    margin-top: 1rem;
  }

  .editor-field-row--3 {
    grid-template-columns: 1fr 1fr 1fr;
  }

  @media (width <= 640px) {
    .editor-field-row,
    .editor-field-row--3 {
      grid-template-columns: 1fr;
    }
  }

  .editor-section {
    border: 1px solid var(--color-border);
    padding: 1rem;
    margin-bottom: 1rem;
    background: var(--color-bg);
  }

  .editor-section-header {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  .editor-section-title {
    flex: 1;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .editor-topics {
    margin-left: 1rem;
    padding-left: 1rem;
    border-left: 2px solid var(--color-copper);
  }

  .editor-topic {
    margin-bottom: 1rem;
  }

  .editor-topic-header {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .editor-topic-dot {
    width: 12px;
    height: 12px;
    border: 2px solid var(--color-copper);
    border-radius: 50%;
    flex-shrink: 0;
  }

  .editor-topic-title {
    flex: 1;
    font-weight: 500;
  }

  .editor-topic-body {
    margin-left: 1.25rem;
  }

  .editor-topic-desc {
    width: 100%;
    min-height: 60px;
    margin-bottom: 0.5rem;
  }

  .editor-concepts {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.5rem;
  }

  .editor-concepts-list {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.375rem;
  }

  .editor-concept-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    background: var(--color-bg-grid);
    border: 1px solid var(--color-border);
    font-size: 0.75rem;
    font-family: var(--font-mono);
    cursor: pointer;
  }

  .editor-concept-pill .remove-concept-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--color-text-muted);
    padding: 0;
    line-height: 1;
  }

  .editor-concept-pill .remove-concept-btn:hover {
    color: var(--color-danger, #c00);
  }

  .editor-concept-input {
    border: 1px dashed var(--color-border);
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    width: 120px;
  }

  .editor-concept-pill.has-notes {
    border-color: var(--color-copper);
    background: rgb(184 115 51 / 8%);
  }

  .concept-notes-indicator {
    color: var(--color-copper);
    font-weight: 700;
    font-size: 0.65rem;
  }

  .editor-concept-notes-area {
    flex-basis: 100%;
  }

  .concept-notes-editor {
    display: flex;
    flex-direction: column;
    gap: 0.375rem;
    padding: 0.5rem;
    border: 1px solid var(--color-copper);
    background: var(--color-bg);
  }

  .concept-notes-label {
    font-family: var(--font-mono);
    font-size: 0.7rem;
    font-weight: 600;
    color: var(--color-copper);
  }

  .concept-notes-textarea {
    width: 100%;
    min-height: 100px;
    resize: vertical;
    font-size: 0.8rem;
    font-family: var(--font-mono);
  }

  .concept-notes-actions {
    display: flex;
    gap: 0.5rem;
    justify-content: flex-end;
  }

  .btn--sm {
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
  }

  .btn--danger {
    color: var(--color-danger, #c00);
    border-color: var(--color-danger, #c00);
  }

  .btn--danger:hover {
    background: var(--color-danger, #c00);
    color: white;
  }

  .custom-track-card--create {
    border-style: dashed;
    border-color: var(--color-copper);
    background: transparent;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 150px;
    transition: background 0.2s, border-color 0.2s;
  }

  .custom-track-card--create:hover {
    background: rgb(184 115 51 / 10%);
    border-color: var(--color-copper-light);
  }

  .custom-track-card--create .custom-track-card__icon {
    font-size: 2rem;
    color: var(--color-copper);
  }

  .custom-track-card--create .custom-track-card__title {
    color: var(--color-copper);
  }

  .editor-resources {
    margin-top: 0.75rem;
  }

  .editor-resources-list {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    margin: 0.5rem 0;
  }

  .editor-resource-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.25rem 0.5rem;
    background: var(--color-bg-grid);
    border: 1px solid var(--color-border);
    font-size: 0.75rem;
  }

  .editor-resource-link {
    flex: 1;
    color: var(--color-pcb);
    text-decoration: none;
    font-family: var(--font-mono);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .editor-resource-link:hover {
    text-decoration: underline;
  }

  .editor-resource-item .remove-resource-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--color-text-muted);
    padding: 0;
    line-height: 1;
  }

  .editor-resource-item .remove-resource-btn:hover {
    color: var(--color-danger, #c00);
  }

  .editor-resource-add {
    display: flex;
    gap: 0.5rem;
    align-items: center;
  }

  .editor-resource-label {
    flex: 1;
    max-width: 150px;
  }

  .editor-resource-url {
    flex: 2;
  }

  .editor-prereqs {
    margin-top: 0.75rem;
  }

  .editor-prereqs-list {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0.375rem;
    margin: 0.25rem 0;
  }

  .editor-prereq-pill {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    padding: 0.25rem 0.5rem;
    background: var(--color-copper-light);
    border: 1px solid var(--color-copper);
    font-size: 0.75rem;
    font-family: var(--font-mono);
    color: var(--color-text);
  }

  .editor-prereq-pill .remove-prereq-btn {
    background: none;
    border: none;
    cursor: pointer;
    color: var(--color-text-muted);
    padding: 0;
    line-height: 1;
  }

  .editor-prereq-pill .remove-prereq-btn:hover {
    color: var(--color-danger, #c00);
  }

  .editor-prereq-input {
    border: 1px dashed var(--color-border);
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    width: 150px;
  }

  .prereq-picker-modal {
    position: fixed;
    inset: 0;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .prereq-picker-backdrop {
    position: absolute;
    inset: 0;
    background: rgb(0 0 0 / 50%);
  }

  .prereq-picker-content {
    position: relative;
    background: var(--color-bg);
    border: 2px solid var(--color-copper);
    padding: 1.5rem;
    max-width: 500px;
    width: 90%;
    max-height: 90vh;
    overflow-y: auto;
  }

  .prereq-picker-title {
    font-family: var(--font-mono);
    font-size: 1rem;
    font-weight: 600;
    margin-bottom: 1rem;
  }

  .prereq-picker-selects {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    margin-bottom: 1rem;
  }

  .prereq-picker-field {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
  }

  .prereq-picker-preview {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem;
    background: var(--color-bg-grid);
    margin-bottom: 1rem;
  }

  .prereq-picker-preview code {
    font-family: var(--font-mono);
    font-size: 0.75rem;
    color: var(--color-copper);
    word-break: break-all;
  }

  .prereq-picker-actions {
    display: flex;
    justify-content: flex-end;
    gap: 0.5rem;
  }
</style>
